<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>狐耳的雪原 on 狐耳的雪原</title>
    <link>https://hueralin.github.io/</link>
    <description>Recent content in 狐耳的雪原 on 狐耳的雪原</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 09 Sep 2019 12:51:57 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>TCP流量控制、拥塞控制</title>
      <link>https://hueralin.github.io/2019/tcpys/</link>
      <pubDate>Mon, 09 Sep 2019 12:51:57 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/tcpys/</guid>
      <description>

&lt;p&gt;计算机网络推荐书籍：计算机网络（谢希仁）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/37379780&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;TCP流量控制、拥塞控制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在前端面试中关于计算机网络的知识多半是HTTP协议、TCP/IP协议，拥塞控制之类的。昨天看了几篇关于拥塞控制的文章，现来做一些总结。&lt;/p&gt;

&lt;h2 id=&#34;tcp流量控制&#34;&gt;TCP流量控制&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;一、 流量控制的原因&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;双方在通信时会涉及到通信速率的问题，即发送速率和处理速率，这两个速率往往是不一样的。如果发送方的发送速率太快，接收方来不及处理，就会将报文放进缓存，若发送方仍不控制发送速率，那么缓存终会爆满，导致丢包，浪费网络资源，所以应该对发送方的发送速率进行控制，使发送方和接收方达到一种动态平衡。&lt;/p&gt;

&lt;p&gt;流量控制，即控制发送方的发送速率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、滑动窗口&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;滑动窗口协议：TCP协议中的一种应用，用于网络数据传输中的流量控制。&lt;/p&gt;

&lt;p&gt;该协议允许发送方在停止并等待确认报文前发送多个数据，不必每发完一段数据就定下来等待确认，提高网络的吞吐量，所以TCP定义了一个&lt;strong&gt;滑动窗口协议&lt;/strong&gt;，滑动窗口包括&lt;strong&gt;发送窗口&lt;/strong&gt;和&lt;strong&gt;接受窗口&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关概念&lt;/strong&gt;&lt;br /&gt;
1. 窗口：一段可以被发送者连续发送的字节序列范围。&lt;br /&gt;
2. 滑动：“窗口”的大小会随着发送过程变化，这种变化是在字节序列上按顺序滑动的。&lt;/p&gt;

&lt;p&gt;因为TCP协议是全双工协议，所以双方都有一个&lt;strong&gt;发送缓冲区&lt;/strong&gt;和&lt;strong&gt;接收缓冲区&lt;/strong&gt;。&lt;br /&gt;
发送缓冲区接收来自应用层的数据（一长条字节流？），而发送窗口框住了其中的一部分（前面说了，窗口其实是一段范围）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;发送缓存区&lt;/strong&gt;相关的四个概念：&lt;br /&gt;
1. 已发送并受到确认&lt;br /&gt;
2. 已发送但未收到确认&lt;br /&gt;
3. 允许发送但未发送&lt;br /&gt;
4. 不允许发送&lt;/p&gt;

&lt;p&gt;其中，允许发送的数据都在发送窗口内。每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送。&lt;/p&gt;

&lt;p&gt;下面，我借由计算机网络（谢希仁）中的图片来讲解一下过程(后来发现copy率达到99.9%)：&lt;br /&gt;
A B 双方在建立TCP连接的时候，B就已经向A给出了自己的窗口值，发送方A会根据这个值来构造自己的发送窗口。&lt;br /&gt;
&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp01.png&#34; alt=&#34;根据B给出的窗口值，A构造自己的发送窗口&#34; /&gt;&lt;br /&gt;
发送窗口表示：在没有收到B的确认情况下，A可以连续把发送窗口中的数据都发送出去。凡是发送过的数据在未收到确认前都应留在发送窗口内，以便超时重传。&lt;/p&gt;

&lt;p&gt;发送窗口的位置由前沿和后沿的位置来确定：&lt;br /&gt;
1. 前沿：不动或前移。不动，可能是因为没有收到确认，或收到了确认但接受窗口缩小了。&lt;br /&gt;
2. 后沿：不动或前移。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp02.png&#34; alt=&#34;A发送了11个字节的数据&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A发送了11个字节的数据，但未收到新的确认，所以前沿后沿都不变，即发送窗口的位置不变。&lt;br /&gt;
看B的接收窗口，32 33 未按序到达，因为接收方发送的确认号ack是由按序到达数据的最高序号决定的，所以B返回的确认号仍然是31。导致了A的发送窗口不变。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;描述一个发送窗口的状态&lt;/strong&gt;需要三个指针：p1、p2、p3。&lt;br /&gt;
1. 小于p1：已发送且已收到确认的部分&lt;br /&gt;
2. 大于p3：不允许发送的部分&lt;br /&gt;
3. p3 - p1：发送窗口&lt;br /&gt;
4. p2 - p1：已发送但未收到确认的部分&lt;br /&gt;
5. p3 - p2：允许发送但未发送的部分，又叫“可用窗口”、“有效窗口”&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp03.png&#34; alt=&#34;A收到了新的确认号，发送窗口向前滑动&#34; /&gt;&lt;/p&gt;

&lt;p&gt;B 收到了31，然后返回确认号34，表明31 32 33 都收到了，且已交付主机。A收到确认号后，发送窗口前移，后沿前移3位指向34。指针p2不动，可用窗口变大，可发送42-53的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp04.png&#34; alt=&#34;可用窗口内的数据已全部发送，但未收到确认&#34; /&gt;&lt;br /&gt;
42-53的数据都被发送了出去，p2指针与p3指针重合，但是没有收到确认，使得可用窗口为0，A不能再发送数据，必须等到B的确认。但是B发送的确认可能在网络中延时了，没有及时到达，A就会一直等，B也会一直等待A发送数据，造成死锁。所以A有一个超时计时器机制，一段时间后没有收到B的确认，会自动重传这部分数据并重置超时计时器，直到收到B的确认为止。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、如何控制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;流量控制主要依靠滑动窗口来实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;流量控制即接收方B向发送方A传递消息，使其不要发送太快～，是一种端到端的控制。利用B返回的报文中的接收窗口的大小来控制A的发送窗口大小。rwnd: 接收窗口&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp05.png&#34; alt=&#34;利用可变窗口进行拥塞控制&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图我们也可以看到，发送窗口是连续的一段一段的发送数据，比如上面连续发送了3段数据后才返回了一个ack。&lt;/p&gt;

&lt;p&gt;B的缓存区也会有满的情况，当缓存区满了后会发送rwnd=0通知A停止发送数据。等一段时间后B的缓存区有了空会发送非0的rwnd给A，但是如果这个报文中途丢失了，A一直收不到，双方一直在互相等待，造成死锁。所以TCP引入了持续计时器，即当A收到了0接收窗口通知时，启动该计时器，时间到了就会发送一个1字节的探测报文，接收方会回应自己的接收窗口大小，若仍为0，则重设计时器，继续等待。&lt;/p&gt;

&lt;h2 id=&#34;tcp拥塞控制&#34;&gt;TCP拥塞控制&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp06.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关概念：&lt;/strong&gt;&lt;br /&gt;
1. 慢开始门限：控制使用慢开始算法还是拥塞避免算法&lt;br /&gt;
2. 拥塞窗口&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关算法&lt;/strong&gt;&lt;br /&gt;
1. 慢开始  2. 拥塞避免  3. 快重传  4. 快恢复&lt;/p&gt;

&lt;p&gt;发送方维持一个叫做“拥塞窗口”的状态变量，其大小取决于网络的拥塞程度，且会动态变化。发送方的发送窗口等于拥塞窗口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;发送方控制拥塞窗口的原则&lt;/strong&gt;：当网络没有发生拥塞时，我可以让窗口再增大一些，发出更多的分组。若出现了拥塞，就让拥塞窗口减小一些，缓解拥塞。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网络中出现拥塞的依据&lt;/strong&gt;：分组丢失/超时。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>字节跳动面试题</title>
      <link>https://hueralin.github.io/2019/bytedance/</link>
      <pubDate>Wed, 04 Sep 2019 16:18:24 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/bytedance/</guid>
      <description>

&lt;h3 id=&#34;实现sleep函数-将程序挂起一段时间-阻塞运行&#34;&gt;实现sleep函数（将程序挂起一段时间，阻塞运行）&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;我能想到的方法就是ES6的 async/await
function my_sleep (time) {
    return new Promise((resolve) =&amp;gt; {
        setTimeout(() =&amp;gt; {
            resolve()
        }, time)
    })
}
async function main() {
    console.log(&#39;start&#39;)
    await my_sleep(5000)
    console.log(&#39;end&#39;)
}
main()
网上还有一种解法，利用循环+Date()，不断的循环，检测当前时间是否超出了间隔时间  
原理就是一直在执行同步任务，阻塞下面同步任务的执行
function my_sleep (time) {
    let start = new Date().getTime()    // 一串长数字
    let end = start + time  // time是毫秒
    while(new Date().getTime() &amp;lt;= end){}
}
console.log(&#39;start&#39;)
my_sleep(5000)
console.log(&#39;end&#39;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>用友笔试题</title>
      <link>https://hueralin.github.io/2019/yongyou/</link>
      <pubDate>Wed, 04 Sep 2019 15:07:51 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/yongyou/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;21题&lt;br /&gt;
css 中经常有类似 background-image 这种通过 - 连接的字符，通过 javascript 设置样式的时候需要将这种样式转换成 backgroundImage 驼峰格式，请完成此转换功能。&lt;br /&gt;
输入：-webkit-background-image&lt;br /&gt;
输出：webkitBackgroundImage&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;解法一、  
思路：将输入按照‘-’分开，得到一个数组，例如：[&#39;&#39;, &#39;webkit&#39;, &#39;background&#39;, &#39;image&#39;]  
然后从第三个元素开始，将首字母变大写（注意字符串是不可变的）
function func(pre){
    let splitArr = pre.split(&#39;-&#39;)
    for(let i=2;i&amp;lt;splitArr.length;i++){
        splitArr[i] = splitArr[i][0].toUpperCase() + splitArr[i].slice(1)
    }
    return splitArr.join(&#39;&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;解法二、  
思路：
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;22题&lt;br /&gt;
请实现一个简单的事件机制，能够实现对事件的触发和监听。
如：EventEmitter.on(); EventEmitter.trigger();&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;思路：封装一个对象，该对象有两个方法：on、trigger。on方法接收两个参数，事件名和回调函数，如果一个事件可以绑定过个回调，可以考虑使用数组。trigger方法接受一个参数，即事件名，拿到指定事件，将该事件下的所有回调函数执行一遍。
这种写法只是实现了时间的触发和更新，并没有将事件绑定到某个元素上。
function EventEmitter () {
    let eventObj = {}

    function on (eventName, callback) {
        if (!eventObj[eventName]) {
            eventObj[eventName] = []
        }
        eventObj[eventName].push(callback)
    }

    function trigger (eventName) {
        if (!eventObj[eventName]) {
            return
        }
        for(let i=0;i&amp;lt;eventObj[eventName].length;i++){
            eventObj[eventName][i]()
        }
    }

    return {
        on: on,
        trigger: trigger
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>节流和防抖</title>
      <link>https://hueralin.github.io/2019/debounceandthrottle/</link>
      <pubDate>Tue, 03 Sep 2019 17:43:42 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/debounceandthrottle/</guid>
      <description>

&lt;h3 id=&#34;lodash-防抖源码解读&#34;&gt;lodash 防抖源码解读&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function debounce(func, wait, options) {
  let lastArgs,
    lastThis,
    maxWait,
    result,
    timerId,
    lastCallTime

  let lastInvokeTime = 0
  let leading = false
  let maxing = false
  let trailing = true

  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.
  const useRAF = (!wait &amp;amp;&amp;amp; wait !== 0 &amp;amp;&amp;amp; typeof root.requestAnimationFrame === &#39;function&#39;)

  if (typeof func !== &#39;function&#39;) {
    throw new TypeError(&#39;Expected a function&#39;)
  }
  wait = +wait || 0
  if (isObject(options)) {
    leading = !!options.leading
    maxing = &#39;maxWait&#39; in options
    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait
    trailing = &#39;trailing&#39; in options ? !!options.trailing : trailing
  }

  // 调用函数
  function invokeFunc(time) {
    const args = lastArgs
    const thisArg = lastThis

    lastArgs = lastThis = undefined
    lastInvokeTime = time
    result = func.apply(thisArg, args)
    return result
  }

  function startTimer(pendingFunc, wait) {
    if (useRAF) {
      root.cancelAnimationFrame(timerId)
      return root.requestAnimationFrame(pendingFunc)
    }
    return setTimeout(pendingFunc, wait)
  }

  function cancelTimer(id) {
    if (useRAF) {
      return root.cancelAnimationFrame(id)
    }
    clearTimeout(id)
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time
    // Start the timer for the trailing edge.
    timerId = startTimer(timerExpired, wait)
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result
  }

  function remainingWait(time) {
    const timeSinceLastCall = time - lastCallTime
    const timeSinceLastInvoke = time - lastInvokeTime
    const timeWaiting = wait - timeSinceLastCall

    return maxing
      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting
  }

  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime
    const timeSinceLastInvoke = time - lastInvokeTime

    // Either this is the first call, activity has stopped and we&#39;re at the
    // trailing edge, the system time has gone backwards and we&#39;re treating
    // it as the trailing edge, or we&#39;ve hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall &amp;gt;= wait) ||
      (timeSinceLastCall &amp;lt; 0) || (maxing &amp;amp;&amp;amp; timeSinceLastInvoke &amp;gt;= maxWait))
  }

  function timerExpired() {
    const time = Date.now()
    if (shouldInvoke(time)) {
      return trailingEdge(time)
    }
    // Restart the timer.
    timerId = startTimer(timerExpired, remainingWait(time))
  }

  function trailingEdge(time) {
    timerId = undefined

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing &amp;amp;&amp;amp; lastArgs) {
      return invokeFunc(time)
    }
    lastArgs = lastThis = undefined
    return result
  }

  function cancel() {
    if (timerId !== undefined) {
      cancelTimer(timerId)
    }
    lastInvokeTime = 0
    lastArgs = lastCallTime = lastThis = timerId = undefined
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(Date.now())
  }

  function pending() {
    return timerId !== undefined
  }

  function debounced(...args) {
    const time = Date.now()
    const isInvoking = shouldInvoke(time)

    lastArgs = args
    lastThis = this
    lastCallTime = time

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime)
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = startTimer(timerExpired, wait)
        return invokeFunc(lastCallTime)
      }
    }
    if (timerId === undefined) {
      timerId = startTimer(timerExpired, wait)
    }
    return result
  }
  debounced.cancel = cancel
  debounced.flush = flush
  debounced.pending = pending
  return debounced
}

export default debounce
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JS 事件循环</title>
      <link>https://hueralin.github.io/2019/eventloop/</link>
      <pubDate>Mon, 02 Sep 2019 18:56:56 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/eventloop/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;MDN 事件循环&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://html.spec.whatwg.org/multipage/webappapis.html#event-loops&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;详细的不知道该给这个链接命什么名好!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ahhhhhh, 这JS学的，不断刷新世界观~&lt;/p&gt;

&lt;p&gt;事件循环可谓是JS中的一大重点，如果说之前的&lt;a href=&#34;http://localhost:1313/2019/jsec/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS执行环境&lt;/a&gt;从微观角度上说明了函数内部的执行原理，那么事件循环则从宏观角度上说明了整个JS代码的执行情况。&lt;/p&gt;

&lt;p&gt;事件循环中的关键概念：执行栈、任务源、任务队列&lt;/p&gt;

&lt;h3 id=&#34;执行栈&#34;&gt;执行栈&lt;/h3&gt;

&lt;p&gt;由于JS是单线程的，一定时间内只能执行一个函数，所以这些函数就得按照一定的顺序排好队，但它并不是一个队列，因为函数调用会涉及到作用域链的问题，函数调用之间有着一定的嵌套关系，所以栈结构比较合适。那么由函数调用组成的栈，也被称为 “执行栈” ，函数被调用时压入栈，执行完毕弹出栈。结合 &lt;a href=&#34;http://localhost:1313/2019/jsec/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS执行环境&lt;/a&gt; 中所讲的内容，函数调用栈中的每一个帧都是一个执行环境，执行环境里面包含着变量对象（函数被调用时才会有）。&lt;/p&gt;

&lt;h3 id=&#34;任务源&#34;&gt;任务源&lt;/h3&gt;

&lt;p&gt;这个高大上的名词可能没见过，但是它本身却很常见。顾名思义，任务源就是分发任务的源头，绝大部分是异步任务。分发异步任务的源头有哪些呢？setTimeout ！setInterval ! promise !等等都是任务源，这些函数在被执行的时候都是立即执行的，但是它们所分发的任务需要在特定的情况下才会被执行，而这些特定的环境则需要事件循环机制来处理。任务源所分发的任务才会被放进任务队列中。&lt;/p&gt;

&lt;h3 id=&#34;任务队列&#34;&gt;任务队列&lt;/h3&gt;

&lt;p&gt;MDN 上叫“消息队列”，好像是从前的说法，讲的有些笼统。新标准下给了它们新的名字：任务队列，给异步任务做了更细致的划分。任务队列分为：“宏任务”和“微任务”。
宏任务包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI渲染。微任务包括：process.nextTick，Promise, Object.observe(已废弃), MutationObserver(html5新特性)。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;推荐两篇博客：&lt;br /&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/26229293&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;深入浅出JS事件循环机制（上）&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/26238030&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;深入浅出JS事件循环机制（下）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上面两篇博客涉及到了&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;WebpAPIs&lt;/a&gt;，文中给出了三种常见的WebAPIs，DOM相关、网络相关、定时器相关。&lt;/p&gt;

&lt;p&gt;下面用一个简单的例子来说明：&lt;br /&gt;
 &lt;img src=&#34;https://hueralin.github.io/img/posts/eventloop01.png&#34; alt=&#34;代码执行前&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在开始执行JS代码，main()入栈，执行到console.log()，log函数入栈，执行log函数，控制台输出&amp;rsquo;Hello world!&amp;rsquo;
 &lt;img src=&#34;https://hueralin.github.io/img/posts/eventloop02.png&#34; alt=&#34;main函数入栈，log函数入栈&#34; /&gt;&lt;/p&gt;

&lt;p&gt;log函数出栈，setTimeout函数入栈，执行栈发现setTimeout函数是WebAPIs，于是将setTimeout所分发的任务交由浏览器内核对应的timer模块处理，然后将setTimeout函数出栈。&lt;br /&gt;
 &lt;img src=&#34;https://hueralin.github.io/img/posts/eventloop03.png&#34; alt=&#34;setTimeout函数入栈&#34; /&gt;&lt;/p&gt;

&lt;p&gt;setTimeout函数出栈，console.log(&amp;lsquo;end&amp;rsquo;)入栈，执行完毕后控制台输出&amp;rsquo;end&amp;rsquo;，然后console.log()函数出栈，若timer模块计时结束就将回调函数放进任务队列。&lt;br /&gt;
 &lt;img src=&#34;https://hueralin.github.io/img/posts/eventloop04.png&#34; alt=&#34;console.log(&#39;end&#39;)入栈&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后执行栈中还剩下main()，main函数出栈，此时执行栈为空。开始检查任务队列，队列中有任务，就拿到执行栈中去执行。再依次出栈。&lt;br /&gt;
 &lt;img src=&#34;https://hueralin.github.io/img/posts/eventloop05.png&#34; alt=&#34;匿名回调函数入栈，console.log入栈&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个例子中只使用了setTimeout，是WebAPIs中的一个。其他的WebAPIs例如ajax请求，DOM等都由浏览器内核中不同的模块去处理。结合前面讲的任务源，来自不同任务源的任务会被放进不同的任务队列。即setTimeout分发的任务会进入setTimeout任务队列（因为可能会有多个setTimeout被调用），诸如setTimeout、setInterval等又同属于“宏任务”，而像promise等则属于“微任务”。既然有“宏任务”和“微任务”之分，那么当执行任务队列中的任务时先去哪个呢？下面来讲一下时间循环的具体流程。&lt;/p&gt;

&lt;h3 id=&#34;事件循环的流程&#34;&gt;事件循环的流程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;从script整体代码开始，执行同步任务。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当碰到异步任务时，会将异步任务交由对应的浏览器内核模块去执行，执行完毕后将其回调函数（即事件处理程序）放到对应的任务队列中，等待被执行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;第二步并不会阻塞下面同步代码的执行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当执行栈为空时，就会优先去检查“微任务”，“微任务”中有“process.nexttick任务队列”、“promise队列”等，前者优先级大于后者，拿出队首任务放到执行栈中执行，执行完出栈，继续拿下一个“微任务”，直到所有的“微任务队列”清空。&lt;strong&gt;此时，一轮循环结束！&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;下一轮循环从“宏任务”开始，“宏任务”包括“setTimeout任务队列”、“setInterval任务队列”等，拿出队首的宏任务放进执行栈中执行，执行完出栈。&lt;strong&gt;注意！当一个“宏任务”又创建了一个“微任务”的话，则会将该“宏任务”所在的“宏任务队列”清空后，再转去处理微任务，且微任务被清空后，才会执行下一个“宏任务队列”，也就是说，“微任务”可插队！。&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;事件循环机制会一直检测执行栈、宏任务队列、微任务队列，不断循环执行。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;例题&#34;&gt;例题&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function test() {
    setTimeout(function() {console.log(4)}, 0);
    new Promise(function executor(resolve) {
        console.log(1);
        for( var i=0 ; i&amp;lt;10000 ; i++ ) {
            i == 9999 &amp;amp;&amp;amp; resolve();
        }
        console.log(2);
    }).then(function() {
        console.log(5);
    });
    console.log(3);
})()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有更复杂的例题&lt;a href=&#34;https://www.jianshu.com/p/12b9f73c5a4f&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这波能反杀&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;q-a&#34;&gt;Q&amp;amp;A&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Q：&lt;/strong&gt; setTimeout又分发了一个setTimeout，会在当前循环中执行么？&lt;br /&gt;
&lt;strong&gt;A：&lt;/strong&gt; 不会，宏任务不会插队，新分发的宏任务会等到下一次循环。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(&#39;start&#39;)
setTimeout(() =&amp;gt; {
	console.log(&#39;out&#39;)
  	setTimeout(() =&amp;gt; {
    	console.log(&#39;in&#39;)
    }, 0)       // 最早1s后放进setTimeout队列
}, 1000)        // 最早1s后放进setTimeout队列

new Promise((resolve) =&amp;gt; {
	console.log(&#39;promise&#39;)
  	for(var i = 0;i&amp;lt;100;i++){
    	i == 99 &amp;amp;&amp;amp; resolve()
    }
}).then(() =&amp;gt; {
	console.log(&#39;then&#39;)
})
setInterval(() =&amp;gt; {
	console.log(new Date().toString())
}, 1000)       // 最早1s后放进setInterval队列
console.log(&#39;end&#39;)

/*
start
promise
end
then
out
Tue Sep 03 2019 16:14:57 GMT+0800 (中国标准时间)
in
*/
// 可以看到，setTimeout任务队列清空后执行的是setInterval任务队列，即使中途插入了新的setTimeout也没有被执行，而是老老实实的等下个循环。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在其他博文还看到另一个说法，就是在任务进入执行栈前会判断是同步任务还是异步任务，是异步任务的话，会有一个事件注册表的东西，来给相应的事件注册回调函数。&lt;/p&gt;

&lt;p&gt;回更!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>狐耳的技术栈</title>
      <link>https://hueralin.github.io/2019/stack/</link>
      <pubDate>Mon, 02 Sep 2019 17:08:32 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/stack/</guid>
      <description>

&lt;h3 id=&#34;javascript&#34;&gt;JavaScript&lt;/h3&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://hueralin.github.io/2019/closure/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS闭包&lt;/a&gt;&lt;br /&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://hueralin.github.io/2019/jsec/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS执行环境/AO/VO&lt;/a&gt;&lt;br /&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 事件循环&lt;br /&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; async/await&lt;br /&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;html&#34;&gt;HTML&lt;/h3&gt;

&lt;h3 id=&#34;css&#34;&gt;CSS&lt;/h3&gt;

&lt;h3 id=&#34;性能优化手段&#34;&gt;性能优化手段&lt;/h3&gt;

&lt;h3 id=&#34;webpack&#34;&gt;webpack&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>JS执行环境，作用域链，变量对象/活动对象</title>
      <link>https://hueralin.github.io/2019/jsec/</link>
      <pubDate>Mon, 02 Sep 2019 11:20:42 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/jsec/</guid>
      <description>

&lt;p&gt;JS的重点内容之一，虽然不会在面试题中直接那么问，多半给你出一段代码，看输出什么。&lt;/p&gt;

&lt;p&gt;我觉得了解了这部分内容，能让我们对整个JS的执行流程有个详细、准确地认识，在面对工作中的一些错误也能快速且正确的排错。&lt;/p&gt;

&lt;h3 id=&#34;js执行环境&#34;&gt;JS执行环境&lt;/h3&gt;

&lt;p&gt;JS的执行环境又被称为执行上下文（Execution context），简称EC。顾名思义，JS执行环境就是JS执行时才会存在的环境，常见的执行环境有两种：全局执行环境和函数执行环境。当JS代码执行的时候，我们会进入不同的执行环境，这些执行环境会构成一个执行环境栈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EC的组成&lt;/strong&gt;：&lt;br /&gt;
1. 变量对象（VO）：包含变量的对象，无法被访问&lt;br /&gt;
2. [[scope]]：作用域链，由变量对象构成，该属性是指向作用域链头节点的指针&lt;br /&gt;
3. this指针：指向环境对象（也是一个普通对象），而不是执行环境EC&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EC的创建&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;EC是在调用函数的时候创建的，一个EC的生命周期分为两个阶段：创建阶段 和 执行阶段：&lt;br /&gt;
1. 创建阶段：此时EC创建变量对象，建立作用域链，确定this的指向，&lt;br /&gt;
2. 代码执行阶段：完成变量赋值，其他函数调用等代码的执行&lt;/p&gt;

&lt;p&gt;其中变量对象的创建也是个重点，这里涉及到了&lt;strong&gt;预编译&lt;/strong&gt;的问题：&lt;br /&gt;
&lt;strong&gt;变量对象的创建&lt;/strong&gt;：&lt;br /&gt;
1. 根据函数的参数，建立arguments对象（类数组，将参数值保存在下标中）。&lt;br /&gt;
2. 函数声明提升：扫描所有的函数声明，将函数名作为变量对象的属性名，属性值为函数在内存中的地址，如果属性名存在，则会被覆盖。&lt;br /&gt;
3. 变量声明提升：扫描所有的变量声明，将变量名作为变量对象的属性名，属性值初始化为undefined，如果属性名存在，则会跳过，不覆盖（防止同名的函数被覆盖为undefined，毕竟函数是一等公民嘛～）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：在代码执行阶段的时候，变量才会被赋值，之前一直都是undefined。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由上可知，作用域其实就是一个变量对象。那么什么是变量对象？&lt;/p&gt;

&lt;h3 id=&#34;变量对象-vo&#34;&gt;变量对象（VO）&lt;/h3&gt;

&lt;p&gt;变量对象存储了EC中定义的变量和函数声明，“这个对象是规范上的，或者说是引擎实现上的，不可在JS环境中访问到”。&lt;/p&gt;

&lt;h3 id=&#34;活动对象-ao&#34;&gt;活动对象（AO）&lt;/h3&gt;

&lt;p&gt;“活动对象其实就是变量对象的激活状态” 这是我在大多数博文中找到的介绍，即当执行流进入一个函数时，EC会被创建，变量对象会被创建，变量对象被激活成为活动对象。&lt;/p&gt;

&lt;p&gt;此处有&lt;strong&gt;争议&lt;/strong&gt;：&lt;br /&gt;
1. 根据“函数是被一级一级的调用的”，我是不是可以说这一级一级向下执行的函数的变量对象都是活动对象呢？毕竟这些函数都被执行了。所以说，我觉得 “活动对象” 应该是处于作用域链顶端的变量对象，该变量对象处于最近被执行的EC。&lt;br /&gt;
2. 另一种说法，不是存在一个执行环境栈嘛，当A函数里执行了B函数，那么B函数入栈，A函数可以想象成处于一种 “休眠” 状态，B函数才算真正被执行。所以B函数里的执行环境、变量对象被创建，变量对象被激活为活动对象。（Emmm，好像也有道理。哈！都是我的猜想😂）&lt;/p&gt;

&lt;p&gt;当函数执行完毕，它的执行环境会被销毁，活动对象也会跟着销毁。但这是在一般的情况下，如果是 &lt;strong&gt;&lt;a href=&#34;https://hueralin.github.io/2019/closure/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;闭包&lt;/a&gt;&lt;/strong&gt;，那就得另当别论。假设A函数里返回了B函数，B函数引用着A函数执行环境里的活动对象。当A函数执行完毕后，A函数的环境变量被销毁，但是活动对象依然存在于作用域的顶端。当返回的函数被调用时，会创建自己的执行环境和活动对象（此时应该就有两个活动对象），闭包函数的活动对象里面引用着上一个活动对象，当闭包函数执行完后，两个活动对象都将被销毁。&lt;/p&gt;

&lt;h3 id=&#34;作用域链&#34;&gt;作用域链&lt;/h3&gt;

&lt;p&gt;作用域分为两种：全局作用域 和 局部作用域。&lt;br /&gt;
前面说过，作用域链其实就是变量对象，但并不是一个，而是一串儿😂。我们所说的局部作用域其实就是当前执行环境的变量对象，我们在查找一个变量的时候，如果在当前变量对象里面查不到的话，就会顺着作用域链一级一级的向上查找，直到全局作用域，因此全局作用域处于作用域链的末端。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/36393048&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;最后，推荐一篇知乎上的帖子，上面讨论的很详细。（尤其是那几个图，很直观，我也就不再放图了😂）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(我听见你在说我懒了&amp;hellip;&amp;hellip;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JS闭包</title>
      <link>https://hueralin.github.io/2019/closure/</link>
      <pubDate>Fri, 30 Aug 2019 17:41:06 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/closure/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考资料：阮一峰&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考资料：MDN&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;之前简单学习过闭包，也会无意间使用过闭包，但如果你要问我闭包是什么我也答不上来。今天呢，重新学习闭包，做个总结。&lt;/p&gt;

&lt;h3 id=&#34;什么是闭包&#34;&gt;什么是闭包&lt;/h3&gt;

&lt;p&gt;相信你在学习闭包的时候肯定看过类似的许多文章是这么说的：“闭包就是一个能够访问 &lt;strong&gt;其他函数的变量&lt;/strong&gt; 的&lt;strong&gt;函数&lt;/strong&gt;”，如果你看过《你不知道的javascript》这本书中关于闭包的解释，你会觉得这句话很片面，也很浅陋，而这句话被当今好多博文所提及，给好多学习闭包的小伙伴造成了不少的误解。&lt;/p&gt;

&lt;p&gt;《你不知道的javascript》这本书中对于闭包是这么说的：“当一个函数能够访问定义它时所处环境的局部变量时，那么就形成了一个闭包（具体怎么说的我也记不太清楚了）”，重点是“形成了一个闭包”，而不是大多数人所说的闭包就是那个函数，闭包其实还跟环境有关。在MDN中也有类似的解释，开头第一句话就是“闭包是函数和声明该函数的词法环境的组合”。下面还有一段解释:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;“闭包是由函数以及创建该函数的词法环境组合而成，这个环境包含了这个闭包创建时所能访问的所有局部变量”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于什么是词法作用域请看 [词法作用域]()&lt;/p&gt;

&lt;p&gt;啪！MDN 还是说出了打脸的话，在makeAdder栗子中，它竟然说“add5 和 add10 都是闭包”（糟糕，我要下不来台了），为什么又说这两个函数是闭包呢，虽然后面还是扯上了词法作用域，但这让读者看起来挺迷啊（哼，双标狗！😂）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function parent() {                 // 外部函数
    let name = &#39;huer&#39;               // 内部变量
    return function children() {    // 内部函数
        console.log(name)
    }
}
let other = parent()
other()                             // ‘huer’
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说下我的简单理解，闭包既然被称为包，那我就可以把它想象成一个包结构（包袱），包裹着外部函数的内部变量和内部函数，并返回内部函数。&lt;strong&gt;注意：内部函数是要被返回的！&lt;/strong&gt; 如果内部函数没有被返回，那么当外部函数执行完毕后，外部函数里面的所有变量和函数都会被垃圾回收机制所清理。此时，我们就引出了闭包函数的一个重要特性，&lt;strong&gt;可以使某些变量长时间存在于内存中而不会被销毁&lt;/strong&gt;。正常情况下，执行完一个函数，即return一个值后，该函数及其内部所有变量就会被回收。而当我们在函数内部又定义了一个函数时，根据对词法作用域的理解，该内部函数可以访问外部函数所定义的变量，即内部函数对它所处的词法作用域有一种引用关系，如果我们将内部函数return出去，并返回给一个变量，那么该变量就是对内部函数的一个引用，从而也能访问外部函数所定义的变量。那么这就实现了某些变量能够一直存在于内存中而不会被销毁，并且还是私有的，其他外部的变量无法访问，只有return的内部函数才能访问。&lt;/p&gt;

&lt;p&gt;在好多博文给出的栗子中，内部函数总是使用了外部函数所定义的变量，这就使好多同学误解，返回的内部函数一定要使用外部函数定义的变量，其实这是不对的。打个比方，我们（内部函数）出生在家里（词法作用域），我们对家里的一切事物都可以够得到，摸得着（除掉‘3岁以下儿童勿碰’等乱七八糟的规则），都可以使用，这并不意味着这些东西此时就在我们手里，它们不在我们的手里，我们也对它们有使用权（即，内部函数对所处的词法作用域有引用关系）。这就是闭包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;形成闭包的条件：外部函数（词法作用域） + 返回一个内部函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们上面的代码只是访问了内部变量，其实我们返回的内部函数还能操作内部变量，是不是有点面向对象的感觉？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function parent() {
    let name = &#39;huer&#39;
    function getName() {
        return name
    }
    function setName(val) {
        name = val
    }
    return {
        getName,
        setName
    }
}
let obj = parent()
obj.getName()                   // &#39;huer&#39;
obj.setName(&#39;tuzi&#39;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看！不止返回函数才能形成闭包，返回对象也可以！（只要对你想留下的变量保持引用就可以）&lt;/p&gt;

&lt;p&gt;MDN 上还给出了一个使用闭包的情景：“通常你使用只有一个方法的对象的地方，都可以使用闭包” 原谅我没有get到点，不过下面给出的例子倒是比较明白：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 点击按钮，修改字体大小
function makeSizer(size) {
  return function() {
    document.body.style.fontSize = size + &#39;px&#39;;
  };
}

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);

document.getElementById(&#39;size-12&#39;).onclick = size12;
document.getElementById(&#39;size-14&#39;).onclick = size14;
document.getElementById(&#39;size-16&#39;).onclick = size16;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相信上面的代码大家应该都很明白，对于事件绑定，我们要传递的是一个函数，但是如果该函数还要传递参数那就比较棘手了，于是我们可以通过闭包的方式，将参数传递给makeSizer，将makeSizer执行完后返回的函数作为事件的回调函数，于是当我们触发事件的时候，回调函数仍能访问当初传递的参数。类似的关于事件处理函数传参的问题，比如 &lt;a href=&#34;https://hueralin.github.io/2019/bind/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;React中的bind绑定&lt;/a&gt;，我也使用了闭包。&lt;/p&gt;

&lt;p&gt;基于闭包，我们可以实现面向对象中的私有变量，外部无法访问，只能通过暴露出去的公共方法来操作这些私有变量。例如上面的setName和getName。&lt;/p&gt;

&lt;p&gt;MDN 上还有一个创建计时器的工厂函数，每个计时器内部的环境都是互相独立的，也就是说这些闭包互不干扰，关于这方面的知识，参见 [JS活动对象]()&lt;/p&gt;

&lt;h3 id=&#34;坑&#34;&gt;坑&lt;/h3&gt;

&lt;p&gt;闭包虽好，但也不能乱用，常见的一个坑就是在循环中使用了闭包：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 假设有五个按钮，点击按钮分别显示1，2，3，4，5
function NB() {
    var arr = [1,2,3,4,5]
    for(var i = 0;i&amp;lt;arr.length;i++){
        var item = arr[i]
        document.getElementById(&#39;五个button的ID&#39;).onclick = function() {
            alert(item)
        }
    }
}
NB()
// 以前在这里翻过车，总以为会按照期望弹出，结果是每个都弹出5  
// 这里确实有闭包，想想上面形成闭包的条件，外部函数NB有了，返回的内部函数有了  
// 这里的内部函数返回的不明显，即传给onclick的匿名函数，这些匿名函数会在点击的时候被调用。  
// 循环了五次，形成了五个闭包（因为每个匿名函数都不一样），但这五个闭包共享同一个词法作用域，  
// 即都引用了同一个arr数组，因为循环先于按钮被点击，所以当点击时，arr[i]已经是最后一个元素了，所以每次都弹出5。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出错的原因大家应该明白了，即五个闭包共享同一个词法作用股，确切的说是调用了同一个item(arr[i])，因为它本意是想弹出不同的item嘛，所以我们要做的就是使item不同：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function NB() {
    var arr = [1,2,3,4,5]
    for(var i = 0;i&amp;lt;arr.length;i++){
        (function(i) {  // 创建了5个不同的匿名函数（即5个不同的函数作用域）
            var item = arr[i]   // 每个作用域中的item都是独一无二的
            document.getElementById(&#39;五个button的ID&#39;).onclick = function() {
                alert(item)
            }
        })(i)   // 通过使用立即执行函数，传入i
    }
}
// 此时，每个闭包所引用的词法作用域都是立即执行函数产生的，都是不同的
NB()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;未完待续&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Git Stash</title>
      <link>https://hueralin.github.io/2019/gitstash/</link>
      <pubDate>Mon, 26 Aug 2019 20:09:47 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitstash/</guid>
      <description>

&lt;h3 id=&#34;emmmm&#34;&gt;Emmmm&lt;/h3&gt;

&lt;p&gt;最近在实习的项目中经常使用 git stash 这个命令，现在来做一些总结。&lt;/p&gt;

&lt;p&gt;你可能会遇到这样一种情况，就是当你在进行开发或修改某个BUG的时候突然来了一个新任务（新任务与当前的开发项目属于同一个项目），时间紧迫，你需要立即切换分支去执行，可是你当前的任务还没有做完，切分支的话会被拒绝，怎么办呢？有种方法是先add再commit，确实可以，但是我感觉这么做的话会添加一个毫无意义的提交记录，虽然以后可以修改，但是太过麻烦。那么，就来试试 git stash 吧。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%EF%BC%88Stashing%EF%BC%89&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;git stash 官方文档第一版&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;git stash 官方文档第二版&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;git-stash-应用场景&#34;&gt;git stash 应用场景&lt;/h3&gt;

&lt;p&gt;git stash 的作用是将当前为提交的修改存储起来，让仓库还原到最后一次提交的状态。&lt;br /&gt;
使用场景：&lt;br /&gt;
1. 工作未完成，需要切换分支，但不想提交（常用）。&lt;br /&gt;
2. 开发一个feature分支（未完成），此时想要合并一下主分支，看看做了哪些修改，提前解决冲突。&lt;/p&gt;

&lt;p&gt;现在来看看场景二的解决方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 假设我在feature分支上开发，突然得知主分支更新了，于是我想要将主分支合并到当前分支，看看有没有冲突，有的话直接解决。
git checkout master  // 报错！会提示当前某些修改未存储提交  
// 当然，我是不想提交的，毕竟还没做完...于是，
git stash save &amp;quot;先搁这儿，我去瞅瞅主分支，拉下代码～&amp;quot;   // save 类似于 commit 的 -m 选项，即注释信息  
git stash list // 列出来所有的存储信息，看看有木有～  
git checkout master  // 切换到主分支
git pull origin master // 将远程主机的master分支拉下来  
git checkout feature    // 切回feature分支  
git merge master    // 将master分支合并到feature（可能会有冲突）  
git stash pop   // 将先前feature分支做的修改释放出来（可能会有冲突）  
// 有冲突合并即可，合并完，feature拥有了master分支最新的修改以及当前的特性开发。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;git-stash&#34;&gt;git stash&lt;/h3&gt;

&lt;p&gt;git stash 实际上是一个栈结构，它可以获取工作目录中的中间状态（包括对已追踪文件的修改和暂存的变更，使用 git status 查看），将它保存在一个栈结构中，方便以后使用。（注意！未被追踪的文件不在存储的范围内！）&lt;/p&gt;

&lt;p&gt;git stash 命令：&lt;br /&gt;
1. git stash（git stash push的简写）将当前工作目录的中间状态保存在栈中。&lt;br /&gt;
2. git stash list 列出所有的存储。&lt;br /&gt;
3. git stash apply stash@{0} apply后面是名字，表示要应用的存储（省略名字则应用最近的存储到仓库中），apply只是应用，并不会将存储弹出栈。&lt;br /&gt;
4. git stash pop 将最近的存储应用到仓库中（但会将存储弹出栈），也可以指定存储的名字，将指定的存储应用到仓库后弹出栈。&lt;br /&gt;
5. git stash clear 清空存储栈。&lt;br /&gt;
6. git stash drop 删除最近的存储，也可以指定名字（但不会被应用到仓库）。&lt;br /&gt;
7. git stash branch name 根据最近的stash创建一个分支，然后删除最近的stash，也可以指定存储名。（如场景二，如果最后应用stash的时候发生了冲突，可以使用这个命令，牵引出一个未合并的分支做副本）。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;讲解一下 git stash push 和 git stash save&lt;/strong&gt;&lt;br /&gt;
这两个命令都可以存储当前工作区中被追踪文件的修改，但是也有些区别。&lt;br /&gt;
语法：&lt;br /&gt;
1. git stash push -m &amp;lsquo;xxxxx&amp;rsquo; src/xxx&lt;br /&gt;
2. git stash save &amp;lsquo;xxxxx&amp;rsquo;&lt;br /&gt;
其中，git stash push能指定路径，存储指定的文件，而指定路径对git stash save来说无效，它会存储工作区中所有的被追踪文件的修改。&lt;/p&gt;

&lt;h3 id=&#34;使用-git-stash-出现的问题&#34;&gt;使用 git stash 出现的问题&lt;/h3&gt;

&lt;p&gt;Q：“我新建了一个文件，用stash存储了一下，切分支后发现该文件被带进了另一个分支”&lt;br /&gt;
A：前面说过，新建的文件，如果没有add进暂存区，那么是不受stash管理的，git也不会追踪。所以对于新建的文件，应该在使用stash前先add一下。&lt;/p&gt;

&lt;p&gt;Q：“不是说我BUG还没改完切到其他分支会报错吗，要我必须提交修改。可是我没提交修改，切master分支成功了。但是！BUG修复的代码被带到master了！”&lt;br /&gt;
A：Emmmm&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mock 前端假数据</title>
      <link>https://hueralin.github.io/2019/mock/</link>
      <pubDate>Wed, 21 Aug 2019 16:09:41 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/mock/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;为什么需要前端做假数据？Emmmm，不用我说了吧～&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;官方文档看这里&lt;a href=&#34;http://mockjs.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;MockJs&lt;/a&gt;！&lt;/p&gt;

&lt;p&gt;数据模版之类的语法去看官方文档，我这里只简单介绍一下我的使用情况。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>伪类 与 伪元素</title>
      <link>https://hueralin.github.io/2019/weilei/</link>
      <pubDate>Wed, 21 Aug 2019 15:17:26 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/weilei/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;“请说一下伪类和伪元素的区别”，之前的面试中遇到过这个问题，当初表示只见过伪类，回答的基本上都是:hover之流，这道题就挂了&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如今，在实习中遇到了相关的需求，看来是时候深入学习一下了。其实，区分伪类和伪元素并不难，它俩最大的区别就在于应用场景。&lt;/p&gt;

&lt;h3 id=&#34;伪类&#34;&gt;伪类&lt;/h3&gt;

&lt;h4 id=&#34;顾名思义-它相当于一个类-是用来设置样式的-当你需要让一个元素在某种特殊状态下显示特殊的样式时-如-按钮悬浮特效-就该使用伪类&#34;&gt;顾名思义，它相当于一个类，是用来设置样式的；当你需要让一个元素在某种特殊状态下显示特殊的样式时（如：按钮悬浮特效），就该使用伪类。&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;下面我们来实现一下伪类：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需求：实现消息列表悬浮特效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 需求很明确，li元素在悬浮情况下应用样式 --&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;React&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Vue&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Angular&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;jQuery&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Webpack&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;NPM&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
li:hover {
    background: #eee;
}
&amp;lt;!-- 再简单不过了，当然也可以设置奇偶行样式不一 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他的伪类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;:active :empty  :enabled    :first  :first-child    :first-child  
:first-of-type  :focus  :hover  :visited    :nth-child  :nth-of-type    :link
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;伪元素&#34;&gt;伪元素&lt;/h3&gt;

&lt;h4 id=&#34;顾名思义-它是一个元素-可以是现有的元素-也可以是新增的元素-这些元素往往有自己的特殊位置-如-段落首字母突出样式-往往被作为附加的标记&#34;&gt;顾名思义，它是一个元素，可以是现有的元素，也可以是新增的元素，这些元素往往有自己的特殊位置（如：段落首字母突出样式）往往被作为附加的标记。&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;下面我们来实现一下伪元素&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需求：表单必填项前面加一个标识（这也是我这次的需求）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;label&amp;gt;页面地址&amp;lt;/label&amp;gt;
&amp;lt;input type=&#39;text&#39; placeholder=&amp;quot;请输入页面地址&amp;quot;/&amp;gt;
label::before {
    content: &#39;*&#39;;
    color: red;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;img src=&#34;https://hueralin.github.io/img/posts/xinghao.jpg&#34; alt=&#34;必填项前加星号&#34; /&gt;&lt;/p&gt;

&lt;p&gt;伪元素并不多：&lt;br /&gt;
1. ::before&lt;br /&gt;
2. ::after&lt;br /&gt;
3. ::first-letter 段落首字母&lt;br /&gt;
4. ::first-line 段落首行&lt;br /&gt;
5. ::selection 这个很有意思，代表被用户高亮的部分（例如鼠标选中）&lt;/p&gt;

&lt;h3 id=&#34;before-和-after&#34;&gt;::before 和 ::after&lt;/h3&gt;

&lt;p&gt;这两个伪元素比较特殊，属于扩增原元素一类（我自己瞎起的名字）&lt;br /&gt;
::before 创建一个伪元素，并作为匹配元素的第一个子元素，::after则相反；这个新增的元素默认为“行内元素”&lt;br /&gt;
语法参照&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;MDN&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/* CSS3 语法 */
element::before { 样式 }  
/* （单冒号）CSS2 过时语法 (仅用来支持 IE8) */
element:before  { 样式 }  
/* 在每一个p元素前插入内容 */
p::before { content: &amp;quot;Hello world!&amp;quot;; } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MDN上关于这一节的最后一个例子不错，大家可以尝试一下！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React组件中的函数this绑定</title>
      <link>https://hueralin.github.io/2019/bind/</link>
      <pubDate>Tue, 20 Aug 2019 11:04:35 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/bind/</guid>
      <description>

&lt;h2 id=&#34;实习项目遇到的问题&#34;&gt;实习项目遇到的问题&lt;/h2&gt;

&lt;h3 id=&#34;关于函数this绑定&#34;&gt;关于函数this绑定！&lt;/h3&gt;

&lt;p&gt;最近在React项目中遇到了关于函数this绑定的问题，因为在普通函数（诸如:function(){xxx}）中，this的绑定是动态的，在被执行时才会确定。若这些普通函数在自身组件内使用一般不会有太大的问题，然而一旦被当作参数（例如事件处理函数）传递到其他组件时，this就会绑定为其他组件的实例，在获取原实例的状态时就会发生错误。&lt;/p&gt;

&lt;p&gt;箭头函数的this绑定和普通函数不一样，它是静态绑定的，也就是说箭头函数的this绑定是在定义时绑定的，即定义箭头函数时所处的作用域的this。所以说如果React组件中的函数是用箭头函数的形式定义的话，就不用担心this绑定的问题。&lt;/p&gt;

&lt;p&gt;假如你的onClick事件处理函数在被触发时需要传参，如果直接 &lt;code&gt;onClick={this.handleClick(xxx)}&lt;/code&gt; 话，onClick得到的就不是函数，而是函数返回的结果，所以应使用 &lt;code&gt;onClick={() =&amp;gt; this.handleClick(xxx)}&lt;/code&gt; ，即给onClick一个箭头函数作为事件处理函数，那么this就绑定为了当前组件的实例，调用的普通函数也不用做特殊的处理。&lt;/p&gt;

&lt;p&gt;我犯了一个最基础也最致命的问题，在渲染中进行了状态的改变！按理说我不应该会犯这种错误，我犯这种错误的原因就是我将箭头函数和普通函数结合使用（模仿的项目中的老代码）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;handleInput(key) {
  return (e) =&amp;gt; {
      let inputValue = {}
      inputValue[key] = e.target.value
      this.setState({
      data: Object.assign({}, this.state.data, inputValue)
      })
  }
}
onChange={this.handleInput(xxx)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看出和之前 &lt;code&gt;onClick={() =&amp;gt; this.handleClick(xxx)}&lt;/code&gt; 的不同了么？&lt;br /&gt;
这里是由普通函数将箭头函数return了出来，所以函数渲染时立即执行handleInput，并将执行后的箭头函数传给onChange，顺便完成this绑定，Emmmm，秀啊！可惜当初我没搞懂这个用意，将handleInput彻底改成了普通函数，导致在渲染时执行了this.setState()，浏览器不停的改变状态和渲染，瞬间报错0～20000+，不得不强制杀死浏览器进程&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;总结react组件中的函数this绑定的几种方法&#34;&gt;总结React组件中的函数this绑定的几种方法&lt;/h3&gt;

&lt;p&gt;一、每当作为事件处理函数时，例如：&lt;code&gt;onClick onChange&lt;/code&gt; 等，都手动绑定一次&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 这种方法的好处是在绑定this的同时能传递参数
onClick={this.handleClick.bind(this, args)}
// 缺点是，每次都得手动调用bind()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、在构造函数中绑定一次，一劳永逸&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 缺点是不能传递参数
this.handleCLick = this.handleClick.bind(this)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三、React组件的函数直接定义成箭头函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;handleClick = (args) =&amp;gt; {xxxxx}
// 缺点也是不能传递参数
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;上述三个做法有个矛盾，就是“一次绑定”和“传递参数”不能兼顾&lt;br /&gt;
对于二、三方法，要实现传递参数，就得使用箭头函数，即&lt;br /&gt;
&lt;code&gt;onClick = {() =&amp;gt; this.handleClick(args)}&lt;/code&gt;&lt;br /&gt;
既然使用了箭头函数，那么二三方法中的绑定就没有必要了，这虽然是个好方法，但是看书写的代码量和第一种方法又有什么区别呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;四、普通函数返回一个箭头函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 这是在实习期做项目时前辈的一个做法，感觉还不错
// 这种方法的原理就是在普通函数中返回一个箭头函数，  
// 在渲染时立即执行该函数，接收箭头函数作为事件处理函数，完成绑定的同时又传递了参数  
handleClick (args) {
  return () =&amp;gt; {
    balabalabala...
  }
}
onClick = {this.handleClick(args)}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Array</title>
      <link>https://hueralin.github.io/2019/array/</link>
      <pubDate>Mon, 19 Aug 2019 15:46:37 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/array/</guid>
      <description>

&lt;h1 id=&#34;array&#34;&gt;Array&lt;/h1&gt;

&lt;p&gt;Emmmm, Array的函数不少，至少我觉的是这样。随着ES的发展，Array多了许多奇奇怪怪的函数。&lt;br /&gt;
虽说奇怪&amp;hellip;.但用起来超爽的啊！！！！&lt;/p&gt;

&lt;h3 id=&#34;什么-想要查找数组中的某个元素&#34;&gt;什么？想要查找数组中的某个元素？&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Array.find()&lt;/strong&gt; 拿走不送！&lt;strong&gt;（ES6）&lt;/strong&gt;&lt;br /&gt;
该函数接受两个参数：callback、thisObj&lt;br /&gt;
在回调函数中return符合查找条件的元素，若查找成功则直接返回该元素的&lt;strong&gt;值&lt;/strong&gt;，否则返回undefined，并且不会改变原素组，简直不要太爽！&lt;br /&gt;
如果想要查找某个元素的&lt;strong&gt;索引&lt;/strong&gt;的话，可以使用 Array.findIndex() 函数，找不到的话返回-1。&lt;/p&gt;

&lt;h3 id=&#34;增删元素类-改变原数组&#34;&gt;增删元素类（改变原数组）&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;push() 在后面插入&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;unshift() 在前面插入&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;pop() 在后面弹出&lt;/li&gt;
&lt;li&gt;shift() 在前面弹出&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;元素查找类&#34;&gt;元素查找类&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;find(callback) 通过callback的逻辑，查找满足条件的元素，返回“值”&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;findIndex(callback)  通过callback的逻辑，查找满足条件的元素，返回“索引“&lt;/li&gt;
&lt;li&gt;includes(item) 查找是否有item，返回布尔值&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;indexOf(item) 查找是否有item，返回下标&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;数组遍历类&#34;&gt;数组遍历类&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;&amp;mdash; forEach() &amp;mdash;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let a = [1,2,3,4,5]  
a.forEach((item, index, arr) =&amp;gt; {
    console.log(item)   // 1,2,3,4,5
})
/*
forEach 遍历的范围在第一次调用 callback 前就会确定,所以后续调用中 添加 和 删除 的item都不会被遍历到
*/
a.forEach((item, index, arr) =&amp;gt; {
    arr.push(index*2)    // 增加一些
    console.log(item)   // 1,2,3,4,5 (实际上a已经是1,2,3,4,5,0,2,4,6,8了)
})
a.forEach((item, index, arr) =&amp;gt; {
    arr.pop()    // 删除一些
    console.log(item)   // 1,2,3,4,5 (实际上a已经是1,2,3,4,5了)
})
// 如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值(如果提前修改了下一个item，那么遍历到该item的那一刻的值就是修改后的值)
a.forEach((item, index, arr) =&amp;gt; {
    arr[index + 1] *= 2    // 做些修改
    console.log(item)   // 1,4,6,8,20.undefined (实际上a已经是1,4,6,8,10,NaN了)
})
// 如果数组的值是undefined(未初始化)或被delete,也不会被遍历
delete a[5]
delete a[4]
a.forEach(item =&amp;gt; {
    console.log(item)   // 1,4,6,8(delete后长度不变，被删除的值变成undefined)
})
// 来看看 for 语法
let b = [6,7,8,9,10]  
for (let i = 0;i&amp;lt;b.length;i++) {
    b.push(0)
    console.log(b[i])   // 6,7,8,9,10,0,0,0,0,0..........此处省去成千上万个0（因为每次都增加item，遍历个没完没了）
}
// forEach 只是遍历，但如果你使用了callback的第三个参数，那么也是会修改原数组的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;&amp;mdash; map() &amp;mdash;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// map函数返回一个新数组，新数组中的每一项都是每个原数组元素执行callback后 返回的值。  
let a = [1,2,3,4,5]  
a.map((item) =&amp;gt; item*2) // [2,4,6,8,10]
/*
MDN：使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。  
在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；  
若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；  
而被删除的元素将不会被访问到。  
这一点和 forEach 一样，毕竟forEach看起来就只是遍历，而map和其他类似的函数是在遍历基础上进行的扩展。
*/
map用途：格式化原数组，根据原数组做一些拓展（计算）  
// map函数的参数是一个回调函数，那是不是也可以传入一些内置的函数呢？当然可以！  
// MDN上就给出了一个简单的例子：将parseInt函数作为参数传递进去
[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt) // [1, NaN, NaN]  
// 可以使用一些内置函数，但是要注意这些内置函数的参数，map的回调函数要求参数有三个item，index，arr。  
// 即使你没有显示的设置后两个参数（仅仅是声明一个局部变量而已），map还是会传递index和arr作为回调函数的参数。  
// parseInt函数接受两个参数：数值，进制。而map将item，index，arr都传递进去（arr会被忽略），那么索引就被当成了进制，所以最后出错了。
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>后台管理系统</title>
      <link>https://hueralin.github.io/2019/athene/</link>
      <pubDate>Wed, 07 Aug 2019 10:49:37 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/athene/</guid>
      <description>

&lt;h3 id=&#34;这是实习期一个后台管理的项目&#34;&gt;这是实习期一个后台管理的项目&lt;/h3&gt;

&lt;p&gt;目前正在熟悉该项目，边熟悉，边做一些记录&lt;/p&gt;

&lt;p&gt;先来看一下大体的框架：&lt;br /&gt;
&lt;strong&gt;顶层容器&lt;/strong&gt;&lt;br /&gt;
在container目录下的index.js文件中，有一个IndexContainer组件，该组件中的render函数是这么写的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;render () {
    let { permission } = this.props
    return (
        &amp;lt;div&amp;gt;
        &amp;lt;Header params={this.props.params} username={permission.username} /&amp;gt;
        &amp;lt;div className=&#39;main-content&#39;&amp;gt;
            &amp;lt;SideNav routes={this.props.routes} permissions={permission.permission} /&amp;gt;
            &amp;lt;div&amp;gt;
            {this.props.children}
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出该系统采用了非常常见的布局，即‘顶部导航+左侧导航+右侧内容’&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;路由配置&lt;/strong&gt;&lt;br /&gt;
因为路由比较多，所有路由配置分为两个路由文件：&lt;br /&gt;
&lt;em&gt;外层路由文件&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 这里引入了内层路由文件  
import routers from &#39;./routers&#39;
module.exports = (
  &amp;lt;Router history={browserHistory}&amp;gt;
    &amp;lt;Route path=&#39;/&#39; /&amp;gt;
    &amp;lt;Route path=&#39;/xxx&#39; component={xxx} /&amp;gt;
    &amp;lt;Route path=&#39;/xx/xx&#39; component={xx} /&amp;gt;
    ......
    &amp;lt;Route path=&#39;&#39; component={Container} onEnter={handleEnterSystem}&amp;gt;
      {/* 嵌套路由，内层路由文件里的Route渲染的组件都是Container容器下的子组件，在this.props.children处渲染*/}
      { routers }
    &amp;lt;/Route&amp;gt;
    &amp;lt;Redirect from=&#39;*&#39; to=&#39;/error/404.html&#39; /&amp;gt;
  &amp;lt;/Router&amp;gt;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;内层路由组件&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Router = (
  &amp;lt;Route path=&#39;/xxx&#39;&amp;gt;
    &amp;lt;IndexRoute component={Page} /&amp;gt;
    &amp;lt;Route path=&#39;yyy/product&#39; component={ProductList} /&amp;gt;
    &amp;lt;Route path=&#39;yyy/product/:id&#39; component={Product} /&amp;gt;
    &amp;lt;Route path=&#39;yyy/users/:id&#39; component={Users} /&amp;gt;
    ......
  &amp;lt;/Route&amp;gt;
)
module.exports = Router
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ES2016/2017新特性</title>
      <link>https://hueralin.github.io/2019/es20162017etc/</link>
      <pubDate>Tue, 06 Aug 2019 11:56:42 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/es20162017etc/</guid>
      <description>

&lt;h3 id=&#34;es2016-es7&#34;&gt;ES2016(ES7)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Array.prototype.includes(value): 判断一个元素是否在数组中&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let a = [1,2,3,4,5,6]  
a.includes(4)   // true  
a.includes(7)   // false  

// 功能类似于 xxx.indexOf(y) &amp;gt; -1, 但有不同  
// includes可以检测Nan  (indexO不可以)
[NaN].includes(NaN) // true

// 不区分 -0 +0 （indexOf也可以）
[-0].includes(+0)   // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;求幂运算&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let a = 3
a ** 2      // 9
// 相当于 Math.pow(a, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;es2017-es8&#34;&gt;ES2017(ES8)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;String.prototype.padStart / String.prototype.padEnd（字符串填充）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;功能：返回指定长度的填充后的字符串  
语法：str.padStart(len [, padStr])  // len 指定长度 padStr 填充字符串  
let str = &#39;huer&#39;  
// 1. 指定长度小于原字符串长度，则返回原字符串    
str.padStart(2)  // &#39;huer&#39;
// 2. 指定长度大于原字符串长度，则返回填充字符串（默认为空格）+原字符串  
str.padStart(5)  // &#39; huer&#39;  
// 3. 原字符串 &amp;lt; 指定长度 &amp;lt; 填充字符串 + 原字符串，则从填充字符串的右侧截取  
str.padStart(7, &#39;malin&#39;)    // &#39;malhuer&#39;  
// 4. 指定长度 &amp;gt; 填充字符串 + 原字符串, 重复填充字符串，使其达到指定长度  
str.padStart(10, &#39;a&#39;)       // &#39;aaaaaahuer&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Object.values / Object.entries&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Object.values(obj): 返回obj的可遍历属性的 ‘属性值’ 数组&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Object.entries(obj): 返回obj的可遍历属性的 ‘键值对’ 数组&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Object.getOwnPropertyDescriptors&lt;/strong&gt;&lt;br /&gt;
该函数返回对象的属性描述符&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;函数定义和函数调用的参数列表最后面的尾逗号&lt;/strong&gt;&lt;br /&gt;
Emmmm，就是说下面这种情况不会报错，有什么作用？？？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Func(a,b,) {xxx}
Func(1,2,)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;异步函数 async/await&lt;/strong&gt;&lt;br /&gt;
to be continued&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>