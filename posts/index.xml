<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 狐耳的雪原</title>
    <link>https://hueralin.github.io/posts/</link>
    <description>Recent content in Posts on 狐耳的雪原</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 04 Jan 2020 14:56:19 +0800</lastBuildDate>
    
	<atom:link href="https://hueralin.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>并查集</title>
      <link>https://hueralin.github.io/2020/bingchaji/</link>
      <pubDate>Sat, 04 Jan 2020 14:56:19 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2020/bingchaji/</guid>
      <description>并查集是一个用树结构表示的集合，来处理一些不相交集的合并及查询问题。 其实并查集就像朋友圈，我们之前都是一个个的个体，后来因为某些共同兴趣而走到了一起，建立了一个小圈子。随着志同道合的人越来越多，这个圈子也越来越大，我们也完全可以通过两个人将两个圈子融合到一起。
 并查集的主要操作有两个：查询某个元素属于哪个集合，合并两个集合。
并查集的表示 并查集是一个树结构，根结点用来代表集合，集合中的其他元素都指向根结点。即我们每个朋友圈都有个代表人物，我们只要报出各自的代表人物的名字，就可以知道我们是不是同一个圈子的人。
#define MAXSIZE 10 typedef int SetName; typedef int Set[MAXSIZE]; // Set数组里面有好多集合 // Set[i] 表示 i 的所属圈子的大佬  初始化朋友圈 void Init() { int i; for(i=0;i&amp;lt;MAXSIZE;i++) Set[i] = i; // 一开始，每个人的圈子只有自己 }  你哪个圈子的？lo娘?！ void Find(Set s[], int x) { // 直到s[x]=x时循环结束 for(;s[x]!=x;x=s[x]); return x; // 返回圈内大佬 }  老妹儿啊~咱俩挺投机滴，拉我进圈儿呗~ void Union(Set s[], int a, int b) { int dalao1 = Find(s, a); int dalao2 = Find(s, b); // 若他们的大佬是同一个人，那他俩就属于同一个圈子 if(dalao1 == dalao2) return; // 否则，将a的圈子并入b的圈子 s[dalao1] = dalao2; // dalao1 认 dalao2 为大佬 // 也可以反过来 }  dalao1：“我TM不服！为什么我要认他做大哥！”</description>
    </item>
    
    <item>
      <title>对Redux的理解</title>
      <link>https://hueralin.github.io/2019/redux-sourcecode/</link>
      <pubDate>Tue, 15 Oct 2019 15:53:24 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/redux-sourcecode/</guid>
      <description>最近根据网课实现了一遍Redux，现在来说下自己的理解，myRedux
React产生的原因 或者说，我为什么使用Redux。在我编写Redux代码的过程中遇到的最棘手的问题就是共享状态，不仅仅是组件传值，组件传值是发生在父子组件等具有嵌套关系的情况下，而在兄弟组件甚至什么关系都扯不上的组件之间，只能称为共享状态。在Redux未出现前，父子组件传值靠的是props，在层级非常深的情况下，这种方法就显得非常麻烦。另外一种父子组件传值的方法就是Context，Context 提供了一种在组件之间传递状态的方式，而不必显式地通过组件树的逐层传递props。虽然它也可以用于组件传值，但这并不是它的本职工作。Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，即共享数据。而组件传值发生在父子组件，祖先和孙子组件之间，也就是说这种情况下的作用范围比较小（局部的），还可能有交叉的情况，this.context的指向就已经很模糊了，若有好多地方都这么用的话，也是一场灾难。也就是说Context方法使数据变得混乱、分散。（据说最新的Context API非常好用&amp;hellip;&amp;hellip;😂）
Redux Redux是一个不依赖于任何前端框架的JS状态管理库，Redux的思想是将应用的所有状态放在一起，集中管理，也就是放在全局。任何组件都不能直接修改状态，必须通过store对象的dispatch方法去发送一个action指令，通知reducer按照指令修改store中的状态。网课上实现的方式用闭包实现的单例模式，将state封装在store内部，向外暴露了三个API，分别是getState、dispatch、subscribe。订阅状态用subscribe、获取状态用getState、修改状态用dispatch。
createStore store是一个状态管理仓库，通过createStore方法创建。该方法创建了个闭包，返回一个store对象，里面包含上述三个方法来实现对状态的管理。单纯的使用Redux，就是在入口文件创建一个store，作为全局的状态仓库。 其他组件需要访问状态的话就将其导入进组件，使用API访问。
action action即指令，一个含有type属性的对象。type指明的是这个命令的内容或目的，表明这个命令是干嘛的。为什么这么设计呢？我认为是为了保证状态的安全性，因为指令是用户（程序员）发出的，万一这个指令不合法（可能是误操作），可能会对state造成破坏，同时type的设置也让指令更加语义化。
reducer reducer是一个纯函数，它接收旧状态和action，返回新状态。reducer是唯一一个有权修改状态的人，dispatch发送完指令后会调用它，让reducer来执行指令，reducer会做一次检查，即使用switch来匹配相应的action，执行对应的操作，若没有则返回旧对象（防止不合法的指令）。最后，当状态修改完毕后，通知所有的订阅者更新视图。
dispatch dispatch是一个发送指令的操作，即指令分发器。任何状态的修改必须调用该函数，尽管该函数不能直接修改状态。
subscribe subscribe是订阅函数，订阅状态的变化。它的参数是一个回调函数，当状态变化时就会调用它。在网课中的实现，这个回调函数是一个固定的写法。当状态变化时我们做什么？当然是重新渲染页面！于是这个回调函数就是这样的：
subscribe(() =&amp;gt; { this.setState({ number: store.getState().number }) })  调用setState触发重新渲染，完成了一次store到state的映射。
combineReducers combineReducers是一个合并reducer的函数。reducer接收旧状态和action，返回新状态。reducer函数接收的state有一个默认值，我们可以认为reducer是状态的起点，或者说状态是在这里初始化的。也就是说状态和reducer是相关的，该reducer里面的指令都是对这个状态进行的操作。而我们一般有很多的业务逻辑，会涉及到很多的状态，如果我们都放在一起，那么代码会非常混乱，文件也比较大。因此我们按照业务逻辑划分reducer，让它操作不同的状态。这样分而治之，我们可以给createStore传入不同的reducer来创建不同的store，的确使代码变得简洁大方，业务逻辑清晰。但是我们Redux的初衷是将状态集中起来管理，而我们上述操作违背了这一原则。我们好不容易分开了，为什么要合并回去呢？其实我们最终要的是合并后的单一的store，我们拆分出来只是为了逻辑清晰。combineReducers函数接受一个对象，键为reducer名，值为reducer函数，combineReducers函数返回一个合并后的reducer，这个reducer最终合并出了一个单一的store。具体的操作方法为，初始化一个合并后的state，遍历传入的对象，执行对应的reducer返回各个业务逻辑的state，并以reducer名为键存入合并后的对象中，最后combineReducers返回这个合并后的对象。
react-redux react-redux是redux的react版，我们开发React应用一般使用这个，react-redux只是在原有的redux上进行扩展。
当我们在组件中使用Redux时，会发现有许多操作是重复的。例如：store到state的映射，组件挂载前设置订阅函数，组件销毁时取消订阅，react-redux将这些操作通过一个connect函数封装了起来。
而且我们之前使用Redux的时候，是将创建的store在各个需要的地方导入，虽然和我们每个组件都要导入React一样，但我们仍需要将其集中在一个地方（如果可以的话，我也不愿意每次都导入React）。react-redux使用一个Provider组件将store放在最顶层，并向下传递。
connect connect函数是一个高阶函数，参数为mapStateToProps函数和mapDispatchToProps函数，返回值也是一个函数。这个返回的函数以一个组件为参数，返回包装后的组件。代码如下：
import { store } from &#39;./store&#39; let connect = (mapStateToProps, mapDispatchToProps) =&amp;gt; { return (Component) =&amp;gt; { // 创建一个容器组件 class Container extends React.Component { constructor(props) { super(props) this.state = {} } componentWillMount() { this.</description>
    </item>
    
    <item>
      <title>HTTPS</title>
      <link>https://hueralin.github.io/2019/https/</link>
      <pubDate>Sat, 12 Oct 2019 14:11:39 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/https/</guid>
      <description>HTTP协议的弊端 报文明文通信 由于HTTP协议本身没有加密手段，所以无法对通信的内容进行加密。因此，一般情况下的HTTP通信都是明文通信的，索引很容易被截获窃听。为了保证通信的安全，必须采取某种外部加密措施。
加密的方式一般有两种，对通信的加密和对内容的加密。
对通信的加密就是 HTTP + SSL/TLS 这种，在真正通信之前先建立一个加密的通信线路。
对内容的加密就是先对要发送的内容进行加密，把加密后的内容放进报文里发送，前提是要求客户端和服务器同 时具备加密和解密机制。
不进行身份验证 HTTP是不进行身份验证的。在TCP三次握手过程中也仅仅是验证双方的收发能力是否完好，并不对通信的双方进行身份验证。也就是说服务器对发来的请求照单全收并且会给对方一个响应。
 无法确定请求发送的目的服务器是真正的服务器。
 无法确定收到响应的客户端是真正的客户端。
 无法确定客户端用户是否有访问权限，因为服务器上的有些信息需要有权限的用户才能访问。
 服务器照单全收，包括垃圾请求（DoS）。  无法验证报文的完整性 因为HTTP报文是明文发送的，所以中途有可能被篡改，但是HTTP协议没有数据验证功能，对方接受到的数据可能是被篡改过的。例如中间人攻击，当我们在网站上下载一个文件时，文件在传输过程中被篡改，客户端无法确认下载的是否为正确的文件，可能是带有病毒的文件。
为了有效地防止上面的弊端，我们有必要使用HTTPS。既然单独使用HTTP协议无法确保安全，我们就必修将HTTP协议和其他协议结合起来，共同完成目标。
HTTPS HTTPS = HTTP + 加密 + 身份认证 + 数据完整性验证
HTTPS 即 HTTP Secure，是身披SSL外壳的HTTP。传统的通信方式是HTTP直接和TCP通信，而HTTPS在中间加了一层SSL，演变成先和 SSL通 信，再由 SSL和 TCP 通信。有了SSL加持，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护 这些功能。
公钥加密技术 现在常用的加密技术里有两种：对称加密　和　非对称加密。
对称加密就是双方都持有约定好的加密解密算法，但是一旦双方约定好的加密解密算法被第三方知道了，加密也就没有了意义。所以如何将约定好的加密解密算法传给对方是个问题，而且还得保存好自己手中的密钥。
非对称加密采用了双密钥的方法，一对公私钥。公钥加密私钥解密，或者私钥加密公钥解密。公钥可以公开，四月自己保存好。这样，传递只传公钥，不怕被别人知道，毕竟只能私钥解开。所以公钥加密，私钥解密比较安全。
混合加密 HTTPS采取的是对称加密和非对称加密相结合的方法，因为非对称加密的开销比较大。HTTPS使用非对称加密传递对称加密所需要的密钥，保证密钥的安全，然后再使用对称加密方法进行通信。
证明公钥正确性（可信度）的证书 即使使用了“混合加密”也是有问题的，因为我们没法确认公钥的安全性，万一拿到的公钥是假的呢？如果连SSL这一层都无法安全通过，那接下来的通信一定是不可靠的。
为了解决上面的问题，我们使用了一种叫做证书的东西，由数字证书颁发机构（CA）发布的一种电子凭证。
申请流程：
1. 申请人向CA提出公钥证书的申请
2. CA对使用自己的私钥对申请人的一些基本信息以及申请人的公钥进行签名（相当于加盖发证书机 构的公章）
3. 将公钥放到公钥证书中，发给申请人
客户端收到服务器发来的公钥证书后的验证流程：
客户端使用CA的公钥（一般内置在浏览器中），对证书上的数字签名进行验证，验证通过说明是权威机构（说明机构可信）颁发的证书，该服务器的公钥可信，身份可信。</description>
    </item>
    
    <item>
      <title>用Node.js讲解Cookie</title>
      <link>https://hueralin.github.io/2019/cookie/</link>
      <pubDate>Sat, 12 Oct 2019 09:50:42 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/cookie/</guid>
      <description>Cookie 靠死记硬背是学不了东西的&amp;hellip;
搭建简易的服务器环境 let express = require(&#39;express&#39;) let app = express() app.get(&#39;/&#39;, (req, res) =&amp;gt; { // 在响应中添加cookie res.cookie(&#39;background&#39;, &#39;skyblue&#39;) res.cookie(&#39;color&#39;, &#39;green&#39;) res.send(&#39;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&#39;) }) app.listen(3000)  发起请求并分析字段 我们请求下试试看：
一开始，我们假设当前域名下是没有cookie的，第一次请求的时候也不会带上cookie。第一次响应时，服务器设置了两个cookie，如上图的set-cookie字段。当我们再次请求时，浏览器会自动带上cookie，如下图：
注意：我们设置cookie前，响应报文没有set-cookie字段，请求报文也不会有cookie字段。
因为我们设置了两个cookie，见上图，cookie字段里不同的cookie之间是通过；和 空格 分割的。
以上就是cookie的大体工作流程。下面我们来介绍下cookie。
Cookie 我们知道HTTP协议是无状态的协议，即TCP连接断开后，当浏览器再次请求访问时，服务器根本不认识这个客户端。但是我们在某些情况下却又希望服务器能记住客户端的状态，这时cookie出现了。
 Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的 Cookie。-————《图解HTTP》
 Cookie的属性 Cookie的属性有六种：
1. NAME=VALUE 2. expires=日期 3. path=路径 4. domain=域名 5. secure 6. httpOnly
expires 指定浏览器可发送 Cookie 的有效期，若省略的话，则有效期为该会话结束，即关闭浏览器。
在HTTP/1.1中有个max-age属性，该属性值设置的是相对时间，以秒为单位，优先级比expires高。
path 限制指定 Cookie 的发送范围的文件目录
domain 指定cookie发送的域名，即发送请求时如果当前URL的域名是该domain或者是该域名的子域，就可以携带该cookie。子域可以访问父域的cookie，即从子域发起请求时，cookie字段会带上父域的cookie字段，反之不行。</description>
    </item>
    
    <item>
      <title>CSS Grid 布局</title>
      <link>https://hueralin.github.io/2019/grid/</link>
      <pubDate>Fri, 11 Oct 2019 10:49:22 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/grid/</guid>
      <description>推荐教程：阮一峰
妈耶~好长~
术语 容器和项目
容器就是外面的壳儿~，项目就是它的孩儿（第一层子元素），孙子不算哦~~~
网格线
m行n列，就有m+1个水平网格线和n+1个垂直网格线
CSS属性 CSS属性有两种：容器属性 和 项目属性
容器属性 display  grid：指定一个容器采用网格布局，当然这个容器时块级元素。 inline-grid：将块级元素变为行内的元素，采取网格布局。  “注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。”
grid-template-rows/columns 划分行高和列宽
/* 3行3列 */ .container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; } /* 也可以使用百分比 */ /* 如果行列很多的话，这样会比较麻烦，可以使用repeat() repeat(n, item) 重复item n次 */ .container { display: grid; grid-template-columns: repeat(3, 33.33%); grid-template-rows: repeat(3, 33.33%); }  repeat关键字 /* 当然，item也可以是某种模式，比如： */ grid-template-columns: repeat(2, 100px 20px 80px); /* 这样的话会出现6列，按上面的次序重复排列，但是如果超出容器的宽度呢， 实际上可以给容器设置宽度，但是对内部的项目无效，即使容器的宽度被设为10， 项目也会按照6列排列 */  auto-fill关键字 /* n 也不止是次数，也可以是 auto-fill 关键字 ，该关键字表明会自动排列， 即容器只要有空间就会一直排下去，直到换行。*/ grid-template-columns: repeat(auto-fill, 200px)  fr 关键字 /* fr关键字表示比例关系，如下，第二列宽度是第一列的2倍 */ .</description>
    </item>
    
    <item>
      <title>圣杯布局</title>
      <link>https://hueralin.github.io/2019/shengbeibuju/</link>
      <pubDate>Fri, 11 Oct 2019 10:01:26 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/shengbeibuju/</guid>
      <description>圣杯布局：
 顶部和底部占满屏幕宽度 中间的部分是一个三栏布局 三栏布局两侧固定宽度，中间部分自适应 中间部分的高度是三栏中最高的区域的高度  总体来说，还是一个三栏布局，这也是重点部分。
浮动实现 &amp;lt;style&amp;gt; .top,.bottom { height: 100px; margin: 5px 0; background-color: orange; } .middle { margin:5px 0; } .left,.right { width: 200px; height: 400px; background-color: skyblue; } .left { float: left; } .right { float: right; } .content { overflow: hidden; /* 形成BFC，防止文本环绕 */ padding: 0 5px; background-color: #eee; } &amp;lt;/style&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;top&amp;quot;&amp;gt;顶部&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;middle&amp;quot;&amp;gt; &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;左侧&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;右侧&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;content&amp;quot;&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;quot;bottom&amp;quot;&amp;gt;底部&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt;  flex实现 &amp;lt;style&amp;gt; .</description>
    </item>
    
    <item>
      <title>HTTP缓存策略</title>
      <link>https://hueralin.github.io/2019/httpcache/</link>
      <pubDate>Wed, 09 Oct 2019 20:00:01 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/httpcache/</guid>
      <description>我再也不废话了&amp;hellip;&amp;hellip;切入正题!
HTTP缓存策略有两种:强缓存和协商缓存.
先大体说一下浏览器缓存的过程:
 浏览器向服务器发起请求前首先向浏览器缓存查询是否有该请求的结果及缓存标识.
 有,则从缓存中读取(强缓存成功),否则再去询问服务器(协商缓存 or 直接请求).  强缓存策略 强缓存的三种情况:
 请求前先去询问浏览器缓存,若有缓存且未失效,则直接从浏览器缓存读取结果,此被称之为&amp;rdquo;强缓存成功&amp;rdquo;.
 &amp;ldquo;强缓存失败&amp;rdquo;, 若有缓存,但已失效,则执行&amp;ldquo;协商缓存&amp;rdquo;策略.
 &amp;ldquo;强缓存失败&amp;rdquo;, 若无缓存, 则向服务器正式发起请求.  强缓存策略涉及到的HTTP头部: Cache-Control / expires
expires 是 HTTP/1.0 的产物,它的值是一个绝对值,即缓存失效的时间点.浏览器会拿客户端的时间和缓存中的此标识做对比,来判断缓存是否过期.所以它的缺陷比较明显,因为客户端和服务器的时间并不总是同步的,也就是说可能出现误差.(可能影响并不多大,别喷我&amp;hellip;&amp;hellip;)
Cache-Control 是 HTTP/1.1 的产物,它的值就丰富多了:
 public 所有内容都将被缓存(客户端和代理服务器都可以)
 private 默认值,只有客户端才能缓存，表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的
 no-cache 只有客户端缓存，强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证器的请求到服务器，即必须经过协商缓存
 no-store 所有内容都不缓存
 max-age=xxx 缓存将于xxx秒后失效  我们一般使用第五种方式
可以看到cache-control使用的是相对时间,弥补了expires的时间误差缺陷. 在实际应用过程中这两种方式都会有,但是cache-control的优先级要高一些.
协商缓存策略 协商缓存发生在有缓存但到期的情况下. 实际上, 服务器设置的过期时间是用来表明此时的缓存可能会过期, 但我不能保证, 届时你得向我确认一下, 所以, 缓存并不一定失效了. 和商品的保质期一个道理.
此时, 我们需要向服务器发起请求, 询问这个缓存能不能用, 如果服务器表示能用, 返回304, 那我们就去缓存中读取, 否则我们再向服务器请求新的数据.</description>
    </item>
    
    <item>
      <title>清除浮动</title>
      <link>https://hueralin.github.io/2019/float/</link>
      <pubDate>Wed, 09 Oct 2019 15:16:09 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/float/</guid>
      <description>清除浮动是个老生常谈的问题了，面对这个问题我们往往能说出一两个解决方法，但你是否知道其背后的原理呢？《CSS世界》这本书给出了很好的解答，现推荐下张鑫旭近10年前的博客。
CSS float浮动的深入研究、详解及拓展(一)
CSS float浮动的深入研究、详解及拓展(二)
别废话!切入正题!
 清除浮动的原因 浮动布局时不小心高度塌陷了呗~
浮动的真正目的 浮动的出现仅仅是为了让文字围绕图片而已，就像WORD中的“文字环绕”一样。
浮动的原理 在张鑫旭的两篇文章中将浮动的本质定义为“包裹与破坏”。
1. 浮动的包裹性
浮动就是个带有方位的display: inline-block; inline-block就是让一个块级盒子变成一个内联盒子，不让其独占一行，而是将其内容紧紧地包裹起来。而在块级盒子上应用了浮动，你会发现其确实变成了一个内联盒子。
2. 浮动的破坏性
结合“浮动的本职工作是实现文字环绕图片”来说明其“破坏性”。
文字之所以会环绕含有float属性的图片时因为浮动破坏了正常的line boxes
line box模型:
&amp;lt;p&amp;gt;float的本职工作是实现&amp;lt;em&amp;gt;文字环绕图片&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;!-- 上面代码包含四个box 1. inline box：‘float的本职工作是实现’是匿名的inline box，‘&amp;lt;em&amp;gt;文字环绕图片&amp;lt;/em&amp;gt;’是inline box。 2. line box：一个个的inline box排成一行就是一个line box，多行则有多个line box。 3. content area：在我理解就是内容区域包含上面所有的一种box。 4. &amp;lt;p&amp;gt;标签所在的containing box，此box包含了其他的boxes。 以上3，4解释不够严谨或有错误，可不做参考，日后修正。 --&amp;gt;  默认无浮动的图文混排是这个样子的（借用下图片）：
图片本身就是个inline box，和两侧的inline box共同组成了line box，line box的高度由最高的inline box决定，第二行文本属于另一个line box，且一张图片只能与一个line box对其。
给图片加了浮动之后：
图片不再和其他的inline box在一块了，可见浮动使图片丧失了inline box特性。而丧失了inline box特性的后果就是高度塌陷。为什么呢？
在CSS中，所有的高度都是有两个CSS模型产生的。box模型，line box模型。
box模型：height + padding + margin</description>
    </item>
    
    <item>
      <title>Git Reflog</title>
      <link>https://hueralin.github.io/2019/gitreflog/</link>
      <pubDate>Mon, 07 Oct 2019 22:13:09 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitreflog/</guid>
      <description>是不是 git reset &amp;ndash;hard 之后傻眼了~~~嗯？ 来咯来咯~ git reflog 真的来咯~~
git reflog git reflog 工具会记录你每次对HEAD的更改，即当你提交、切换分支或者reset后，HEAD都会更改，reflog都会记录下来你的操作。
比如：
// git log --oneline b2d387d (HEAD -&amp;gt; master) add index.css 9515998 initial reset 29adb97 (origin/master, origin/HEAD) add branch_learn 1563c0f add log.md 53b7acc add What&#39;s commit/log.md f318db2 git add --all // 现在我们不小心回退到 1563c0f 这个提交 // git reset --hard 1563c0f // git log --oneline 1563c0f (HEAD -&amp;gt; master) add log.md 53b7acc add What&#39;s commit/log.md f318db2 git add --all // 此时，暂存区和工作目录都回退到了指定的提交，那些未保存的修改都没了.</description>
    </item>
    
    <item>
      <title>LearnGitWithBitbucketCloud(3-4-4)-Git Reset</title>
      <link>https://hueralin.github.io/2019/gitreset-translation/</link>
      <pubDate>Mon, 07 Oct 2019 11:30:54 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitreset-translation/</guid>
      <description>[假面包屑导航] Git tutorials / Getting Started / UndoingChanges / git-reset
“这是一篇译文”，本人水平有限，若有错误请参考原文
The git reset command is a complex and versatile tool for undoing changes. It has three primary forms of invocation. These forms correspond to command line arguments &amp;ndash;soft, &amp;ndash;mixed, &amp;ndash;hard. The three arguments each correspond to Git&amp;rsquo;s three internal state management mechanism&amp;rsquo;s, The Commit Tree (HEAD), The Staging Index, and The Working Directory.
git reset 命令是用于撤销更改的复杂而又通用的工具。它有三种主要的调用形式，这三种形式分别对应着命令行参数 &amp;ndash;soft, &amp;ndash;mixed, &amp;ndash;hard。这三种参数分别对应着Git的三种内部状态管理机制，The Commit Tree (HEAD), The Staging Index, and The Working Directory。</description>
    </item>
    
    <item>
      <title>call, apply, bind</title>
      <link>https://hueralin.github.io/2019/callapplybind/</link>
      <pubDate>Sun, 06 Oct 2019 13:27:32 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/callapplybind/</guid>
      <description>call apply bind 这三个函数的作用都是将一个函数的this指向另一个对象，使得该对象可以调用这个它自身没有的函数。
 Func.call(thisObj, [arg1,arg2,&amp;hellip;.]) thisObj 作为Func内部的this，它的取值有四种情况：
1. null/undefined/不传 Func的this &amp;mdash;-&amp;gt; window
2. 函数名 Func的this &amp;mdash;-&amp;gt; 该函数的引用
3. 数值/字符串/布尔值 Func的this &amp;mdash;-&amp;gt; Number/String/Boolean
4. 对象 Func的this &amp;mdash;-&amp;gt; 对象
function Func(){ console.log(this) } function Test(){console.log(&#39;Test&#39;)} var obj = { name: &#39;huer&#39; } Func.call() // window Func.call(null) // window Func.call(undefined) // window Func.call(Test) // Test(){console.log(&#39;Test&#39;)} Func.call(666) // Number {666} Func.call(&#39;666&#39;) // String {&amp;quot;666&amp;quot;} Func.call(true) // Boolean {true} Func.call(obj) // {name: &amp;quot;huer&amp;quot;}  这三个函数除了由上面的功能外，还有一个功能。还能给对象添加新属性，例如在继承中：</description>
    </item>
    
    <item>
      <title>setState</title>
      <link>https://hueralin.github.io/2019/state-async/</link>
      <pubDate>Fri, 04 Oct 2019 23:57:30 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/state-async/</guid>
      <description>State机制 setState函数是React管理组件状态的一种方法，修改组件的状态时必须使用该方法，而不能直接在this.state上赋值。但是，如果我们在调用完setState之后直接去访问State时，拿到的是修改前的值。也就是说，setState并不保证“同步执行”。
如果在一次操作中多次调用setState，那么React会将这几次操作暂存起来，然后统一集中合并，根据合并后的结果去计算新的虚拟DOM，最后执行渲染。　// 初始 count = 0 this.setState({ count: this.state.count + 1 }) console.log(this.state.count) // 0  那么如果和解决上面的问题呢？&amp;mdash;&amp;ndash;回调函数
setState函数的参数有两个，第一个参数是对象，第二个参数是回调函数。回调函数在State合并更新完后才会被调用，所以可以拿到更新后的值。
this.setState({ count: this.state.count + 1 }, () =&amp;gt; { console.log(this.state.count) // count = 1 })  下面来看另一段代码：
this.setState({ count: this.state.count + 1 }) this.setState({ count: this.state.count + 1 })  该会怎么执行呢？结果是2么？不对！结果是1。
上面提到过，多次调用setState会被合并为一次操作。上面的代码类似于下面这段：
Object.assign(state, {count: state.count+1}, {count: state.count+1})  都是操作的count，合并时只执行最后一个。
那么如何做到增加两次呢？其实setState函数的第一个参数也可以为函数：
this.setState((preState, props) =&amp;gt; {count: preState.count + 1}) this.setState((preState, props) =&amp;gt; {count: preState.</description>
    </item>
    
    <item>
      <title>技术分享之Redux思想</title>
      <link>https://hueralin.github.io/2019/share/</link>
      <pubDate>Wed, 18 Sep 2019 13:40:10 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/share/</guid>
      <description>Redux 普通的状态管理 // 状态 let state = { // 计数 count: 0 }··· // 修改状态 state.count = 1 // 获取状态 console.log(state.count)  缺点：状态改变，依赖状态的地方得不到通知
带有发布订阅的状态管理 // 状态 let state = { // 计数 count: 0 } // 集中管理订阅 let listeners = [] // 订阅函数 function subscribe(callback) { listeners.push(callback) } // 修改状态的函数 function changState(newVal) { state.count = newVal for(let i=0;i&amp;lt;listeners.length;i++){ listeners[i]() } } // main subscribe(() =&amp;gt; { console.log(&#39;count&#39;, state.count) }) changState(1) // 1 changState(2) // 2 changState(3) // 3  缺点：只对count（即单个状态）有效，应将公共操作封装起来。</description>
    </item>
    
    <item>
      <title>TCP流量控制、拥塞控制</title>
      <link>https://hueralin.github.io/2019/tcpys/</link>
      <pubDate>Mon, 09 Sep 2019 12:51:57 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/tcpys/</guid>
      <description>计算机网络推荐书籍：计算机网络（谢希仁）
TCP流量控制、拥塞控制
在前端面试中关于计算机网络的知识多半是HTTP协议、TCP/IP协议，拥塞控制之类的。昨天看了几篇关于拥塞控制的文章，现来做一些总结。
TCP流量控制 一、 流量控制的原因
双方在通信时会涉及到通信速率的问题，即发送速率和处理速率，这两个速率往往是不一样的。如果发送方的发送速率太快，接收方来不及处理，就会将报文放进缓存，若发送方仍不控制发送速率，那么缓存终会爆满，导致丢包，浪费网络资源，所以应该对发送方的发送速率进行控制，使发送方和接收方达到一种动态平衡。
流量控制，即控制发送方的发送速率。
二、滑动窗口
滑动窗口协议：TCP协议中的一种应用，用于网络数据传输中的流量控制。
该协议允许发送方在停止并等待确认报文前发送多个数据，不必每发完一段数据就定下来等待确认，提高网络的吞吐量，所以TCP定义了一个滑动窗口协议，滑动窗口包括发送窗口和接受窗口。
相关概念
1. 窗口：一段可以被发送者连续发送的字节序列范围。
2. 滑动：“窗口”的大小会随着发送过程变化，这种变化是在字节序列上按顺序滑动的。
因为TCP协议是全双工协议，所以双方都有一个发送缓冲区和接收缓冲区。
发送缓冲区接收来自应用层的数据（一长条字节流？），而发送窗口框住了其中的一部分（前面说了，窗口其实是一段范围）。
发送缓存区相关的四个概念：
1. 已发送并受到确认
2. 已发送但未收到确认
3. 允许发送但未发送
4. 不允许发送
其中，允许发送的数据都在发送窗口内。每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送。
下面，我借由计算机网络（谢希仁）中的图片来讲解一下过程(后来发现copy率达到99.9%)：
A B 双方在建立TCP连接的时候，B就已经向A给出了自己的窗口值，发送方A会根据这个值来构造自己的发送窗口。
发送窗口表示：在没有收到B的确认情况下，A可以连续把发送窗口中的数据都发送出去。凡是发送过的数据在未收到确认前都应留在发送窗口内，以便超时重传。
发送窗口的位置由前沿和后沿的位置来确定：
1. 前沿：不动或前移。不动，可能是因为没有收到确认，或收到了确认但接受窗口缩小了。
2. 后沿：不动或前移。
A发送了11个字节的数据，但未收到新的确认，所以前沿后沿都不变，即发送窗口的位置不变。
看B的接收窗口，32 33 未按序到达，因为接收方发送的确认号ack是由按序到达数据的最高序号决定的，所以B返回的确认号仍然是31。导致了A的发送窗口不变。
描述一个发送窗口的状态需要三个指针：p1、p2、p3。
1. 小于p1：已发送且已收到确认的部分
2. 大于p3：不允许发送的部分
3. p3 - p1：发送窗口
4. p2 - p1：已发送但未收到确认的部分
5. p3 - p2：允许发送但未发送的部分，又叫“可用窗口”、“有效窗口”
B 收到了31，然后返回确认号34，表明31 32 33 都收到了，且已交付主机。A收到确认号后，发送窗口前移，后沿前移3位指向34。指针p2不动，可用窗口变大，可发送42-53的数据。
42-53的数据都被发送了出去，p2指针与p3指针重合，但是没有收到确认，使得可用窗口为0，A不能再发送数据，必须等到B的确认。但是B发送的确认可能在网络中延时了，没有及时到达，A就会一直等，B也会一直等待A发送数据，造成死锁。所以A有一个超时计时器机制，一段时间后没有收到B的确认，会自动重传这部分数据并重置超时计时器，直到收到B的确认为止。
三、如何控制
流量控制主要依靠滑动窗口来实现
流量控制即接收方B向发送方A传递消息，使其不要发送太快～，是一种端到端的控制。利用B返回的报文中的接收窗口的大小来控制A的发送窗口大小。rwnd: 接收窗口</description>
    </item>
    
    <item>
      <title>字节跳动面试题</title>
      <link>https://hueralin.github.io/2019/bytedance/</link>
      <pubDate>Wed, 04 Sep 2019 16:18:24 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/bytedance/</guid>
      <description> 实现sleep函数（将程序挂起一段时间，阻塞运行） 我能想到的方法就是ES6的 async/await function my_sleep (time) { return new Promise((resolve) =&amp;gt; { setTimeout(() =&amp;gt; { resolve() }, time) }) } async function main() { console.log(&#39;start&#39;) await my_sleep(5000) console.log(&#39;end&#39;) } main() 网上还有一种解法，利用循环+Date()，不断的循环，检测当前时间是否超出了间隔时间 原理就是一直在执行同步任务，阻塞下面同步任务的执行 function my_sleep (time) { let start = new Date().getTime() // 一串长数字 let end = start + time // time是毫秒 while(new Date().getTime() &amp;lt;= end){} } console.log(&#39;start&#39;) my_sleep(5000) console.log(&#39;end&#39;)  </description>
    </item>
    
    <item>
      <title>用友笔试题</title>
      <link>https://hueralin.github.io/2019/yongyou/</link>
      <pubDate>Wed, 04 Sep 2019 15:07:51 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/yongyou/</guid>
      <description>21题
css 中经常有类似 background-image 这种通过 - 连接的字符，通过 javascript 设置样式的时候需要将这种样式转换成 backgroundImage 驼峰格式，请完成此转换功能。
输入：-webkit-background-image
输出：webkitBackgroundImage
 解法一、 思路：将输入按照‘-’分开，得到一个数组，例如：[&#39;&#39;, &#39;webkit&#39;, &#39;background&#39;, &#39;image&#39;] 然后从第三个元素开始，将首字母变大写（注意字符串是不可变的） function func(pre){ let splitArr = pre.split(&#39;-&#39;) for(let i=2;i&amp;lt;splitArr.length;i++){ splitArr[i] = splitArr[i][0].toUpperCase() + splitArr[i].slice(1) } return splitArr.join(&#39;&#39;) }  解法二、 思路：   22题
请实现一个简单的事件机制，能够实现对事件的触发和监听。 如：EventEmitter.on(); EventEmitter.trigger();
 思路：封装一个对象，该对象有两个方法：on、trigger。on方法接收两个参数，事件名和回调函数，如果一个事件可以绑定过个回调，可以考虑使用数组。trigger方法接受一个参数，即事件名，拿到指定事件，将该事件下的所有回调函数执行一遍。 这种写法只是实现了时间的触发和更新，并没有将事件绑定到某个元素上。 function EventEmitter () { let eventObj = {} function on (eventName, callback) { if (!eventObj[eventName]) { eventObj[eventName] = [] } eventObj[eventName].</description>
    </item>
    
    <item>
      <title>节流和防抖</title>
      <link>https://hueralin.github.io/2019/debounceandthrottle/</link>
      <pubDate>Tue, 03 Sep 2019 17:43:42 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/debounceandthrottle/</guid>
      <description>lodash 防抖源码解读 function debounce(func, wait, options) { let lastArgs, lastThis, maxWait, result, timerId, lastCallTime let lastInvokeTime = 0 let leading = false let maxing = false let trailing = true // Bypass `requestAnimationFrame` by explicitly setting `wait=0`. const useRAF = (!wait &amp;amp;&amp;amp; wait !== 0 &amp;amp;&amp;amp; typeof root.requestAnimationFrame === &#39;function&#39;) if (typeof func !== &#39;function&#39;) { throw new TypeError(&#39;Expected a function&#39;) } wait = +wait || 0 if (isObject(options)) { leading = !</description>
    </item>
    
    <item>
      <title>JS 事件循环</title>
      <link>https://hueralin.github.io/2019/eventloop/</link>
      <pubDate>Mon, 02 Sep 2019 18:56:56 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/eventloop/</guid>
      <description>MDN 事件循环
详细的不知道该给这个链接命什么名好!
Ahhhhhh, 这JS学的，不断刷新世界观~
事件循环可谓是JS中的一大重点，如果说之前的JS执行环境从微观角度上说明了函数内部的执行原理，那么事件循环则从宏观角度上说明了整个JS代码的执行情况。
事件循环中的关键概念：执行栈、任务源、任务队列
执行栈 由于JS是单线程的，一定时间内只能执行一个函数，所以这些函数就得按照一定的顺序排好队，但它并不是一个队列，因为函数调用会涉及到作用域链的问题，函数调用之间有着一定的嵌套关系，所以栈结构比较合适。那么由函数调用组成的栈，也被称为 “执行栈” ，函数被调用时压入栈，执行完毕弹出栈。结合 JS执行环境 中所讲的内容，函数调用栈中的每一个帧都是一个执行环境，执行环境里面包含着变量对象（函数被调用时才会有）。
任务源 这个高大上的名词可能没见过，但是它本身却很常见。顾名思义，任务源就是分发任务的源头，绝大部分是异步任务。分发异步任务的源头有哪些呢？setTimeout ！setInterval ! promise !等等都是任务源，这些函数在被执行的时候都是立即执行的，但是它们所分发的任务需要在特定的情况下才会被执行，而这些特定的环境则需要事件循环机制来处理。任务源所分发的任务才会被放进任务队列中。
任务队列 MDN 上叫“消息队列”，好像是从前的说法，讲的有些笼统。新标准下给了它们新的名字：任务队列，给异步任务做了更细致的划分。任务队列分为：“宏任务”和“微任务”。 宏任务包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI渲染。微任务包括：process.nextTick，Promise, Object.observe(已废弃), MutationObserver(html5新特性)。
推荐两篇博客：
深入浅出JS事件循环机制（上）
深入浅出JS事件循环机制（下）
上面两篇博客涉及到了WebpAPIs，文中给出了三种常见的WebAPIs，DOM相关、网络相关、定时器相关。
下面用一个简单的例子来说明：
现在开始执行JS代码，main()入栈，执行到console.log()，log函数入栈，执行log函数，控制台输出&amp;rsquo;Hello world!&amp;rsquo; log函数出栈，setTimeout函数入栈，执行栈发现setTimeout函数是WebAPIs，于是将setTimeout所分发的任务交由浏览器内核对应的timer模块处理，然后将setTimeout函数出栈。
setTimeout函数出栈，console.log(&amp;lsquo;end&amp;rsquo;)入栈，执行完毕后控制台输出&amp;rsquo;end&amp;rsquo;，然后console.log()函数出栈，若timer模块计时结束就将回调函数放进任务队列。
然后执行栈中还剩下main()，main函数出栈，此时执行栈为空。开始检查任务队列，队列中有任务，就拿到执行栈中去执行。再依次出栈。
这个例子中只使用了setTimeout，是WebAPIs中的一个。其他的WebAPIs例如ajax请求，DOM等都由浏览器内核中不同的模块去处理。结合前面讲的任务源，来自不同任务源的任务会被放进不同的任务队列。即setTimeout分发的任务会进入setTimeout任务队列（因为可能会有多个setTimeout被调用），诸如setTimeout、setInterval等又同属于“宏任务”，而像promise等则属于“微任务”。既然有“宏任务”和“微任务”之分，那么当执行任务队列中的任务时先去哪个呢？下面来讲一下时间循环的具体流程。
事件循环的流程  从script整体代码开始，执行同步任务。
 当碰到异步任务时，会将异步任务交由对应的浏览器内核模块去执行，执行完毕后将其回调函数（即事件处理程序）放到对应的任务队列中，等待被执行。
 第二步并不会阻塞下面同步代码的执行。
 当执行栈为空时，就会优先去检查“微任务”，“微任务”中有“process.nexttick任务队列”、“promise队列”等，前者优先级大于后者，拿出队首任务放到执行栈中执行，执行完出栈，继续拿下一个“微任务”，直到所有的“微任务队列”清空。此时，一轮循环结束！
 下一轮循环从“宏任务”开始，“宏任务”包括“setTimeout任务队列”、“setInterval任务队列”等，拿出队首的宏任务放进执行栈中执行，执行完出栈。注意！当一个“宏任务”又创建了一个“微任务”的话，则会将该“宏任务”所在的“宏任务队列”清空后，再转去处理微任务，且微任务被清空后，才会执行下一个“宏任务队列”，也就是说，“微任务”可插队！。
 事件循环机制会一直检测执行栈、宏任务队列、微任务队列，不断循环执行。
  例题 (function test() { setTimeout(function() {console.log(4)}, 0); new Promise(function executor(resolve) { console.log(1); for( var i=0 ; i&amp;lt;10000 ; i++ ) { i == 9999 &amp;amp;&amp;amp; resolve(); } console.</description>
    </item>
    
    <item>
      <title>狐耳的技术栈</title>
      <link>https://hueralin.github.io/2019/stack/</link>
      <pubDate>Mon, 02 Sep 2019 17:08:32 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/stack/</guid>
      <description> JavaScript JS闭包
 JS执行环境/AO/VO
 事件循环
 async/await
  HTML CSS 性能优化手段 webpack </description>
    </item>
    
    <item>
      <title>JS执行环境，作用域链，变量对象/活动对象</title>
      <link>https://hueralin.github.io/2019/jsec/</link>
      <pubDate>Mon, 02 Sep 2019 11:20:42 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/jsec/</guid>
      <description>JS的重点内容之一，虽然不会在面试题中直接那么问，多半给你出一段代码，看输出什么。
我觉得了解了这部分内容，能让我们对整个JS的执行流程有个详细、准确地认识，在面对工作中的一些错误也能快速且正确的排错。
JS执行环境 JS的执行环境又被称为执行上下文（Execution context），简称EC。顾名思义，JS执行环境就是JS执行时才会存在的环境，常见的执行环境有两种：全局执行环境和函数执行环境。当JS代码执行的时候，我们会进入不同的执行环境，这些执行环境会构成一个执行环境栈。
EC的组成：
1. 变量对象（VO）：包含变量的对象，无法被访问
2. [[scope]]：作用域链，由变量对象构成，该属性是指向作用域链头节点的指针
3. this指针：指向环境对象（也是一个普通对象），而不是执行环境EC
EC的创建：
EC是在调用函数的时候创建的，一个EC的生命周期分为两个阶段：创建阶段 和 执行阶段：
1. 创建阶段：此时EC创建变量对象，建立作用域链，确定this的指向，
2. 代码执行阶段：完成变量赋值，其他函数调用等代码的执行
其中变量对象的创建也是个重点，这里涉及到了预编译的问题：
变量对象的创建：
1. 根据函数的参数，建立arguments对象（类数组，将参数值保存在下标中）。
2. 函数声明提升：扫描所有的函数声明，将函数名作为变量对象的属性名，属性值为函数在内存中的地址，如果属性名存在，则会被覆盖。
3. 变量声明提升：扫描所有的变量声明，将变量名作为变量对象的属性名，属性值初始化为undefined，如果属性名存在，则会跳过，不覆盖（防止同名的函数被覆盖为undefined，毕竟函数是一等公民嘛～）。
注意：在代码执行阶段的时候，变量才会被赋值，之前一直都是undefined。
由上可知，作用域其实就是一个变量对象。那么什么是变量对象？
变量对象（VO） 变量对象存储了EC中定义的变量和函数声明，“这个对象是规范上的，或者说是引擎实现上的，不可在JS环境中访问到”。
活动对象（AO） “活动对象其实就是变量对象的激活状态” 这是我在大多数博文中找到的介绍，即当执行流进入一个函数时，EC会被创建，变量对象会被创建，变量对象被激活成为活动对象。
此处有争议：
1. 根据“函数是被一级一级的调用的”，我是不是可以说这一级一级向下执行的函数的变量对象都是活动对象呢？毕竟这些函数都被执行了。所以说，我觉得 “活动对象” 应该是处于作用域链顶端的变量对象，该变量对象处于最近被执行的EC。
2. 另一种说法，不是存在一个执行环境栈嘛，当A函数里执行了B函数，那么B函数入栈，A函数可以想象成处于一种 “休眠” 状态，B函数才算真正被执行。所以B函数里的执行环境、变量对象被创建，变量对象被激活为活动对象。（Emmm，好像也有道理。哈！都是我的猜想😂）
当函数执行完毕，它的执行环境会被销毁，活动对象也会跟着销毁。但这是在一般的情况下，如果是 闭包，那就得另当别论。假设A函数里返回了B函数，B函数引用着A函数执行环境里的活动对象。当A函数执行完毕后，A函数的环境变量被销毁，但是活动对象依然存在于作用域的顶端。当返回的函数被调用时，会创建自己的执行环境和活动对象（此时应该就有两个活动对象），闭包函数的活动对象里面引用着上一个活动对象，当闭包函数执行完后，两个活动对象都将被销毁。
作用域链 作用域分为两种：全局作用域 和 局部作用域。
前面说过，作用域链其实就是变量对象，但并不是一个，而是一串儿😂。我们所说的局部作用域其实就是当前执行环境的变量对象，我们在查找一个变量的时候，如果在当前变量对象里面查不到的话，就会顺着作用域链一级一级的向上查找，直到全局作用域，因此全局作用域处于作用域链的末端。
示例 function a(name) { function b(age) { var x = 10 } var name = &#39;ml&#39; var x = 20 b() console.</description>
    </item>
    
    <item>
      <title>JS闭包</title>
      <link>https://hueralin.github.io/2019/closure/</link>
      <pubDate>Fri, 30 Aug 2019 17:41:06 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/closure/</guid>
      <description>参考资料：阮一峰
参考资料：MDN
之前简单学习过闭包，也会无意间使用过闭包，但如果你要问我闭包是什么我也答不上来。今天呢，重新学习闭包，做个总结。
什么是闭包 相信你在学习闭包的时候肯定看过类似的许多文章是这么说的：“闭包就是一个能够访问 其他函数的变量 的函数”，如果你看过《你不知道的javascript》这本书中关于闭包的解释，你会觉得这句话很片面，也很浅陋，而这句话被当今好多博文所提及，给好多学习闭包的小伙伴造成了不少的误解。
《你不知道的javascript》这本书中对于闭包是这么说的：“当一个函数能够访问定义它时所处环境的局部变量时，那么就形成了一个闭包（具体怎么说的我也记不太清楚了）”，重点是“形成了一个闭包”，而不是大多数人所说的闭包就是那个函数，闭包其实还跟环境有关。在MDN中也有类似的解释，开头第一句话就是“闭包是函数和声明该函数的词法环境的组合”。下面还有一段解释:
“闭包是由函数以及创建该函数的词法环境组合而成，这个环境包含了这个闭包创建时所能访问的所有局部变量”。  关于什么是词法作用域请看 [词法作用域]()
啪！MDN 还是说出了打脸的话，在makeAdder栗子中，它竟然说“add5 和 add10 都是闭包”（糟糕，我要下不来台了），为什么又说这两个函数是闭包呢，虽然后面还是扯上了词法作用域，但这让读者看起来挺迷啊（哼，双标狗！😂）。
function parent() { // 外部函数 let name = &#39;huer&#39; // 内部变量 return function children() { // 内部函数 console.log(name) } } let other = parent() other() // ‘huer’  说下我的简单理解，闭包既然被称为包，那我就可以把它想象成一个包结构（包袱），包裹着外部函数的内部变量和内部函数，并返回内部函数。注意：内部函数是要被返回的！ 如果内部函数没有被返回，那么当外部函数执行完毕后，外部函数里面的所有变量和函数都会被垃圾回收机制所清理。此时，我们就引出了闭包函数的一个重要特性，可以使某些变量长时间存在于内存中而不会被销毁。正常情况下，执行完一个函数，即return一个值后，该函数及其内部所有变量就会被回收。而当我们在函数内部又定义了一个函数时，根据对词法作用域的理解，该内部函数可以访问外部函数所定义的变量，即内部函数对它所处的词法作用域有一种引用关系，如果我们将内部函数return出去，并返回给一个变量，那么该变量就是对内部函数的一个引用，从而也能访问外部函数所定义的变量。那么这就实现了某些变量能够一直存在于内存中而不会被销毁，并且还是私有的，其他外部的变量无法访问，只有return的内部函数才能访问。
在好多博文给出的栗子中，内部函数总是使用了外部函数所定义的变量，这就使好多同学误解，返回的内部函数一定要使用外部函数定义的变量，其实这是不对的。打个比方，我们（内部函数）出生在家里（词法作用域），我们对家里的一切事物都可以够得到，摸得着（除掉‘3岁以下儿童勿碰’等乱七八糟的规则），都可以使用，这并不意味着这些东西此时就在我们手里，它们不在我们的手里，我们也对它们有使用权（即，内部函数对所处的词法作用域有引用关系）。这就是闭包。
形成闭包的条件：外部函数（词法作用域） + 返回一个内部函数
我们上面的代码只是访问了内部变量，其实我们返回的内部函数还能操作内部变量，是不是有点面向对象的感觉？
function parent() { let name = &#39;huer&#39; function getName() { return name } function setName(val) { name = val } return { getName, setName } } let obj = parent() obj.</description>
    </item>
    
    <item>
      <title>Git Stash</title>
      <link>https://hueralin.github.io/2019/gitstash/</link>
      <pubDate>Mon, 26 Aug 2019 20:09:47 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitstash/</guid>
      <description>Emmmm 最近在实习的项目中经常使用 git stash 这个命令，现在来做一些总结。
你可能会遇到这样一种情况，就是当你在进行开发或修改某个BUG的时候突然来了一个新任务（新任务与当前的开发项目属于同一个项目），时间紧迫，你需要立即切换分支去执行，可是你当前的任务还没有做完，切分支的话会被拒绝，怎么办呢？有种方法是先add再commit，确实可以，但是我感觉这么做的话会添加一个毫无意义的提交记录，虽然以后可以修改，但是太过麻烦。那么，就来试试 git stash 吧。
git stash 官方文档第一版
git stash 官方文档第二版
git stash 应用场景 git stash 的作用是将当前为提交的修改存储起来，让仓库还原到最后一次提交的状态。
使用场景：
1. 工作未完成，需要切换分支，但不想提交（常用）。
2. 开发一个feature分支（未完成），此时想要合并一下主分支，看看做了哪些修改，提前解决冲突。
现在来看看场景二的解决方法：
// 假设我在feature分支上开发，突然得知主分支更新了，于是我想要将主分支合并到当前分支，看看有没有冲突，有的话直接解决。 git checkout master // 报错！会提示当前某些修改未存储提交 // 当然，我是不想提交的，毕竟还没做完...于是， git stash save &amp;quot;先搁这儿，我去瞅瞅主分支，拉下代码～&amp;quot; // save 类似于 commit 的 -m 选项，即注释信息 git stash list // 列出来所有的存储信息，看看有木有～ git checkout master // 切换到主分支 git pull origin master // 将远程主机的master分支拉下来 git checkout feature // 切回feature分支 git merge master // 将master分支合并到feature（可能会有冲突） git stash pop // 将先前feature分支做的修改释放出来（可能会有冲突） // 有冲突合并即可，合并完，feature拥有了master分支最新的修改以及当前的特性开发。  git stash git stash 实际上是一个栈结构，它可以获取工作目录中的中间状态（包括对已追踪文件的修改和暂存的变更，使用 git status 查看），将它保存在一个栈结构中，方便以后使用。（注意！未被追踪的文件不在存储的范围内！）</description>
    </item>
    
    <item>
      <title>Mock 前端假数据</title>
      <link>https://hueralin.github.io/2019/mock/</link>
      <pubDate>Wed, 21 Aug 2019 16:09:41 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/mock/</guid>
      <description>为什么需要前端做假数据？Emmmm，不用我说了吧～
 官方文档看这里MockJs！
数据模版之类的语法去看官方文档，我这里只简单介绍一下我的使用情况。</description>
    </item>
    
    <item>
      <title>伪类 与 伪元素</title>
      <link>https://hueralin.github.io/2019/weilei/</link>
      <pubDate>Wed, 21 Aug 2019 15:17:26 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/weilei/</guid>
      <description>“请说一下伪类和伪元素的区别”，之前的面试中遇到过这个问题，当初表示只见过伪类，回答的基本上都是:hover之流，这道题就挂了&amp;hellip;&amp;hellip;
 如今，在实习中遇到了相关的需求，看来是时候深入学习一下了。其实，区分伪类和伪元素并不难，它俩最大的区别就在于应用场景。
伪类 顾名思义，它相当于一个类，是用来设置样式的；当你需要让一个元素在某种特殊状态下显示特殊的样式时（如：按钮悬浮特效），就该使用伪类。 下面我们来实现一下伪类：
需求：实现消息列表悬浮特效
&amp;lt;!-- 需求很明确，li元素在悬浮情况下应用样式 --&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;React&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Vue&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Angular&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;jQuery&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Webpack&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;NPM&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; li:hover { background: #eee; } &amp;lt;!-- 再简单不过了，当然也可以设置奇偶行样式不一 --&amp;gt;  其他的伪类：
:active :empty :enabled :first :first-child :first-child :first-of-type :focus :hover :visited :nth-child :nth-of-type :link  伪元素 顾名思义，它是一个元素，可以是现有的元素，也可以是新增的元素，这些元素往往有自己的特殊位置（如：段落首字母突出样式）往往被作为附加的标记。 下面我们来实现一下伪元素
需求：表单必填项前面加一个标识（这也是我这次的需求）
&amp;lt;label&amp;gt;页面地址&amp;lt;/label&amp;gt; &amp;lt;input type=&#39;text&#39; placeholder=&amp;quot;请输入页面地址&amp;quot;/&amp;gt; label::before { content: &#39;*&#39;; color: red; }  效果：伪元素并不多：
1. ::before
2. ::after</description>
    </item>
    
    <item>
      <title>React组件中的函数this绑定</title>
      <link>https://hueralin.github.io/2019/bind/</link>
      <pubDate>Tue, 20 Aug 2019 11:04:35 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/bind/</guid>
      <description>实习项目遇到的问题 关于函数this绑定！ 最近在React项目中遇到了关于函数this绑定的问题，因为在普通函数（诸如:function(){xxx}）中，this的绑定是动态的，在被执行时才会确定。若这些普通函数在自身组件内使用一般不会有太大的问题，然而一旦被当作参数（例如事件处理函数）传递到其他组件时，this就会绑定为其他组件的实例，在获取原实例的状态时就会发生错误。
箭头函数的this绑定和普通函数不一样，它是静态绑定的，也就是说箭头函数的this绑定是在定义时绑定的，即定义箭头函数时所处的作用域的this。所以说如果React组件中的函数是用箭头函数的形式定义的话，就不用担心this绑定的问题。
假如你的onClick事件处理函数在被触发时需要传参，如果直接 onClick={this.handleClick(xxx)} 话，onClick得到的就不是函数，而是函数返回的结果，所以应使用 onClick={() =&amp;gt; this.handleClick(xxx)} ，即给onClick一个箭头函数作为事件处理函数，那么this就绑定为了当前组件的实例，调用的普通函数也不用做特殊的处理。
我犯了一个最基础也最致命的问题，在渲染中进行了状态的改变！按理说我不应该会犯这种错误，我犯这种错误的原因就是我将箭头函数和普通函数结合使用（模仿的项目中的老代码）：
handleInput(key) { return (e) =&amp;gt; { let inputValue = {} inputValue[key] = e.target.value this.setState({ data: Object.assign({}, this.state.data, inputValue) }) } } onChange={this.handleInput(xxx)}  看出和之前 onClick={() =&amp;gt; this.handleClick(xxx)} 的不同了么？
这里是由普通函数将箭头函数return了出来，所以函数渲染时立即执行handleInput，并将执行后的箭头函数传给onChange，顺便完成this绑定，Emmmm，秀啊！可惜当初我没搞懂这个用意，将handleInput彻底改成了普通函数，导致在渲染时执行了this.setState()，浏览器不停的改变状态和渲染，瞬间报错0～20000+，不得不强制杀死浏览器进程&amp;hellip;&amp;hellip;
总结React组件中的函数this绑定的几种方法 一、每当作为事件处理函数时，例如：onClick onChange 等，都手动绑定一次
// 这种方法的好处是在绑定this的同时能传递参数 onClick={this.handleClick.bind(this, args)} // 缺点是，每次都得手动调用bind()  二、在构造函数中绑定一次，一劳永逸
// 缺点是不能传递参数 this.handleCLick = this.handleClick.bind(this)  三、React组件的函数直接定义成箭头函数
handleClick = (args) =&amp;gt; {xxxxx} // 缺点也是不能传递参数   上述三个做法有个矛盾，就是“一次绑定”和“传递参数”不能兼顾</description>
    </item>
    
    <item>
      <title>Array</title>
      <link>https://hueralin.github.io/2019/array/</link>
      <pubDate>Mon, 19 Aug 2019 15:46:37 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/array/</guid>
      <description>Array Emmmm, Array的函数不少，至少我觉的是这样。随着ES的发展，Array多了许多奇奇怪怪的函数。
虽说奇怪&amp;hellip;.但用起来超爽的啊！！！！
什么？想要查找数组中的某个元素？ Array.find() 拿走不送！（ES6）
该函数接受两个参数：callback、thisObj
在回调函数中return符合查找条件的元素，若查找成功则直接返回该元素的值，否则返回undefined，并且不会改变原素组，简直不要太爽！
如果想要查找某个元素的索引的话，可以使用 Array.findIndex() 函数，找不到的话返回-1。
增删元素类（改变原数组）  push() 在后面插入
 unshift() 在前面插入
 pop() 在后面弹出 shift() 在前面弹出  元素查找类  find(callback) 通过callback的逻辑，查找满足条件的元素，返回“值”
 findIndex(callback) 通过callback的逻辑，查找满足条件的元素，返回“索引“ includes(item) 查找是否有item，返回布尔值
 indexOf(item) 查找是否有item，返回下标
  数组遍历类 &amp;mdash; forEach() &amp;mdash;
let a = [1,2,3,4,5] a.forEach((item, index, arr) =&amp;gt; { console.log(item) // 1,2,3,4,5 }) /* forEach 遍历的范围在第一次调用 callback 前就会确定,所以后续调用中 添加 和 删除 的item都不会被遍历到 */ a.forEach((item, index, arr) =&amp;gt; { arr.</description>
    </item>
    
    <item>
      <title>后台管理系统</title>
      <link>https://hueralin.github.io/2019/athene/</link>
      <pubDate>Wed, 07 Aug 2019 10:49:37 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/athene/</guid>
      <description>这是实习期一个后台管理的项目 目前正在熟悉该项目，边熟悉，边做一些记录
先来看一下大体的框架：
顶层容器
在container目录下的index.js文件中，有一个IndexContainer组件，该组件中的render函数是这么写的
render () { let { permission } = this.props return ( &amp;lt;div&amp;gt; &amp;lt;Header params={this.props.params} username={permission.username} /&amp;gt; &amp;lt;div className=&#39;main-content&#39;&amp;gt; &amp;lt;SideNav routes={this.props.routes} permissions={permission.permission} /&amp;gt; &amp;lt;div&amp;gt; {this.props.children} &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ) }  可以看出该系统采用了非常常见的布局，即‘顶部导航+左侧导航+右侧内容’
路由配置
因为路由比较多，所有路由配置分为两个路由文件：
外层路由文件
// 这里引入了内层路由文件 import routers from &#39;./routers&#39; module.exports = ( &amp;lt;Router history={browserHistory}&amp;gt; &amp;lt;Route path=&#39;/&#39; /&amp;gt; &amp;lt;Route path=&#39;/xxx&#39; component={xxx} /&amp;gt; &amp;lt;Route path=&#39;/xx/xx&#39; component={xx} /&amp;gt; ...... &amp;lt;Route path=&#39;&#39; component={Container} onEnter={handleEnterSystem}&amp;gt; {/* 嵌套路由，内层路由文件里的Route渲染的组件都是Container容器下的子组件，在this.props.children处渲染*/} { routers } &amp;lt;/Route&amp;gt; &amp;lt;Redirect from=&#39;*&#39; to=&#39;/error/404.</description>
    </item>
    
    <item>
      <title>ES2016/2017新特性</title>
      <link>https://hueralin.github.io/2019/es20162017etc/</link>
      <pubDate>Tue, 06 Aug 2019 11:56:42 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/es20162017etc/</guid>
      <description>ES2016(ES7) Array.prototype.includes(value): 判断一个元素是否在数组中
let a = [1,2,3,4,5,6] a.includes(4) // true a.includes(7) // false // 功能类似于 xxx.indexOf(y) &amp;gt; -1, 但有不同 // includes可以检测Nan (indexO不可以) [NaN].includes(NaN) // true // 不区分 -0 +0 （indexOf也可以） [-0].includes(+0) // true  求幂运算
let a = 3 a ** 2 // 9 // 相当于 Math.pow(a, 2)  ES2017(ES8) String.prototype.padStart / String.prototype.padEnd（字符串填充）
功能：返回指定长度的填充后的字符串 语法：str.padStart(len [, padStr]) // len 指定长度 padStr 填充字符串 let str = &#39;huer&#39; // 1. 指定长度小于原字符串长度，则返回原字符串 str.</description>
    </item>
    
    <item>
      <title>React_router配置</title>
      <link>https://hueralin.github.io/2019/react_router/</link>
      <pubDate>Mon, 05 Aug 2019 14:24:46 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/react_router/</guid>
      <description>最近在学习React-router遇到了一些问题，在此记录一下：
目前成功的配置为：
app.jsx
import React from &#39;react&#39; import ReactDOM from &#39;react-dom&#39; import { HashRouter as Router, Route } from &#39;react-router-dom&#39; import Content from &#39;./components/Content.jsx&#39; import About from &#39;./components/About.jsx&#39; import Posts from &#39;./components/Posts.jsx&#39; import Post from &#39;./components/Post.jsx&#39; ReactDOM.render( &amp;lt;Router&amp;gt; &amp;lt;Content&amp;gt; &amp;lt;Route path=&#39;/about&#39; component={About}&amp;gt;&amp;lt;/Route&amp;gt; &amp;lt;Route path=&#39;/posts&#39; component={Posts}&amp;gt;&amp;lt;/Route&amp;gt; &amp;lt;Route path=&#39;/posts/:id&#39; component={Post}&amp;gt;&amp;lt;/Route&amp;gt; &amp;lt;/Content&amp;gt; &amp;lt;/Router&amp;gt;, document.getElementById(&#39;app&#39;) )  Content.jsx
import React from &#39;react&#39; import { Link } from &#39;react-router-dom&#39; class Content extends React.Component { render () { return &amp;lt;div&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;Link to=&#39;/&#39;&amp;gt;主页&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;Link to=&#39;/posts&#39;&amp;gt;博文&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;Link to=&#39;/about&#39;&amp;gt;关于&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; {this.</description>
    </item>
    
    <item>
      <title>敏捷开发</title>
      <link>https://hueralin.github.io/2019/mjkf/</link>
      <pubDate>Thu, 01 Aug 2019 17:10:22 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/mjkf/</guid>
      <description>敏捷宣言
12条原则
Scrum
XP(极限编程)
1. 结对编程
2. 测试驱动开发：单元测试，重构
3. 持续集成
4. 代码集体所有（统一规范，任何人写的代码，任何人都能维护）
5. 现场客户
精益思维
1. 消除浪费
2. 增强学习
3. 尽量延迟决定
4. 尽快发布
5. 下放权力
6. 嵌入质量
7. 全局优化
FDD-特性驱动开发
看板（白板）
MoSCoW
估算
估算纸牌（数字高代表能力强，数字代表和参照物相比该任务的复杂度，每个人对同一个任务的估算是不同的）
技术债务
迭代开发 增量交付 自组织团队 高价值的优先级排序</description>
    </item>
    
    <item>
      <title>Webpack4 配置文件解析</title>
      <link>https://hueralin.github.io/2019/webpack4/</link>
      <pubDate>Mon, 29 Jul 2019 18:54:31 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/webpack4/</guid>
      <description>let path = require(&#39;path&#39;) // 创建HTML模板的插件 let HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;) // 抽离CSS样式为单独文件的插件（原来都是将CSS样式全部放进了style里面） let MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;) // 优化CSS的插件（压缩CSS文件） let OptimizeCss = require(&#39;optimize-css-assets-webpack-plugin&#39;) // 用了上面优化CSS的插件，就得使用下面这个插件来优化JS（压缩JS文件） let UglifyJsWebpackPlugin = require(&#39;uglifyjs-webpack-plugin&#39;) module.exports = { // 优化CSS和JS // 优化项 optimization: { // 压缩 minimizer: [ new UglifyJsWebpackPlugin({ cache: true, // 缓存 parallel: true, // 并发压缩 sourceMap: true // }), new OptimizeCss() ] }, // 模式：开发和生产模式两种 mode: &#39;development&#39;, entry: &#39;./src/index.js&#39;, output: { // path 必须是绝对路径 // path.</description>
    </item>
    
    <item>
      <title>汉服那么美，为何现在流行不起来</title>
      <link>https://hueralin.github.io/2019/hjjh-02/</link>
      <pubDate>Sun, 28 Jul 2019 12:27:50 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/hjjh-02/</guid>
      <description>出行不便（生活节奏）
 价格昂贵（手工刺绣，配饰）
 身材和气质（汉服对这两点要求有点高）
 普及范围狭窄（汉服知识？恐怕得考古好久）
  服装和文化一样，要与时俱进。要想发扬汉服文化，让汉服流行起来，不能一味的追求历史（此言不当，不知如何表述），应该结合当下的形式，做出一些改进，这算不上“取其精华，去其糟粕”，古代的穿衣礼节，穿衣过程确有其繁琐的地方，放到现代来确实让人难以接受，这也是汉服流行不起来的原因之一。我们不能一味的遵从汉服文化而渐渐变得复古，这也是不可能的。最近在相关贴吧上看到过这样一个帖子，有个小姐姐晒出汉服写真却被一群大叔嘲讽，不懂汉服历史，穿着不伦不类，不认同这是汉服，戏称为“花衣服”。大叔们有这种想法也无可厚非，毕竟现在的穿汉服的人多多少少也搭配着一些现代的服饰，比如手表、小白鞋，还有大叔们嘲讽的丝袜，小姐姐面对嘲讽也是欲哭无泪&amp;hellip;
小姐姐错了么？大叔们错了么？
在我看来，此事无关对错。现在的年轻人穿汉服无非两个原因，其一是服饰着实好看，其二是想为发扬中国传统文化献上一份力量。曾经抖音上的一个短视频对我产生了一丝丝触动，一个女孩儿边哭变向床上扔着一件件汉服，边扔边说“我穿汉服上街怎么了？我喜欢汉服，这有错么，碍着你们了？一个个用异样的眼光看我，甚至还嘲讽我穿着奇装异服”，“在日本韩国，这在他们看来是很正常不过的事情，为什么在国内穿传统服装却被看作异类”（Emmm，原话忘了，大体这个意思吧）这段话引起了我的思考
至于思考了啥？晚上回去再说，学习！😂
to be continue&amp;hellip;</description>
    </item>
    
    <item>
      <title>汉家江湖-起源</title>
      <link>https://hueralin.github.io/2019/hjjh-01/</link>
      <pubDate>Sun, 28 Jul 2019 12:22:08 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/hjjh-01/</guid>
      <description>不知何时起，对汉服有了兴趣～
能做什么？ 1. 维护一个像B站二次元的网站（搞活动） 2. 汉服实体店 3. 联动武侠IP，电影？动漫？ 4. 侠客栈（民宿） 5. IP手办？</description>
    </item>
    
    <item>
      <title>实习项目的Header结构解析</title>
      <link>https://hueralin.github.io/2019/zkheader/</link>
      <pubDate>Sun, 28 Jul 2019 00:07:10 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/zkheader/</guid>
      <description>最近在做公司的项目，更改移动端Header的现有布局。
Header是React组件，点击按钮出现侧边栏导航。
下面简单来介绍一下Header的结构：
Header接受了3个props，分别是“userInfo”、“changeNavState”、“style”。
userInfo是用户信息，changeNavState是用来更改侧边导航状态的函数，style是一个类样式。
以上几个props都交由PropTypes来验证参数的合法性。
该Header组件内仅维护了一个状态，那就是 subNav，即侧边导航栏的显示与否，changeNavState函数改变的就是它。
在render渲染函数中：
const { userInfo, style } = this.props
根据是否有userInfo.avatar属性来初始化headUrl变量（有则赋值为用户头像URL，无则赋值为默认头像URL）
接下来return一个JSX，
首先判断subNav是否为真，真则显示侧边导航。
然后是左右布局，左边是点击显示侧边导航的下拉按钮和点击能返回主页的LOGO，右边是用户头像。
左边的导航按钮添加点击事件（调用changeNavState函数），通过控制subNav状态来显示和隐藏侧边导航。
右边判断userInfo.id属性，有则根据headeUrl显示用户头像，否则显示默认头像。默认头像图标添加点击跳转登录事件。
其中userInfo属性是由connect函数连接的， userInfo来自于Redux的State。</description>
    </item>
    
    <item>
      <title>Mac使用技巧</title>
      <link>https://hueralin.github.io/2019/mactips/</link>
      <pubDate>Sat, 27 Jul 2019 17:21:45 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/mactips/</guid>
      <description>VSCODE使用命令行打开目录
&amp;gt;相关知识：环境变量的设置
环境变量的分类：系统级和用户级
系统级：对所有用户生效的永久性变量（/etc/profile）
用户级：对单一用户生效的永久性变量（～/.bash_profile）
 查看单个环境变量echo $PATH
 查看所有环境变量env
 修改环境变量PATH=&amp;quot;xxxx&amp;quot; 查看所有本地定义的shell变量set
 删除变量unset VNAME
 设置只读变量readonly VNAME  使用export指令添加环境变量：
vim ~/.bash_profile
输入 export JAVA_HOME=/usr/java/jdk
输入 export PATH=$JAVA_HOME/bin:$PATH
添加完成后新的环境变量不会立即生效，调用source ~/.bash_profile 该文件才会生效
使用export命令添加临时环境变量：
命令行下输入 export MALIN=&#39;malin&#39;
使用code命令用VSCODE打开目录：
1. 在VSCODE中 command+shift+P -&amp;gt; 输入shell command -&amp;gt; 点击提示Shell Command: Install ‘code’ command in PATH运行
2. 在终端中使用 code 目录路径 打开目录（vscode）</description>
    </item>
    
    <item>
      <title>HOC---高阶组件</title>
      <link>https://hueralin.github.io/2019/hoc/</link>
      <pubDate>Sat, 27 Jul 2019 12:37:17 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/hoc/</guid>
      <description>推荐文章：助你完全理解React高阶组件（Higher-Order Components）
简单讲，高阶组件就是一个函数，以组件为参数，返回另一个组件。
高阶组件的目的就是为了复用，可能有很多人不理解，“组件不就是用来复用的么，为什么还要出来一个高阶组件呢？”。
举个例子，有这么一个需求：</description>
    </item>
    
    <item>
      <title>Git Reset</title>
      <link>https://hueralin.github.io/2019/gitreset/</link>
      <pubDate>Fri, 26 Jul 2019 17:41:51 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitreset/</guid>
      <description>背景：
惊了！本来想撤销上一次commit，但保留工作区的修改，但是手残加了 &amp;ndash;hard 参数，修改全没了！！！
后来，运行了一遍 git reflog branchName , 查看了下该分支上的历史记录，找到reset操作之前的历史，执行 git reset --hard reset之前的记录点 回来了！！！
 参考文章
三棵树    树 用途     HEAD引用 上一次提交的快照，下一次提交的父结点   索引文件 预期的下一次提交的快照   work directory 工作目录    HEAD HEAD是当前分支引用的指针，指向当前分支的最后一次提交。是上一次提交的快照。不过我在其他文章里看到说这棵树应该是“提交记录”。Emmmm，也可以，提交记录就可看成是一个链表，HAED一直都是头指针，每个分支都有各自的提交记录。
INDEX 索引即暂存索引树，预期的下一次提交，是Git的暂存区（一个文件被git add后就给暂存索引树添加一条）
工作目录 工作目录就是实际的工作区，就是你敲代码的地方。上面两个都是放在了 .git 目录中，不太直观。在添加到暂存区和提交之前，你可以在工作目录里随意修改，可看成沙盒。
版本控制的工作流程 首先，进入一个只有一个file.txt文件的目录。执行 git init，初始化一个仓库。此时HEAD指向master分支，但是master分支还未创建。工作目录中只有一个file.txt文件。 执行 git add file.txt，将其纳入版本控制，即将该文件添加进了暂存区（索引）中。 接着执行 git commit，它会从暂存索引中取出内容，并将其保存为一个永久的快照，然后创建一个指向该快照的提交对象，该提交对象保存在提交记录树中，然后更新master指向该提交对象。此时如果我们执行 git status，会发现什么也没有，因为此时这三棵树的状态相同。 然后我们修改file.txt。 修改完后执行 git status，会发现提示“Changes not staged for commit”，因为此时暂存索引树的状态和工作目录不一样了。然后我们再调用 git add，将修改后的文件添加进暂存索引中。 再执行 git status，发现提示“Changes to be committed”，因为此时暂存索引树的状态和提交记录树不一样了（即现在预期的下一次提交与上一次提交不同），最后执行 git commit完成提交。 再执行 git commit，发现什么也没有，因为此时三棵树又都一样了。</description>
    </item>
    
    <item>
      <title>Git分支</title>
      <link>https://hueralin.github.io/2019/gitbranch/</link>
      <pubDate>Fri, 26 Jul 2019 16:45:41 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitbranch/</guid>
      <description>分支就是一个指向单个commit的指针
分支基本操作：
1. 分支改名：git branch -m oldName newName
2. 删除分支：git branch -d feature
3. 从master签出feature：git checkout -b feature master
4. 查看本地分支：git branch
5. 查看远程分支：git branch -r
6. 查看所有分支：git branch -a
7. 合并分支：git merge B 要想将B分支合并到A分支，首先要切换回A分支，在执行merge命令</description>
    </item>
    
    <item>
      <title>Zhike</title>
      <link>https://hueralin.github.io/2019/zhike/</link>
      <pubDate>Fri, 26 Jul 2019 15:48:33 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/zhike/</guid>
      <description>线上分支：production
测试分支：master（www.dev.xxxxxx）
迭代分支：release-3.xxx
在一个迭代开始后，各种开发新特性，修复BUG，当这些工作做完时，需要将所有的改动都合并到release分支上，
作为一次迭代，再合并到master分支（dev）进行测试，测试没问题后再合并到production分支上，发布（上线）。</description>
    </item>
    
    <item>
      <title>Git pull 的使用</title>
      <link>https://hueralin.github.io/2019/gitpull/</link>
      <pubDate>Tue, 23 Jul 2019 14:37:19 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitpull/</guid>
      <description>语法：git pull &amp;lt;选项&amp;gt; &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;
 注意：和git push的语法顺序稍有不同
git push 的语法为：git pull &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt;
git pull 意为从远程分支的最新版本拉取下来并于本地分支合并
 git pull origin master:dev 将origin的master分支拉取并合并到本地的dev分支
 git pull origin master 省略了本地分支名，即拉取并合并到本地分支
 git pull origin 若有 某远程分支与当前分支有追踪关系，则远程分支名也可以省略
 git pull 若只有一个远程主机，且只有一个远程分支与当前分支有追踪关系，则可以直接git pull
  git pull相当于git fetch和git merge的简写
比如：git pull origin dev 相当于 git fetch origin dev + git merge origin/dev
未完待续&amp;hellip;</description>
    </item>
    
    <item>
      <title>Fork工作流</title>
      <link>https://hueralin.github.io/2019/fork/</link>
      <pubDate>Tue, 23 Jul 2019 10:34:46 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/fork/</guid>
      <description>Fork工作流 实现协同开发
作为实习新人，在参与公司项目的开发时被要求使用Fork工作流，Fork工作流实际上就是从GitHub上fork一个原仓库，并与原仓库代码保持同步的一种工作方式。
Fork工作流不再是只有一个中央代码库，而是给予每个人一个远程仓库（origin），外加一个唯一的中央仓库（upstream，或称为官方仓库）。点击Fork时就会生成一个自己的远程仓库，每次开发者提交时都会先将自己的贡献提交到origin，然后发起一个Pull Request请求给中央仓库，中央仓库的管理者会决定是否将你的代码提交到中央仓库，其他人都没这个权限。这使得管理者可以接受任何人的提交，而不需要给它们中央仓库的权限。
具体流程
1. 从原仓库fork到自己的origin
2. git clone xxxxxx 将origin克隆到本地
3. git remote add upstream xxxxx 指向上游仓库，即原仓库
4. git checkout -b feature-xx origin/dev 从远程分支检出本地分支进行开发
5. 开发、修改。。。。提交。。。
6. git push origin feature-xx 将本地feature分支push到origin
7. 发起Pull Request请求管理员合并
8. 上述合并可能会导致冲突，因为本地仓库可能比较旧了，需要更新
9. git checkout dev 切回dev分支
10. git pull upstream dev 从原仓库拉取dev分支的最新版本,更新本地的dev分支
11. git checkout -b feature-merge-dev dev 从更新后的本地dev检出合并分支，并切换为该分支
12. git merge feature-xx 合并你的修改，即feature-xx分支上的内容
13. git branch -m feature-merge-dev feature-xx 将合并分支改名为feature-xx 覆盖原分支</description>
    </item>
    
    <item>
      <title>Git push 的使用</title>
      <link>https://hueralin.github.io/2019/gitpush/</link>
      <pubDate>Mon, 22 Jul 2019 14:32:37 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitpush/</guid>
      <description>语法：git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt; ：&amp;lt;远程分支名&amp;gt;
  git push origin master
最常用的一个写法，忽略了远程分支名，将本地master分支推送到origin中与之有追踪关系的对应分支（通常同名），若没有则创建一个对应的远程分支。
 git push origin :master
忽略了本地分支名，意味着要推送一个本地的空分支到指定远程分支，即删除指定的远程分支，相当于git push origin --delete master
 git push origin
如果当前分支和远程分支存在对应关系，则两个分支名都可省略掉，直接推送当前分支到对应的远程分支。
 git push
如果只有一个远程主机，且只有一个与当前分支对应的远程分支，那么就可以全都省略，直接git push。
 git push -u origin master
如果对应多个远程主机，-u 则指定一个默认主机，以后就可以直接使用git push推送当前分支到远程对应分支。
 git push &amp;ndash;all origin
不管是否存在对应的远程分支，将本地的所有分支全部推上去。
 git push &amp;ndash;force origin
一般情况下本地仓库比远程仓库旧的话会要求你先git pull进行更新，而 &amp;ndash;force 表明不要更新，直接推上去。
 git push origin &amp;ndash;tags
不推送分支，只推送标签。
&amp;mdash;
关于追踪关系
追踪即本地分支跟进远程分支的变化，用于push、pull、merge等&amp;hellip;
追踪远程分支
 git clone 一般克隆下来的项目将自动创建master分支，并且自动关联到远程的master分支上</description>
    </item>
    
    <item>
      <title>用webpack搭建简易的React应用</title>
      <link>https://hueralin.github.io/2019/createreactwithwebpack/</link>
      <pubDate>Sun, 21 Jul 2019 00:19:54 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/createreactwithwebpack/</guid>
      <description>Emmm,步骤清单😂
 npm init -y
 npm i webpack webpack-cli webpack-dev-server --save-dev
 npm i react react-dom --save
 npm i babel-core babel-loader@7 babel-preset-es2015 babel-preset-react --save-dev
需要安装的包差不多就这些了，接下来配置webpack.config.js文件
  module.exports = { entry: &amp;quot;./index.jsx&amp;quot;, output: { path: __dirname + &amp;quot;/public&amp;quot;, filename: &amp;quot;bundle.js&amp;quot; }, module: { rules: [ { test: /\.jsx$/, loader: &amp;quot;babel-loader&amp;quot; } ] }, devServer: { contentBase: &amp;quot;./public&amp;quot; } }   在package.json文件中添加脚本
5.1. &amp;quot;build&amp;quot;: &amp;quot;webpack&amp;quot;打包
5.2. &amp;quot;dev&amp;quot;: &amp;quot;webpack-dev-server --open --inline&amp;quot;启动测试服务器</description>
    </item>
    
    <item>
      <title>搭个窝，储点儿粮，准备过冬！</title>
      <link>https://hueralin.github.io/2019/life20190720/</link>
      <pubDate>Sat, 20 Jul 2019 23:28:34 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/life20190720/</guid>
      <description>今天总算把我的小窝搭建起来了，hugo + github pages 还真不错，感谢该hugo主题的作者，UI很好看。 为什么要放在GiHub上而不是自己前后端+服务器啥的一通瞎搞呢？记得有人说过，刚开始做博客的时候大包大揽，前后端都自己做，确实考验技术也很有成就感，或许也是一时兴起，刚接触博客，饶有趣味，可后来操心太多，可能还会修复bug，还不时续费维护，那时才想起来，”我就是要发篇博客嘛，那么麻烦干什么，都不能专心写作了“，于是github静态博客成了首选（毕竟CSDN、博客园、简书啥的不能定制），通过简单的Markdown语法+GitHub基础就可以发布一篇博客了，岂不美哉～ 可以在该博客上发发技术文章，也可以记录学习和生活，简简单单，专心写作。今天也算是里程碑的一天吧，有此博客就像在北京有了一套房（哈哈哈😂，有些夸张～），实习的日子，加油！</description>
    </item>
    
  </channel>
</rss>