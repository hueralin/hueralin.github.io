<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>狐耳的雪原 on 狐耳的雪原</title>
    <link>https://hueralin.github.io/</link>
    <description>Recent content in 狐耳的雪原 on 狐耳的雪原</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 07 Oct 2019 11:30:54 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LearnGitWithBitbucketCloud(3-4-4)-Git Reset</title>
      <link>https://hueralin.github.io/2019/gitreset-translation/</link>
      <pubDate>Mon, 07 Oct 2019 11:30:54 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitreset-translation/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;[假面包屑导航]&lt;/strong&gt; &lt;a href=&#34;https://www.atlassian.com/git/tutorials&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Git tutorials&lt;/a&gt; / &lt;a href=&#34;https://www.atlassian.com/git/tutorials/setting-up-a-repository&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Getting Started&lt;/a&gt; / &lt;a href=&#34;https://www.atlassian.com/git/tutorials/undoing-changes&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;UndoingChanges&lt;/a&gt; / git-reset&lt;/p&gt;

&lt;p&gt;“这是一篇译文”，本人水平有限，若有错误请&lt;a href=&#34;https://www.atlassian.com/git/tutorials/undoing-changes/git-reset&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考原文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The git reset command is a complex and versatile tool for undoing changes. It has three primary forms of invocation. These forms correspond to command line arguments &amp;ndash;soft, &amp;ndash;mixed, &amp;ndash;hard. The three arguments each correspond to Git&amp;rsquo;s three internal state management mechanism&amp;rsquo;s, The Commit Tree (HEAD), The Staging Index, and The Working Directory.&lt;/p&gt;

&lt;p&gt;git reset 命令是用于撤销更改的复杂而又通用的工具。它有三种主要的调用形式，这三种形式分别对应着命令行参数 &amp;ndash;soft, &amp;ndash;mixed, &amp;ndash;hard。这三种参数分别对应着Git的三种内部状态管理机制，The Commit Tree (HEAD), The Staging Index, and The Working Directory。&lt;/p&gt;

&lt;h1 id=&#34;git-reset-three-trees-of-git&#34;&gt;Git Reset &amp;amp; Three Trees of Git&lt;/h1&gt;

&lt;p&gt;To properly understand git reset usage, we must first understand Git&amp;rsquo;s internal state management systems. Sometimes these mechanisms are called Git&amp;rsquo;s &amp;ldquo;three trees&amp;rdquo;. Trees may be a misnomer, as they are not strictly traditional tree data-structures. They are, however, node and pointer-based data structures that Git uses to track a timeline of edits. The best way to demonstrate these mechanisms is to create a changeset in a repository and follow it through the three trees.&lt;/p&gt;

&lt;p&gt;为了更适当的理解 git reset 的用法，我们必须首先了解Git的内部状态管理系统。有时这些机制被称为&lt;strong&gt;Git的三棵树&lt;/strong&gt;，尽管它们不是严格意义上的传统的“树”数据结构。而是Git用来跟踪编辑时间轴的基于结点和指针的数据结构。演示这种机制的最好方法是在仓库中创建一个“改动集合”，然后通过着三棵树来跟踪它。&lt;/p&gt;

&lt;p&gt;To get started we will create a new repository with the commands below:&lt;br /&gt;
首先，我们使用以下的命令行创建一个仓库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ mkdir git_reset_test
$ cd git_reset_test/
$ git init .
Initialized empty Git repository in /git_reset_test/.git/
$ touch reset_lifecycle_file
$ git add reset_lifecycle_file
$ git commit -m&amp;quot;initial commit&amp;quot;
[master (root-commit) d386d86] initial commit
1 file changed, 0 insertions(+), 0 deletions(-)
create mode 100644 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above example code creates a new git repository with a single empty file, reset_lifecycle_file. At this point, the example repository has a single commit (d386d86) from adding reset_lifecycle_file.&lt;/p&gt;

&lt;p&gt;上面的示例代码创建了一个仓库，里面只有一个空文件 reset_lifecycle_file。此时，这个仓库里面只有一个刚刚初始化的提交。&lt;/p&gt;

&lt;h1 id=&#34;the-working-directory&#34;&gt;The working directory&lt;/h1&gt;

&lt;p&gt;The first tree we will examine is &amp;ldquo;The Working Directory&amp;rdquo;. This tree is in sync with the local filesystem and is representative of the immediate changes made to content in files and directories.&lt;/p&gt;

&lt;p&gt;我们将要了解的第一棵树叫做“工作目录”。这棵树和本地文件系统是同步的，并且文件或目录中内容的更改它都能立即显示出来。（说白了就是你本地的工作目录）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ echo &#39;hello git reset&#39; &amp;gt; reset_lifecycle_file  
$ git status  
On branch master  
Changes not staged for commit:  
(use &amp;quot;git add ...&amp;quot; to update what will be committed)  
(use &amp;quot;git checkout -- ...&amp;quot; to discard changes in working directory)  
modified: reset_lifecycle_file // (假装是红色的)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our demo repository, we modify and add some content to the reset_lifecycle_file. Invoking git status shows that Git is aware of the changes to the file. These changes are currently a part of the first tree, &amp;ldquo;The Working Directory&amp;rdquo;. Git status can be used to show changes to the Working Directory. They will be displayed in the red with a &amp;lsquo;modified&amp;rsquo; prefix.&lt;/p&gt;

&lt;p&gt;在我们的示例仓库中，我们修改了 reset_lifecycle_file 文件的内容。调用 git status 命令，可以看到Git已经追踪到了文件的修改。这些修改是当前“工作目录”的一部分。&lt;code&gt;git status&lt;/code&gt; 用来显示工作目录的修改。这些改动将会以红色的‘modified’前缀显示。&lt;/p&gt;

&lt;h1 id=&#34;staging-index&#34;&gt;Staging index&lt;/h1&gt;

&lt;p&gt;Next up is the &amp;lsquo;Staging Index&amp;rsquo; tree. This tree is tracking Working Directory changes, that have been promoted with git add, to be stored in the next commit. This tree is a complex internal caching mechanism. Git generally tries to hide the implementation details of the Staging Index from the user.&lt;/p&gt;

&lt;p&gt;接下来是“暂存索引”树。这棵树是用来追踪工作目录的修改的，且已经调用过 &lt;code&gt;git add&lt;/code&gt;。这棵树是一个复杂的内部缓存机制。Git一般情况下会对用户隐藏暂存索引的实现细节。&lt;/p&gt;

&lt;p&gt;To accurately view the state of the Staging Index we must utilize a lesser known Git command git ls-files. The git ls-files command is essentially a debug utility for inspecting the state of the Staging Index tree.&lt;/p&gt;

&lt;p&gt;为了准确的观察“暂存索引”的状态，我们必须使用一个不常见的Git命令 &lt;code&gt;git ls-files&lt;/code&gt; 。这个命令实际上是一个为了检查“暂存索引”树的状态的调试命令。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;git ls-files -s  
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0 reset_lifecycle_file  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have executed git ls-files with the -s or &amp;ndash;stage option. Without the -s option the git ls-files output is simply a list of file names and paths that are currently part of the index. The -s option displays additional metadata for the files in the Staging Index. This metadata is the staged contents&amp;rsquo; mode bits, object name, and stage number. Here we are interested in the object name, the second value (d7d77c1b04b5edd5acfc85de0b592449e5303770). This is a standard Git object SHA-1 hash. It is a hash of the content of the files. The Commit History stores its own object SHA&amp;rsquo;s for identifying pointers to commits and refs and the Staging Index has its own object SHA&amp;rsquo;s for tracking versions of files in the index.&lt;/p&gt;

&lt;p&gt;接下来，我们执行 git ls-files -s / &amp;ndash;stage。如果没有 -s 选项，那么 git ls-files 只会输出一个简单的包含文件名和路径的文件列表。-s 选项展示了暂存索引树中文件的额外的元数据。这些元数据包括暂存内容的位模式，对象名以及暂存号。这里我们主要看对象名，即列表项的第二个值。这是一个标准的Git对象SHA-1散列。它是文章内容的hash值。提交历史（git log）保存了它自身的对象SHA，用于标识提交和引用的指针，并且暂存索引也有它自己的用来跟踪索引中文件版本的对象SHA。&lt;/p&gt;

&lt;p&gt;Next, we will promote the modified reset_lifecycle_file into the Staging Index.&lt;/p&gt;

&lt;p&gt;接下来，我们将修改后的 reset_lifecycle_file 文件加入到暂存索引中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git add reset_lifecycle_file   
$ git status   
On branch master Changes to be committed:   
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)   
modified: reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have invoked git add reset_lifecycle_file which adds the file to the Staging Index. Invoking git status now shows reset_lifecycle_file in green under &amp;ldquo;Changes to be committed&amp;rdquo;. It is important to note that git status is not a true representation of the Staging Index. The git status command output displays changes between the Commit History and the Staging Index. Let us examine the Staging Index content at this point.&lt;/p&gt;

&lt;p&gt;这里我们调用了 git add reset_lifecycle_file 命令，将文件加入了暂存索引中。在调用 git status 命令，可以看到输出显示 reset_lifecycle_file 文件以绿色标识在“Changes to be committed”下面。注意，git status 并不是暂存索引的真正体现。git status 命令输出显示是 提交历史 和 暂存索引 之间的改动。现在让我们检查一下暂存索引的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git ls-files -s  
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that the object SHA for reset_lifecycle_file has been updated from e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 to d7d77c1b04b5edd5acfc85de0b592449e5303770.&lt;/p&gt;

&lt;p&gt;我们可以看到 reset_lifecycle_file 文件的对象SHA发生了变化。&lt;/p&gt;

&lt;h1 id=&#34;commit-history&#34;&gt;Commit history&lt;/h1&gt;

&lt;p&gt;The final tree is the Commit History. The git commit command adds changes to a permanent snapshot that lives in the Commit History. This snapshot also includes the state of the Staging Index at the time of commit.&lt;/p&gt;

&lt;p&gt;最后一棵树是“提交历史”。git commit 命令将文件的改动添加进一个永久的快照中，这个快照保存在“提交历史”树中。这个快照还包含了提交时暂存索引的状态。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git commit -am&amp;quot;update content of reset_lifecycle_file&amp;quot;
[master dc67808] update content of reset_lifecycle_file
1 file changed, 1 insertion(+)
$ git status
On branch master
nothing to commit, working tree clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have created a new commit with a message of &amp;ldquo;update content of resetlifecyclefile&amp;rdquo;. The changeset has been added to the Commit History. Invoking git status at this point shows that there are no pending changes to any of the trees. Executing git log will display the Commit History. Now that we have followed this changeset through the three trees we can begin to utilize git reset.&lt;/p&gt;

&lt;p&gt;我们创建了一个提交，将之前所做的修改作为一个集合添加进提交历史。调用 git status 命令，可以看到没有需要添加进任何树中的等待中的修改。执行 git log 命令会显示提交历史。既然我们已经通过三棵树跟踪了这个变更集，我们就可以开始使用git reset了。&lt;/p&gt;

&lt;h1 id=&#34;how-it-works&#34;&gt;How it works&lt;/h1&gt;

&lt;p&gt;At a surface level, git reset is similar in behavior to git checkout. Where git checkout solely operates on the HEAD ref pointer, git reset will move the HEAD ref pointer and the current branch ref pointer. To better demonstrate this behavior consider the following example:&lt;/p&gt;

&lt;p&gt;表面上，git reset 在行为上和 git checkout 相似。git checkout 仅仅操作在HEAD的引用指针上，而 git reset 会移动到HEAD的引用指针以及当前分支的引用指针上。为了更好地演示这种行为，我们考虑下下面的例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wac-cdn.atlassian.com/dam/jcr:b02e7b60-742a-449d-921d-53c32410576d/git-sequence-transparent.png?cdnVersion=612&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;git checkout b&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wac-cdn.atlassian.com/dam/jcr:73e231c7-ddee-4f32-94d6-a3e31e835690/git-checkout-transparent.png?cdnVersion=612&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With git checkout, the master ref is still pointing to d. The HEAD ref has been moved, and now points at commit b. The repo is now in a &amp;lsquo;detached HEAD&amp;rsquo; state.&lt;/p&gt;

&lt;p&gt;调用了 git checkout ，master分支的引用仍然指向d。HEAD引用移动了，现在指向了 commit b。仓库现在处于HEAD指向的状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;git reset b&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wac-cdn.atlassian.com/dam/jcr:29e29d3d-dddd-480b-afd9-77169a7b0230/git-reset-transparent.png?cdnVersion=612&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Comparatively, git reset, moves both the HEAD and branch refs to the specified commit.&lt;/p&gt;

&lt;p&gt;相对而言，git reset 将HEAD引用和分支引用都移动到了特定的提交上。&lt;/p&gt;

&lt;p&gt;In addition to updating the commit ref pointers, git reset will modify the state of the three trees. The ref pointer modification always happens and is an update to the third tree, the Commit tree. The command line arguments &amp;ndash;soft, &amp;ndash;mixed, and &amp;ndash;hard direct how to modify the Staging Index, and Working Directory trees.&lt;/p&gt;

&lt;p&gt;除了更新提交引用指针，git reset 还会修改三棵树的状态。引用指针的改变经常会发生，并且是对第三棵树&amp;mdash;“提交树”的更新。命令行参数 &amp;ndash;soft，&amp;ndash;mixed 以及 &amp;ndash;hard 如何修改这三棵树呢。&lt;/p&gt;

&lt;h1 id=&#34;main-options&#34;&gt;Main Options&lt;/h1&gt;

&lt;p&gt;The default invocation of git reset has implicit arguments of &amp;ndash;mixed and HEAD. This means executing git reset is equivalent to executing git reset &amp;ndash;mixed HEAD. In this form HEAD is the specified commit. Instead of HEAD any Git SHA-1 commit hash can be used.&lt;/p&gt;

&lt;p&gt;调用 git reset 默认会有两个隐式的参数 &amp;ndash;mixed 和 HEAD。也就是说执行 git reset 等同于执行 git reset &amp;ndash;mixed HEAD。在这种形式中，HEAD就是一个指定的提交。可以使用任何提交对象的散列值来代替HEAD。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wac-cdn.atlassian.com/dam/jcr:7fb4b5f7-a2cd-4cb7-9a32-456202499922/03%20(8).svg?cdnVersion=612&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;hard&#34;&gt;&amp;ndash;hard&lt;/h1&gt;

&lt;p&gt;This is the most direct, DANGEROUS, and frequently used option. When passed &amp;ndash;hard The Commit History ref pointers are updated to the specified commit. Then, the Staging Index and Working Directory are reset to match that of the specified commit. Any previously pending changes to the Staging Index and the Working Directory gets reset to match the state of the Commit Tree. This means any pending work that was hanging out in the Staging Index and Working Directory will be lost.&lt;/p&gt;

&lt;p&gt;这是一个最直接，&lt;strong&gt;最危险&lt;/strong&gt;，且使用最频繁的一个选项。当使用 &amp;ndash;hard 后，提交历史的引用指针会更新到指定的提交。然后，暂存索引和工作目录也会重置到指定提交的状态。任何先前暂存索引和工作目录中的等待中的修改都会被重置到提交记录树种的指定的状态。也就是说任何暂存索引和工作目录中挂起的工作都会丢失。&lt;/p&gt;

&lt;p&gt;To demonstrate this, let&amp;rsquo;s continue with the three tree example repo we established earlier. First let&amp;rsquo;s make some modifications to the repo. Execute the following commands in the example repo:&lt;/p&gt;

&lt;p&gt;为了演示，我们继续使用之前的仓库。首先我们做些修改，然后执行下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ echo &#39;new file content&#39; &amp;gt; new_file
$ git add new_file
$ echo &#39;changed content&#39; &amp;gt;&amp;gt; reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These commands have created a new file named new_file and added it to the repo. Additionally, the content of reset_lifecycle_file will be modified. With these changes in place let us now examine the state of the repo using git status.&lt;/p&gt;

&lt;p&gt;创建一个新文件，并添加进仓库。然后对 reset_lifecycle_file 文件做一些修改，再执行 git status：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git status
On branch master
Changes to be committed:
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)
new file: new_file
Changes not staged for commit:
(use &amp;quot;git add ...&amp;quot; to update what will be committed)
(use &amp;quot;git checkout -- ...&amp;quot; to discard changes in working directory)
modified: reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that there are now pending changes to the repo. The Staging Index tree has a pending change for the addition of new_file and the Working Directory has a pending change for the modifications to reset_lifecycle_file.&lt;/p&gt;

&lt;p&gt;现在我们能看到仓库中有一些等待中的修改。暂存索引树中等待中的修改是新文件的增加，工作目录书树的等待中的修改是 reset_lifecycle_file 文件的改动。&lt;/p&gt;

&lt;p&gt;Before moving forward let us also examine the state of the Staging Index:&lt;/p&gt;

&lt;p&gt;在使用 git reset 移动之前，我们先来看一下暂存索引：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git ls-files -s
100644 8e66654a5477b1bf4765946147c49509a431f963 0 new_file
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that new_file has been added to the index. We have made updates to reset_lifecycle_file but the Staging Index SHA (d7d77c1b04b5edd5acfc85de0b592449e5303770) remains the same. This is expected behavior because have not used git add to promote these changes to the Staging Index. These changes exist in the Working Directory.&lt;/p&gt;

&lt;p&gt;我们可以看到新文件被添加进了暂存索引。我们对 reset_lifecycle_file 文件做了修改，但是它的暂存索引中的SHA并没有改变。这是意料之中的事，因为我们并没有使用 git add 命令将修改添加进暂存索引。这些修改仍然存在于工作目录中。&lt;/p&gt;

&lt;p&gt;Let us now execute a git reset &amp;ndash;hard and examine the new state of the repository.&lt;/p&gt;

&lt;p&gt;让我们执行下 git reset &amp;ndash;hard 然后看看仓库中当前的状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git reset --hard
HEAD is now at dc67808 update content of reset_lifecycle_file
$ git status
On branch master
nothing to commit, working tree clean
$ git ls-files -s
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have executed a &amp;ldquo;hard reset&amp;rdquo; using the &amp;ndash;hard option. Git displays output indicating that HEAD is pointing to the latest commit dc67808. Next, we check the state of the repo with git status. Git indicates there are no pending changes. We also examine the state of the Staging Index and see that it has been reset to a point before new_file was added. Our modifications to reset_lifecycle_file and the addition of new_file have been destroyed. This data loss cannot be undone, this is critical to take note of.&lt;/p&gt;

&lt;p&gt;现在HEAD指向了最近的一次提交 dc67808。执行 git status，发现Git说此时没有等待中的修改。执行  git ls-files -s ，查看暂存索引树，发现回到了添加新文件之前的状态。我们对新文件的添加和对旧文件的修改都被销毁了。这些数据丢失了，也不能重做，注意这一点很重要。&lt;/p&gt;

&lt;h1 id=&#34;mixed&#34;&gt;&amp;ndash;mixed&lt;/h1&gt;

&lt;p&gt;This is the default operating mode. The ref pointers are updated. The Staging Index is reset to the state of the specified commit. Any changes that have been undone from the Staging Index are moved to the Working Directory. Let us continue.&lt;/p&gt;

&lt;p&gt;&amp;ndash;mixed 是默认选项。引用指针会被更新。暂存索引被重置到指定的提交。从暂存索引中撤消的任何更改都将移动到工作目录。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ echo &#39;new file content&#39; &amp;gt; new_file
$ git add new_file
$ echo &#39;append content&#39; &amp;gt;&amp;gt; reset_lifecycle_file
$ git add reset_lifecycle_file
$ git status
On branch master
Changes to be committed:
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)
new file: new_file
modified: reset_lifecycle_file
$ git ls-files -s
100644 8e66654a5477b1bf4765946147c49509a431f963 0 new_file
100644 7ab362db063f9e9426901092c00a3394b4bec53d 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above we have made some modifications to the repository. Again, we have added a new_file and modified the contents of reset_lifecycle_file. These changes are then applied to the Staging Index with git add. With the repo in this state, we will now execute the reset.&lt;/p&gt;

&lt;p&gt;新文件的增加和旧文件的修改都被执行了 git add ，添加进了暂存索引。然后，我们执行reset：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git reset --mixed
$ git status
On branch master
Changes not staged for commit:
(use &amp;quot;git add ...&amp;quot; to update what will be committed)
(use &amp;quot;git checkout -- ...&amp;quot; to discard changes in working directory)
modified: reset_lifecycle_file
Untracked files:
(use &amp;quot;git add ...&amp;quot; to include in what will be committed)
new_file
no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)
$ git ls-files -s
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have executed a &amp;ldquo;mixed reset&amp;rdquo;. To reiterate, &amp;ndash;mixed is the default mode and the same effect as executing git reset. Examining the output from git status and git ls-files, shows that the Staging Index has been reset to a state where reset_lifecycle_file is the only file in the index. The object SHA for reset_lifecycle_file has been reset to the previous version.&lt;/p&gt;

&lt;p&gt;我们可以看到，&amp;ndash;mixed 和 &amp;ndash;hard 对使用 git ls-files 命令的结果一样，暂存索引中只有reset_lifecycle_file。暂存索引回退到之前的状态。&lt;/p&gt;

&lt;p&gt;The important things to take note of here is that git status shows us that there are modifications to reset_lifecycle_file and there is an untracked file: new_file. This is the explicit &amp;ndash;mixed behavior. The Staging Index has been reset and the pending changes have been moved into the Working Directory. Compare this to the &amp;ndash;hard reset case where the Staging Index was reset and the Working Directory was reset as well, losing these updates.&lt;/p&gt;

&lt;p&gt;需要注意的是，git status 显示，reset_lifecycle_file 被修改了， new_file 未被跟踪。暂存索引被重置，等待中的修改都被放进了工作目录。而 &amp;ndash;hard ，暂存索引和工作目录都被重置了，所做的修改都丢失了。&lt;/p&gt;

&lt;h1 id=&#34;soft&#34;&gt;&amp;ndash;soft&lt;/h1&gt;

&lt;p&gt;When the &amp;ndash;soft argument is passed, the ref pointers are updated and the reset stops there. The Staging Index and the Working Directory are left untouched. This behavior can be hard to clearly demonstrate. Let&amp;rsquo;s continue with our demo repo and prepare it for a soft reset.&lt;/p&gt;

&lt;p&gt;使用 &amp;ndash;soft，引用指针被更新，重置就停止在那里。暂存索引和工作目录保持不变。这个行为不好演示，我们继续使用这个仓库，为 soft reset 做好准备。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git add reset_lifecycle_file   
$ git ls-files -s   
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file   
$ git status   
On branch master   
Changes to be committed:   
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)   
modified: reset_lifecycle_file   
Untracked files:   
(use &amp;quot;git add ...&amp;quot; to include in what will be committed)   
new_file  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have again used git add to promote the modified reset_lifecycle_file into the Staging Index. We confirm that the index has been updated with the git ls-files output. The output from git status now displays the &amp;ldquo;Changes to be committed&amp;rdquo; in green. The new_file from our previous examples is floating around in the Working Directory as an untracked file. Lets quickly execute rm new_file to delete the file as we will not need it for the upcoming examples.&lt;/p&gt;

&lt;p&gt;这里，我们修改了旧文件，并添加进了暂存索引。执行 git status 可以看到旧文件处于待提交状态，新文件处于待暂存状态。让我们快速执行rm new_file来删除文件，因为在接下来的示例中不需要它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git reset --soft
$ git status
On branch master
Changes to be committed:
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)
modified: reset_lifecycle_file
$ git ls-files -s
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have executed a &amp;lsquo;soft reset&amp;rsquo;. Examining the repo state with git status and git ls-files shows that nothing has changed. This is expected behavior. A soft reset will only reset the Commit History. By default, git reset is invoked with HEAD as the target commit. Since our Commit History was already sitting on HEAD and we implicitly reset to HEAD nothing really happened.&lt;/p&gt;

&lt;p&gt;执行完 git reset &amp;ndash;soft 以及 git status 后，显示xxx。soft reset 只会重置提交历史。因为我们的提交历史已经被设置为HEAD了，我们隐式地将其重置为HEAD，所以实际上什么也没有发生。&lt;/p&gt;

&lt;p&gt;To better understand and utilize &amp;ndash;soft we need a target commit that is not HEAD. We have reset_lifecycle_file waiting in the Staging Index. Let&amp;rsquo;s create a new commit.&lt;/p&gt;

&lt;p&gt;为了更好的理解 &amp;ndash;soft 用法，我们需要一个非HEAD的提交记录。暂存索引中 reset_lifecycle_file 文件还在等着被提交，那我们就提交它吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git commit -m&amp;quot;prepend content to reset_lifecycle_file&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, our repo should have three commits. We will be going back in time to the first commit. To do this we will need the first commit&amp;rsquo;s ID. This can be found by viewing output from git log.&lt;/p&gt;

&lt;p&gt;此时，仓库应该有3个提交记录。为了回退到第一个提交记录，我们需要它的提交ID，执行 git log 即可查看。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git log
commit 62e793f6941c7e0d4ad9a1345a175fe8f45cb9df
Author: bitbucket 
Date: Fri Dec 1 15:03:07 2017 -0800
prepend content to reset_lifecycle_file
commit dc67808a6da9f0dec51ed16d3d8823f28e1a72a
Author: bitbucket 
Date: Fri Dec 1 10:21:57 2017 -0800
update content of reset_lifecycle_file
commit 780411da3b47117270c0e3a8d5dcfd11d28d04a4
Author: bitbucket 
Date: Thu Nov 30 16:50:39 2017 -0800
initial commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Keep in mind that Commit History ID&amp;rsquo;s will be unique to each system. This means the commit ID&amp;rsquo;s in this example will be different from what you see on your personal machine. The commit ID we are interested in for this example is 780411da3b47117270c0e3a8d5dcfd11d28d04a4. This is the ID that corresponds to the &amp;ldquo;initial commit&amp;rdquo;. Once we have located this ID we will use it as the target for our soft reset.&lt;/p&gt;

&lt;p&gt;注意，每个系统的提交历史的ID都是独一无二的。我们需要的是第一个提交历史的ID 780411da3b47117270c0e3a8d5dcfd11d28d04a4 ，将用它准备调用 git reset &amp;ndash;soft。&lt;/p&gt;

&lt;p&gt;Before we travel back in time lets first check the current state of the repo.&lt;/p&gt;

&lt;p&gt;回退之前我们先看一下仓库当前的状态。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git status &amp;amp;&amp;amp; git ls-files -s
On branch master
nothing to commit, working tree clean
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始回退&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$git reset --soft 780411da3b47117270c0e3a8d5dcfd11d28d04a4
$ git status &amp;amp;&amp;amp; git ls-files -s
On branch master
Changes to be committed:
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)
modified: reset_lifecycle_file
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above executes a &amp;ldquo;soft reset&amp;rdquo; and also invokes the git status and git ls-files combo command, which outputs the state of the repository. We can examine the repo state output and note some interesting observations. First, git status indicates there are modifications to reset_lifecycle_file and highlights them indicating they are changes staged for the next commit. Second, the git ls-files input indicates that the Staging Index has not changed and retains the SHA 67cc52710639e5da6b515416fd779d0741e3762e we had earlier.&lt;/p&gt;

&lt;p&gt;首先，根据状态输出，我们能够看到对 reset_lifecycle_file 文件的修改仍然存在，仍然在等着被提交。其次，根据暂存索引输出，我们发现 reset_lifecycle_file 的SHA也没有变化。&lt;/p&gt;

&lt;p&gt;To further clarify what has happened in this reset let us examine the git log:&lt;/p&gt;

&lt;p&gt;为了更进一步地解释执行 &amp;ndash;soft 发生了什么，我们执行 git log 查看一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git log
commit 780411da3b47117270c0e3a8d5dcfd11d28d04a4
Author: bitbucket 
Date: Thu Nov 30 16:50:39 2017 -0800
initial commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The log output now shows that there is a single commit in the Commit History. This helps to clearly illustrate what &amp;ndash;soft has done. As with all git reset invocations, the first action reset takes is to reset the commit tree. Our previous examples with &amp;ndash;hard and &amp;ndash;mixed have both been against the HEAD and have not moved the Commit Tree back in time. During a soft reset, this is all that happens.&lt;/p&gt;

&lt;p&gt;日志输出显示了这确实是第一次提交历史。与所有 git reset 调用一样，重置的第一个操作是重置提交树。我们前面的例子 &amp;ndash;hard 和 &amp;ndash;mixed 都是针对HEAD的，没有及时地将提交树向后移动。但是在 &amp;ndash;soft 中，这些都做过了。&lt;/p&gt;

&lt;p&gt;This may then be confusing as to why git status indicates there are modified files. &amp;ndash;soft does not touch the Staging Index, so the updates to our Staging Index followed us back in time through the commit history. This can be confirmed by the output of git ls-files -s showing that the SHA for reset_lifecycle_file is unchanged. As a reminder, git status does not show the state of &amp;lsquo;the three trees&amp;rsquo;, it essentially shows a diff between them. In this case, it is displaying that the Staging Index is ahead of the changes in the Commit History as if we have already staged them.&lt;/p&gt;

&lt;p&gt;为什么 git status 表明存在修改过的文件？这可能会让人感到困惑。因为 &amp;ndash;soft 没有触及暂存索引，因此对暂存索引的更新在提交历史中一直跟随我们。这可以通过git ls-files -s的输出得到确认，其中 reset_lifecycle_file 的SHA没有改变。提醒一下，git status 并不显示“三棵树”的状态，它实际上显示了它们之间的差异。在本例中，它将显示暂存索引先于提交历史记录中的更改，就好像我们已经暂存了它们一样。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>call, apply, bind</title>
      <link>https://hueralin.github.io/2019/callapplybind/</link>
      <pubDate>Sun, 06 Oct 2019 13:27:32 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/callapplybind/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;call apply bind 这三个函数的作用都是将一个函数的this指向另一个对象，使得该对象可以调用这个它自身没有的函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;func-call-thisobj-arg1-arg2&#34;&gt;Func.call(thisObj, [arg1,arg2,&amp;hellip;.])&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;thisObj&lt;/strong&gt; 作为Func内部的this，它的取值有四种情况：&lt;br /&gt;
1. null/undefined/不传 Func的this &amp;mdash;-&amp;gt; window&lt;br /&gt;
2. 函数名 Func的this &amp;mdash;-&amp;gt; 该函数的引用&lt;br /&gt;
3. 数值/字符串/布尔值 Func的this &amp;mdash;-&amp;gt; Number/String/Boolean&lt;br /&gt;
4. 对象 Func的this &amp;mdash;-&amp;gt; 对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Func(){
    console.log(this)
}
function Test(){console.log(&#39;Test&#39;)}
var obj = { name: &#39;huer&#39; }
Func.call() // window
Func.call(null) // window
Func.call(undefined) // window
Func.call(Test) // Test(){console.log(&#39;Test&#39;)}
Func.call(666) // Number {666}
Func.call(&#39;666&#39;) // String {&amp;quot;666&amp;quot;}
Func.call(true) // Boolean {true}
Func.call(obj)  // {name: &amp;quot;huer&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三个函数除了由上面的功能外，还有一个功能。还能给对象添加新属性，例如在继承中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person(name, age) {
    this.name = name;
    this.age = age; 
}
let dog = {}
Person.call(dog, &#39;wangcai&#39;, 5);
console.log(dog);   // {name: &amp;quot;wangcai&amp;quot;, age: 5}
// dog调用了Person构造函数，于是Person函数中的this指向dog，然后给dog添加了两个属性。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;func-apply-thisobj-args&#34;&gt;Func.apply(thisObj, [args[]])&lt;/h3&gt;

&lt;p&gt;功能和call一样，只不过第二个参数是一个参数数组（或伪数组，如arguments），而不是参数列表。&lt;/p&gt;

&lt;h3 id=&#34;func-bind-thisobj-arg1-arg2&#34;&gt;Func.bind(thisObj, [arg1, arg2&amp;hellip;])&lt;/h3&gt;

&lt;p&gt;功能和上面两个一样，只不过该函数并不会立即执行Func，而是返回一个绑定后的函数。它常用于事件绑定中，因为事件绑定要求传入函数引用而不是函数的执行结果，bind的其他参数和call一样，是一个参数列表。&lt;/p&gt;

&lt;p&gt;bind函数返回一个原函数的拷贝，并拥有指定的this值和初始参数。&lt;/p&gt;

&lt;p&gt;bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;bind函数用法1：创建一个绑定函数。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 9;
var module = {
  x: 81,
  getX: function() { return this.x; }
};

module.getX(); // 81

var retrieveX = module.getX;
retrieveX();   
// 返回9 - 因为函数是在全局作用域中调用的

// 创建一个新函数，把 &#39;this&#39; 绑定到 module 对象
var boundGetX = retrieveX.bind(module);
boundGetX(); // 81
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;bind函数用法2：创建一个偏函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 偏函数，即拥有预设参数的函数
// 只要将这些参数（如果有的话）作为bind()的参数写在this后面。
// 当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。

function sum(a, b) {
    return a + b;
}
function toArr() {
    return Array.prototype.slice.call(arguments);
}

let FuncA = sum.bind(null, 666);    // 将666作为第一个参数的预设
console.log(FuncA(10)); // 676
console.log(FuncA(10, 20)); // 676, 第二个参数实际上被作为第三个参数而忽略掉

let FuncB = toArr.bind(null, 6, 7, 8);  // 将6，7，8作为预设参数
console.log(FuncB());   // [6, 7, 8]
console.log(FuncB(9, 10));   // [6, 7, 8, 9, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bind函数用法3-配合settimeout&#34;&gt;bind函数用法3: 配合setTimeout&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// setTimeout实际上是window.setTimeout
// 下面计时器的执行过程是，3秒后，将匿名函数放进事件队列，事件循环到它时执行
// 这个执行和 function A(){xxx} A()一样，即在全局环境下执行匿名函数，里面的this指向window
setTimeout(function() {
    console.log(&#39;this is: &#39;, this)
}, 3000)

// 比如有个绘制函数
let canvas = {
    render: function() {
        this.update();
        this.draw();
    }
    update: function(){xxx}
    draw: function(){xxx}
}

window.setInterval(canvas.render, 1000 / 60)
// 这样的话，render函数里的this很容易指向window，导致报错！

// 所以我们可以显式地将this绑定到canvas
window.setInterval(canvas.render.bind(canvas), 1000);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>setState</title>
      <link>https://hueralin.github.io/2019/state-async/</link>
      <pubDate>Fri, 04 Oct 2019 23:57:30 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/state-async/</guid>
      <description>

&lt;h3 id=&#34;state机制&#34;&gt;State机制&lt;/h3&gt;

&lt;p&gt;setState函数是React管理组件状态的一种方法，修改组件的状态时必须使用该方法，而不能直接在this.state上赋值。但是，如果我们在调用完setState之后直接去访问State时，拿到的是修改前的值。也就是说，setState并不保证“同步执行”。&lt;/p&gt;

&lt;p&gt;如果在一次操作中多次调用setState，那么React会将这几次操作暂存起来，然后统一集中合并，根据合并后的结果去计算新的虚拟DOM，最后执行渲染。　　&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 初始 count = 0
this.setState({ count: this.state.count + 1 })
console.log(this.state.count)       // 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么如果和解决上面的问题呢？&amp;mdash;&amp;ndash;回调函数&lt;/p&gt;

&lt;p&gt;setState函数的参数有两个，第一个参数是对象，第二个参数是回调函数。回调函数在State合并更新完后才会被调用，所以可以拿到更新后的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;this.setState({
    count: this.state.count + 1
}, () =&amp;gt; {
    console.log(this.state.count)   // count = 1
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面来看另一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;this.setState({ count: this.state.count + 1 })
this.setState({ count: this.state.count + 1 })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该会怎么执行呢？结果是2么？不对！结果是1。&lt;br /&gt;
上面提到过，多次调用setState会被合并为一次操作。上面的代码类似于下面这段：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.assign(state, {count: state.count+1}, {count: state.count+1})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;都是操作的count，合并时只执行最后一个。&lt;/p&gt;

&lt;p&gt;那么如何做到增加两次呢？其实setState函数的第一个参数也可以为函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;this.setState((preState, props) =&amp;gt; {count: preState.count + 1})
this.setState((preState, props) =&amp;gt; {count: preState.count + 1})
console.log(this.state.count)   // 仍然是10，但页面渲染的是2

// preState为之前的State，props为State更新执行瞬间的props
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，每次调用都是在上一次state的基础上修改。&lt;/p&gt;

&lt;p&gt;上面代码相当于:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[{increment: 1}, {increment: 1}, {increment: 1}].reduce((preState, props) =&amp;gt; {
    count: preState.count + props.increment
})
// 累加器
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实，React的内部会维护一个State的更新队列，会将当前所有的State修改操作都推入队列中，然后集中合并处理，再调用回调函数，最后计算新的虚拟DOM，执行渲染。&lt;/p&gt;

&lt;h3 id=&#34;setstate真的是异步的么-非也&#34;&gt;setState真的是异步的么？非也！&lt;/h3&gt;

&lt;p&gt;React为了实现跨平台，保证兼容性，内部封装了自己的事件机制，来代替原生事件。React内部会维护一个isBatchingUpdate的标识，来决定是同步修改还是异步修改。在这些合成事件和生命周期函数里执行setState的时候，React将isBatchingUpdate设置为true，即批处理修改，也就是说异步修改。而在原生事和setTimeout函数里面使用setState的时候则是同步修改。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sisterAn/blog/issues/26&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>技术分享之Redux思想</title>
      <link>https://hueralin.github.io/2019/share/</link>
      <pubDate>Wed, 18 Sep 2019 13:40:10 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/share/</guid>
      <description>

&lt;h1 id=&#34;redux&#34;&gt;Redux&lt;/h1&gt;

&lt;h3 id=&#34;普通的状态管理&#34;&gt;普通的状态管理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 状态
let state = {
    // 计数
    count: 0
}···
// 修改状态
state.count = 1
// 获取状态
console.log(state.count)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：状态改变，依赖状态的地方得不到通知&lt;/p&gt;

&lt;h3 id=&#34;带有发布订阅的状态管理&#34;&gt;带有发布订阅的状态管理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 状态
let state = {
    // 计数
    count: 0
}
// 集中管理订阅
let listeners = []
// 订阅函数
function subscribe(callback) {
    listeners.push(callback)
}
// 修改状态的函数
function changState(newVal) {
    state.count = newVal
    for(let i=0;i&amp;lt;listeners.length;i++){
        listeners[i]()
    }
}
// main
subscribe(() =&amp;gt; {
    console.log(&#39;count&#39;, state.count)
})
changState(1)  // 1
changState(2)  // 2
changState(3)  // 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：只对count（即单个状态）有效，应将公共操作封装起来。&lt;/p&gt;

&lt;h3 id=&#34;封装后的版本&#34;&gt;封装后的版本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//  创建store的函数
function createStore(initState) {
    let state = initState || {}
    let listeners = []
    // 订阅函数
    function subscribe(callback) {
        listeners.push(callback)
    }
    // 修改状态的函数
    function changeState(newState) {
        state = newState
        for(let i=0;i&amp;lt;listeners.length;i++){
            listeners[i]()
        }
    }
    //  获取状态
    function getState() {
        return state
    }
    // 返回一个store对象
    return {
        subscribe,
        changeState,
        getState
    }
}
// main
let initState = {
    count: 0,
    user: {
        name: &#39;huer&#39;,
        age: 20,
        sex: &#39;male&#39;
    }
}
let store = createStore(initState)
store.subscribe(() =&amp;gt; {
    let count = store.getState().count
    console.log(`count: ${count}`)
})
store.subscribe(() =&amp;gt; {
    let user = store.getState().user
    console.log(`name: ${user.name}`)
})
store.changeState(Object.assign({}, store.getState(), {count: 1}))
store.changeState(Object.assign({}, store.getState(), {user: &#39;malin&#39;}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：state可以被随便改，没有约束。&lt;/p&gt;

&lt;h3 id=&#34;带计划的状态管理&#34;&gt;带计划的状态管理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//  以计数器为例
/*
    {
        type: &#39;ADD&#39;,
        count: 2
    }
*/
// 计划函数 plan
function plan(state = {}, action) {
    switch(action.type) {
        case &#39;ADD&#39;: return Object.assign({}, state, {count: state.count + 1});break;
        case &#39;SUB&#39;: return Object.assign({}, state, {count: state.count - 1});break;
        default: return state;
    }
}
//  改进封装后的changeState函数
function changeState(action) {
    // 按计划修改状态
    state = plan(state, action)
    for(let i=0;i&amp;lt;listeners.length;i++){
        listeners[i]()
    }
}
// main
// 自增
store.changeState({
  type: &#39;ADD&#39;
})
// 自减
store.changeState({
  type: &#39;SUB&#39;
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过Action，使得状态变化的结果可预测。&lt;/p&gt;

&lt;p&gt;changeState &amp;ndash;&amp;gt; dispatch&lt;br /&gt;
plan &amp;mdash;&amp;gt; Reducer&lt;/p&gt;

&lt;p&gt;Store的角色是整个应用的数据存储中心，集中大部分页面需要的状态数据。&lt;/p&gt;

&lt;p&gt;Redux工作流程：用户通过界面组件 触发Action，携带Store中的旧State与Action 流向Reducer, Reducer返回新的state，并更新界面。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hueralin/Rimage&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Rimage&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zmage.caldis.me/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Zmage&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP流量控制、拥塞控制</title>
      <link>https://hueralin.github.io/2019/tcpys/</link>
      <pubDate>Mon, 09 Sep 2019 12:51:57 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/tcpys/</guid>
      <description>

&lt;p&gt;计算机网络推荐书籍：计算机网络（谢希仁）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/37379780&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;TCP流量控制、拥塞控制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在前端面试中关于计算机网络的知识多半是HTTP协议、TCP/IP协议，拥塞控制之类的。昨天看了几篇关于拥塞控制的文章，现来做一些总结。&lt;/p&gt;

&lt;h2 id=&#34;tcp流量控制&#34;&gt;TCP流量控制&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;一、 流量控制的原因&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;双方在通信时会涉及到通信速率的问题，即发送速率和处理速率，这两个速率往往是不一样的。如果发送方的发送速率太快，接收方来不及处理，就会将报文放进缓存，若发送方仍不控制发送速率，那么缓存终会爆满，导致丢包，浪费网络资源，所以应该对发送方的发送速率进行控制，使发送方和接收方达到一种动态平衡。&lt;/p&gt;

&lt;p&gt;流量控制，即控制发送方的发送速率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、滑动窗口&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;滑动窗口协议：TCP协议中的一种应用，用于网络数据传输中的流量控制。&lt;/p&gt;

&lt;p&gt;该协议允许发送方在停止并等待确认报文前发送多个数据，不必每发完一段数据就定下来等待确认，提高网络的吞吐量，所以TCP定义了一个&lt;strong&gt;滑动窗口协议&lt;/strong&gt;，滑动窗口包括&lt;strong&gt;发送窗口&lt;/strong&gt;和&lt;strong&gt;接受窗口&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关概念&lt;/strong&gt;&lt;br /&gt;
1. 窗口：一段可以被发送者连续发送的字节序列范围。&lt;br /&gt;
2. 滑动：“窗口”的大小会随着发送过程变化，这种变化是在字节序列上按顺序滑动的。&lt;/p&gt;

&lt;p&gt;因为TCP协议是全双工协议，所以双方都有一个&lt;strong&gt;发送缓冲区&lt;/strong&gt;和&lt;strong&gt;接收缓冲区&lt;/strong&gt;。&lt;br /&gt;
发送缓冲区接收来自应用层的数据（一长条字节流？），而发送窗口框住了其中的一部分（前面说了，窗口其实是一段范围）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;发送缓存区&lt;/strong&gt;相关的四个概念：&lt;br /&gt;
1. 已发送并受到确认&lt;br /&gt;
2. 已发送但未收到确认&lt;br /&gt;
3. 允许发送但未发送&lt;br /&gt;
4. 不允许发送&lt;/p&gt;

&lt;p&gt;其中，允许发送的数据都在发送窗口内。每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送。&lt;/p&gt;

&lt;p&gt;下面，我借由计算机网络（谢希仁）中的图片来讲解一下过程(后来发现copy率达到99.9%)：&lt;br /&gt;
A B 双方在建立TCP连接的时候，B就已经向A给出了自己的窗口值，发送方A会根据这个值来构造自己的发送窗口。&lt;br /&gt;
&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp01.png&#34; alt=&#34;根据B给出的窗口值，A构造自己的发送窗口&#34; /&gt;&lt;br /&gt;
发送窗口表示：在没有收到B的确认情况下，A可以连续把发送窗口中的数据都发送出去。凡是发送过的数据在未收到确认前都应留在发送窗口内，以便超时重传。&lt;/p&gt;

&lt;p&gt;发送窗口的位置由前沿和后沿的位置来确定：&lt;br /&gt;
1. 前沿：不动或前移。不动，可能是因为没有收到确认，或收到了确认但接受窗口缩小了。&lt;br /&gt;
2. 后沿：不动或前移。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp02.png&#34; alt=&#34;A发送了11个字节的数据&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A发送了11个字节的数据，但未收到新的确认，所以前沿后沿都不变，即发送窗口的位置不变。&lt;br /&gt;
看B的接收窗口，32 33 未按序到达，因为接收方发送的确认号ack是由按序到达数据的最高序号决定的，所以B返回的确认号仍然是31。导致了A的发送窗口不变。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;描述一个发送窗口的状态&lt;/strong&gt;需要三个指针：p1、p2、p3。&lt;br /&gt;
1. 小于p1：已发送且已收到确认的部分&lt;br /&gt;
2. 大于p3：不允许发送的部分&lt;br /&gt;
3. p3 - p1：发送窗口&lt;br /&gt;
4. p2 - p1：已发送但未收到确认的部分&lt;br /&gt;
5. p3 - p2：允许发送但未发送的部分，又叫“可用窗口”、“有效窗口”&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp03.png&#34; alt=&#34;A收到了新的确认号，发送窗口向前滑动&#34; /&gt;&lt;/p&gt;

&lt;p&gt;B 收到了31，然后返回确认号34，表明31 32 33 都收到了，且已交付主机。A收到确认号后，发送窗口前移，后沿前移3位指向34。指针p2不动，可用窗口变大，可发送42-53的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp04.png&#34; alt=&#34;可用窗口内的数据已全部发送，但未收到确认&#34; /&gt;&lt;br /&gt;
42-53的数据都被发送了出去，p2指针与p3指针重合，但是没有收到确认，使得可用窗口为0，A不能再发送数据，必须等到B的确认。但是B发送的确认可能在网络中延时了，没有及时到达，A就会一直等，B也会一直等待A发送数据，造成死锁。所以A有一个超时计时器机制，一段时间后没有收到B的确认，会自动重传这部分数据并重置超时计时器，直到收到B的确认为止。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、如何控制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;流量控制主要依靠滑动窗口来实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;流量控制即接收方B向发送方A传递消息，使其不要发送太快～，是一种端到端的控制。利用B返回的报文中的接收窗口的大小来控制A的发送窗口大小。rwnd: 接收窗口&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp05.png&#34; alt=&#34;利用可变窗口进行拥塞控制&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图我们也可以看到，发送窗口是连续的一段一段的发送数据，比如上面连续发送了3段数据后才返回了一个ack。&lt;/p&gt;

&lt;p&gt;B的缓存区也会有满的情况，当缓存区满了后会发送rwnd=0通知A停止发送数据。等一段时间后B的缓存区有了空会发送非0的rwnd给A，但是如果这个报文中途丢失了，A一直收不到，双方一直在互相等待，造成死锁。所以TCP引入了持续计时器，即当A收到了0接收窗口通知时，启动该计时器，时间到了就会发送一个1字节的探测报文，接收方会回应自己的接收窗口大小，若仍为0，则重设计时器，继续等待。&lt;/p&gt;

&lt;h2 id=&#34;tcp拥塞控制&#34;&gt;TCP拥塞控制&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp06.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关概念：&lt;/strong&gt;&lt;br /&gt;
1. 慢开始门限：控制使用慢开始算法还是拥塞避免算法&lt;br /&gt;
2. 拥塞窗口&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关算法&lt;/strong&gt;&lt;br /&gt;
1. 慢开始  2. 拥塞避免  3. 快重传  4. 快恢复&lt;/p&gt;

&lt;p&gt;发送方维持一个叫做“拥塞窗口”的状态变量，其大小取决于网络的拥塞程度，且会动态变化。发送方的发送窗口等于拥塞窗口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;发送方控制拥塞窗口的原则&lt;/strong&gt;：当网络没有发生拥塞时，我可以让窗口再增大一些，发出更多的分组。若出现了拥塞，就让拥塞窗口减小一些，缓解拥塞。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网络中出现拥塞的依据&lt;/strong&gt;：分组丢失/超时。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>字节跳动面试题</title>
      <link>https://hueralin.github.io/2019/bytedance/</link>
      <pubDate>Wed, 04 Sep 2019 16:18:24 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/bytedance/</guid>
      <description>

&lt;h3 id=&#34;实现sleep函数-将程序挂起一段时间-阻塞运行&#34;&gt;实现sleep函数（将程序挂起一段时间，阻塞运行）&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;我能想到的方法就是ES6的 async/await
function my_sleep (time) {
    return new Promise((resolve) =&amp;gt; {
        setTimeout(() =&amp;gt; {
            resolve()
        }, time)
    })
}
async function main() {
    console.log(&#39;start&#39;)
    await my_sleep(5000)
    console.log(&#39;end&#39;)
}
main()
网上还有一种解法，利用循环+Date()，不断的循环，检测当前时间是否超出了间隔时间  
原理就是一直在执行同步任务，阻塞下面同步任务的执行
function my_sleep (time) {
    let start = new Date().getTime()    // 一串长数字
    let end = start + time  // time是毫秒
    while(new Date().getTime() &amp;lt;= end){}
}
console.log(&#39;start&#39;)
my_sleep(5000)
console.log(&#39;end&#39;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>用友笔试题</title>
      <link>https://hueralin.github.io/2019/yongyou/</link>
      <pubDate>Wed, 04 Sep 2019 15:07:51 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/yongyou/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;21题&lt;br /&gt;
css 中经常有类似 background-image 这种通过 - 连接的字符，通过 javascript 设置样式的时候需要将这种样式转换成 backgroundImage 驼峰格式，请完成此转换功能。&lt;br /&gt;
输入：-webkit-background-image&lt;br /&gt;
输出：webkitBackgroundImage&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;解法一、  
思路：将输入按照‘-’分开，得到一个数组，例如：[&#39;&#39;, &#39;webkit&#39;, &#39;background&#39;, &#39;image&#39;]  
然后从第三个元素开始，将首字母变大写（注意字符串是不可变的）
function func(pre){
    let splitArr = pre.split(&#39;-&#39;)
    for(let i=2;i&amp;lt;splitArr.length;i++){
        splitArr[i] = splitArr[i][0].toUpperCase() + splitArr[i].slice(1)
    }
    return splitArr.join(&#39;&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;解法二、  
思路：
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;22题&lt;br /&gt;
请实现一个简单的事件机制，能够实现对事件的触发和监听。
如：EventEmitter.on(); EventEmitter.trigger();&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;思路：封装一个对象，该对象有两个方法：on、trigger。on方法接收两个参数，事件名和回调函数，如果一个事件可以绑定过个回调，可以考虑使用数组。trigger方法接受一个参数，即事件名，拿到指定事件，将该事件下的所有回调函数执行一遍。
这种写法只是实现了时间的触发和更新，并没有将事件绑定到某个元素上。
function EventEmitter () {
    let eventObj = {}

    function on (eventName, callback) {
        if (!eventObj[eventName]) {
            eventObj[eventName] = []
        }
        eventObj[eventName].push(callback)
    }

    function trigger (eventName) {
        if (!eventObj[eventName]) {
            return
        }
        for(let i=0;i&amp;lt;eventObj[eventName].length;i++){
            eventObj[eventName][i]()
        }
    }

    return {
        on: on,
        trigger: trigger
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>节流和防抖</title>
      <link>https://hueralin.github.io/2019/debounceandthrottle/</link>
      <pubDate>Tue, 03 Sep 2019 17:43:42 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/debounceandthrottle/</guid>
      <description>

&lt;h3 id=&#34;lodash-防抖源码解读&#34;&gt;lodash 防抖源码解读&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function debounce(func, wait, options) {
  let lastArgs,
    lastThis,
    maxWait,
    result,
    timerId,
    lastCallTime

  let lastInvokeTime = 0
  let leading = false
  let maxing = false
  let trailing = true

  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.
  const useRAF = (!wait &amp;amp;&amp;amp; wait !== 0 &amp;amp;&amp;amp; typeof root.requestAnimationFrame === &#39;function&#39;)

  if (typeof func !== &#39;function&#39;) {
    throw new TypeError(&#39;Expected a function&#39;)
  }
  wait = +wait || 0
  if (isObject(options)) {
    leading = !!options.leading
    maxing = &#39;maxWait&#39; in options
    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait
    trailing = &#39;trailing&#39; in options ? !!options.trailing : trailing
  }

  // 调用函数
  function invokeFunc(time) {
    const args = lastArgs
    const thisArg = lastThis

    lastArgs = lastThis = undefined
    lastInvokeTime = time
    result = func.apply(thisArg, args)
    return result
  }

  function startTimer(pendingFunc, wait) {
    if (useRAF) {
      root.cancelAnimationFrame(timerId)
      return root.requestAnimationFrame(pendingFunc)
    }
    return setTimeout(pendingFunc, wait)
  }

  function cancelTimer(id) {
    if (useRAF) {
      return root.cancelAnimationFrame(id)
    }
    clearTimeout(id)
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time
    // Start the timer for the trailing edge.
    timerId = startTimer(timerExpired, wait)
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result
  }

  function remainingWait(time) {
    const timeSinceLastCall = time - lastCallTime
    const timeSinceLastInvoke = time - lastInvokeTime
    const timeWaiting = wait - timeSinceLastCall

    return maxing
      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting
  }

  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime
    const timeSinceLastInvoke = time - lastInvokeTime

    // Either this is the first call, activity has stopped and we&#39;re at the
    // trailing edge, the system time has gone backwards and we&#39;re treating
    // it as the trailing edge, or we&#39;ve hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall &amp;gt;= wait) ||
      (timeSinceLastCall &amp;lt; 0) || (maxing &amp;amp;&amp;amp; timeSinceLastInvoke &amp;gt;= maxWait))
  }

  function timerExpired() {
    const time = Date.now()
    if (shouldInvoke(time)) {
      return trailingEdge(time)
    }
    // Restart the timer.
    timerId = startTimer(timerExpired, remainingWait(time))
  }

  function trailingEdge(time) {
    timerId = undefined

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing &amp;amp;&amp;amp; lastArgs) {
      return invokeFunc(time)
    }
    lastArgs = lastThis = undefined
    return result
  }

  function cancel() {
    if (timerId !== undefined) {
      cancelTimer(timerId)
    }
    lastInvokeTime = 0
    lastArgs = lastCallTime = lastThis = timerId = undefined
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(Date.now())
  }

  function pending() {
    return timerId !== undefined
  }

  function debounced(...args) {
    const time = Date.now()
    const isInvoking = shouldInvoke(time)

    lastArgs = args
    lastThis = this
    lastCallTime = time

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime)
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = startTimer(timerExpired, wait)
        return invokeFunc(lastCallTime)
      }
    }
    if (timerId === undefined) {
      timerId = startTimer(timerExpired, wait)
    }
    return result
  }
  debounced.cancel = cancel
  debounced.flush = flush
  debounced.pending = pending
  return debounced
}

export default debounce
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JS 事件循环</title>
      <link>https://hueralin.github.io/2019/eventloop/</link>
      <pubDate>Mon, 02 Sep 2019 18:56:56 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/eventloop/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;MDN 事件循环&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://html.spec.whatwg.org/multipage/webappapis.html#event-loops&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;详细的不知道该给这个链接命什么名好!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ahhhhhh, 这JS学的，不断刷新世界观~&lt;/p&gt;

&lt;p&gt;事件循环可谓是JS中的一大重点，如果说之前的&lt;a href=&#34;http://localhost:1313/2019/jsec/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS执行环境&lt;/a&gt;从微观角度上说明了函数内部的执行原理，那么事件循环则从宏观角度上说明了整个JS代码的执行情况。&lt;/p&gt;

&lt;p&gt;事件循环中的关键概念：执行栈、任务源、任务队列&lt;/p&gt;

&lt;h3 id=&#34;执行栈&#34;&gt;执行栈&lt;/h3&gt;

&lt;p&gt;由于JS是单线程的，一定时间内只能执行一个函数，所以这些函数就得按照一定的顺序排好队，但它并不是一个队列，因为函数调用会涉及到作用域链的问题，函数调用之间有着一定的嵌套关系，所以栈结构比较合适。那么由函数调用组成的栈，也被称为 “执行栈” ，函数被调用时压入栈，执行完毕弹出栈。结合 &lt;a href=&#34;http://localhost:1313/2019/jsec/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS执行环境&lt;/a&gt; 中所讲的内容，函数调用栈中的每一个帧都是一个执行环境，执行环境里面包含着变量对象（函数被调用时才会有）。&lt;/p&gt;

&lt;h3 id=&#34;任务源&#34;&gt;任务源&lt;/h3&gt;

&lt;p&gt;这个高大上的名词可能没见过，但是它本身却很常见。顾名思义，任务源就是分发任务的源头，绝大部分是异步任务。分发异步任务的源头有哪些呢？setTimeout ！setInterval ! promise !等等都是任务源，这些函数在被执行的时候都是立即执行的，但是它们所分发的任务需要在特定的情况下才会被执行，而这些特定的环境则需要事件循环机制来处理。任务源所分发的任务才会被放进任务队列中。&lt;/p&gt;

&lt;h3 id=&#34;任务队列&#34;&gt;任务队列&lt;/h3&gt;

&lt;p&gt;MDN 上叫“消息队列”，好像是从前的说法，讲的有些笼统。新标准下给了它们新的名字：任务队列，给异步任务做了更细致的划分。任务队列分为：“宏任务”和“微任务”。
宏任务包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI渲染。微任务包括：process.nextTick，Promise, Object.observe(已废弃), MutationObserver(html5新特性)。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;推荐两篇博客：&lt;br /&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/26229293&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;深入浅出JS事件循环机制（上）&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/26238030&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;深入浅出JS事件循环机制（下）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上面两篇博客涉及到了&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;WebpAPIs&lt;/a&gt;，文中给出了三种常见的WebAPIs，DOM相关、网络相关、定时器相关。&lt;/p&gt;

&lt;p&gt;下面用一个简单的例子来说明：&lt;br /&gt;
 &lt;img src=&#34;https://hueralin.github.io/img/posts/eventloop01.png&#34; alt=&#34;代码执行前&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在开始执行JS代码，main()入栈，执行到console.log()，log函数入栈，执行log函数，控制台输出&amp;rsquo;Hello world!&amp;rsquo;
 &lt;img src=&#34;https://hueralin.github.io/img/posts/eventloop02.png&#34; alt=&#34;main函数入栈，log函数入栈&#34; /&gt;&lt;/p&gt;

&lt;p&gt;log函数出栈，setTimeout函数入栈，执行栈发现setTimeout函数是WebAPIs，于是将setTimeout所分发的任务交由浏览器内核对应的timer模块处理，然后将setTimeout函数出栈。&lt;br /&gt;
 &lt;img src=&#34;https://hueralin.github.io/img/posts/eventloop03.png&#34; alt=&#34;setTimeout函数入栈&#34; /&gt;&lt;/p&gt;

&lt;p&gt;setTimeout函数出栈，console.log(&amp;lsquo;end&amp;rsquo;)入栈，执行完毕后控制台输出&amp;rsquo;end&amp;rsquo;，然后console.log()函数出栈，若timer模块计时结束就将回调函数放进任务队列。&lt;br /&gt;
 &lt;img src=&#34;https://hueralin.github.io/img/posts/eventloop04.png&#34; alt=&#34;console.log(&#39;end&#39;)入栈&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后执行栈中还剩下main()，main函数出栈，此时执行栈为空。开始检查任务队列，队列中有任务，就拿到执行栈中去执行。再依次出栈。&lt;br /&gt;
 &lt;img src=&#34;https://hueralin.github.io/img/posts/eventloop05.png&#34; alt=&#34;匿名回调函数入栈，console.log入栈&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个例子中只使用了setTimeout，是WebAPIs中的一个。其他的WebAPIs例如ajax请求，DOM等都由浏览器内核中不同的模块去处理。结合前面讲的任务源，来自不同任务源的任务会被放进不同的任务队列。即setTimeout分发的任务会进入setTimeout任务队列（因为可能会有多个setTimeout被调用），诸如setTimeout、setInterval等又同属于“宏任务”，而像promise等则属于“微任务”。既然有“宏任务”和“微任务”之分，那么当执行任务队列中的任务时先去哪个呢？下面来讲一下时间循环的具体流程。&lt;/p&gt;

&lt;h3 id=&#34;事件循环的流程&#34;&gt;事件循环的流程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;从script整体代码开始，执行同步任务。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当碰到异步任务时，会将异步任务交由对应的浏览器内核模块去执行，执行完毕后将其回调函数（即事件处理程序）放到对应的任务队列中，等待被执行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;第二步并不会阻塞下面同步代码的执行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当执行栈为空时，就会优先去检查“微任务”，“微任务”中有“process.nexttick任务队列”、“promise队列”等，前者优先级大于后者，拿出队首任务放到执行栈中执行，执行完出栈，继续拿下一个“微任务”，直到所有的“微任务队列”清空。&lt;strong&gt;此时，一轮循环结束！&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;下一轮循环从“宏任务”开始，“宏任务”包括“setTimeout任务队列”、“setInterval任务队列”等，拿出队首的宏任务放进执行栈中执行，执行完出栈。&lt;strong&gt;注意！当一个“宏任务”又创建了一个“微任务”的话，则会将该“宏任务”所在的“宏任务队列”清空后，再转去处理微任务，且微任务被清空后，才会执行下一个“宏任务队列”，也就是说，“微任务”可插队！。&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;事件循环机制会一直检测执行栈、宏任务队列、微任务队列，不断循环执行。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;例题&#34;&gt;例题&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function test() {
    setTimeout(function() {console.log(4)}, 0);
    new Promise(function executor(resolve) {
        console.log(1);
        for( var i=0 ; i&amp;lt;10000 ; i++ ) {
            i == 9999 &amp;amp;&amp;amp; resolve();
        }
        console.log(2);
    }).then(function() {
        console.log(5);
    });
    console.log(3);
})()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有更复杂的例题&lt;a href=&#34;https://www.jianshu.com/p/12b9f73c5a4f&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这波能反杀&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;q-a&#34;&gt;Q&amp;amp;A&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Q：&lt;/strong&gt; setTimeout又分发了一个setTimeout，会在当前循环中执行么？&lt;br /&gt;
&lt;strong&gt;A：&lt;/strong&gt; 不会，宏任务不会插队，新分发的宏任务会等到下一次循环。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(&#39;start&#39;)
setTimeout(() =&amp;gt; {
	console.log(&#39;out&#39;)
  	setTimeout(() =&amp;gt; {
    	console.log(&#39;in&#39;)
    }, 0)       // 最早1s后放进setTimeout队列
}, 1000)        // 最早1s后放进setTimeout队列

new Promise((resolve) =&amp;gt; {
	console.log(&#39;promise&#39;)
  	for(var i = 0;i&amp;lt;100;i++){
    	i == 99 &amp;amp;&amp;amp; resolve()
    }
}).then(() =&amp;gt; {
	console.log(&#39;then&#39;)
})
setInterval(() =&amp;gt; {
	console.log(new Date().toString())
}, 1000)       // 最早1s后放进setInterval队列
console.log(&#39;end&#39;)

/*
start
promise
end
then
out
Tue Sep 03 2019 16:14:57 GMT+0800 (中国标准时间)
in
*/
// 可以看到，setTimeout任务队列清空后执行的是setInterval任务队列，即使中途插入了新的setTimeout也没有被执行，而是老老实实的等下个循环。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在其他博文还看到另一个说法，就是在任务进入执行栈前会判断是同步任务还是异步任务，是异步任务的话，会有一个事件注册表的东西，来给相应的事件注册回调函数。&lt;/p&gt;

&lt;p&gt;回更!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>狐耳的技术栈</title>
      <link>https://hueralin.github.io/2019/stack/</link>
      <pubDate>Mon, 02 Sep 2019 17:08:32 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/stack/</guid>
      <description>

&lt;h3 id=&#34;javascript&#34;&gt;JavaScript&lt;/h3&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://hueralin.github.io/2019/closure/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS闭包&lt;/a&gt;&lt;br /&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://hueralin.github.io/2019/jsec/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS执行环境/AO/VO&lt;/a&gt;&lt;br /&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 事件循环&lt;br /&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; async/await&lt;br /&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;html&#34;&gt;HTML&lt;/h3&gt;

&lt;h3 id=&#34;css&#34;&gt;CSS&lt;/h3&gt;

&lt;h3 id=&#34;性能优化手段&#34;&gt;性能优化手段&lt;/h3&gt;

&lt;h3 id=&#34;webpack&#34;&gt;webpack&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>JS执行环境，作用域链，变量对象/活动对象</title>
      <link>https://hueralin.github.io/2019/jsec/</link>
      <pubDate>Mon, 02 Sep 2019 11:20:42 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/jsec/</guid>
      <description>

&lt;p&gt;JS的重点内容之一，虽然不会在面试题中直接那么问，多半给你出一段代码，看输出什么。&lt;/p&gt;

&lt;p&gt;我觉得了解了这部分内容，能让我们对整个JS的执行流程有个详细、准确地认识，在面对工作中的一些错误也能快速且正确的排错。&lt;/p&gt;

&lt;h3 id=&#34;js执行环境&#34;&gt;JS执行环境&lt;/h3&gt;

&lt;p&gt;JS的执行环境又被称为执行上下文（Execution context），简称EC。顾名思义，JS执行环境就是JS执行时才会存在的环境，常见的执行环境有两种：全局执行环境和函数执行环境。当JS代码执行的时候，我们会进入不同的执行环境，这些执行环境会构成一个执行环境栈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EC的组成&lt;/strong&gt;：&lt;br /&gt;
1. 变量对象（VO）：包含变量的对象，无法被访问&lt;br /&gt;
2. [[scope]]：作用域链，由变量对象构成，该属性是指向作用域链头节点的指针&lt;br /&gt;
3. this指针：指向环境对象（也是一个普通对象），而不是执行环境EC&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EC的创建&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;EC是在调用函数的时候创建的，一个EC的生命周期分为两个阶段：创建阶段 和 执行阶段：&lt;br /&gt;
1. 创建阶段：此时EC创建变量对象，建立作用域链，确定this的指向，&lt;br /&gt;
2. 代码执行阶段：完成变量赋值，其他函数调用等代码的执行&lt;/p&gt;

&lt;p&gt;其中变量对象的创建也是个重点，这里涉及到了&lt;strong&gt;预编译&lt;/strong&gt;的问题：&lt;br /&gt;
&lt;strong&gt;变量对象的创建&lt;/strong&gt;：&lt;br /&gt;
1. 根据函数的参数，建立arguments对象（类数组，将参数值保存在下标中）。&lt;br /&gt;
2. 函数声明提升：扫描所有的函数声明，将函数名作为变量对象的属性名，属性值为函数在内存中的地址，如果属性名存在，则会被覆盖。&lt;br /&gt;
3. 变量声明提升：扫描所有的变量声明，将变量名作为变量对象的属性名，属性值初始化为undefined，如果属性名存在，则会跳过，不覆盖（防止同名的函数被覆盖为undefined，毕竟函数是一等公民嘛～）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：在代码执行阶段的时候，变量才会被赋值，之前一直都是undefined。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由上可知，作用域其实就是一个变量对象。那么什么是变量对象？&lt;/p&gt;

&lt;h3 id=&#34;变量对象-vo&#34;&gt;变量对象（VO）&lt;/h3&gt;

&lt;p&gt;变量对象存储了EC中定义的变量和函数声明，“这个对象是规范上的，或者说是引擎实现上的，不可在JS环境中访问到”。&lt;/p&gt;

&lt;h3 id=&#34;活动对象-ao&#34;&gt;活动对象（AO）&lt;/h3&gt;

&lt;p&gt;“活动对象其实就是变量对象的激活状态” 这是我在大多数博文中找到的介绍，即当执行流进入一个函数时，EC会被创建，变量对象会被创建，变量对象被激活成为活动对象。&lt;/p&gt;

&lt;p&gt;此处有&lt;strong&gt;争议&lt;/strong&gt;：&lt;br /&gt;
1. 根据“函数是被一级一级的调用的”，我是不是可以说这一级一级向下执行的函数的变量对象都是活动对象呢？毕竟这些函数都被执行了。所以说，我觉得 “活动对象” 应该是处于作用域链顶端的变量对象，该变量对象处于最近被执行的EC。&lt;br /&gt;
2. 另一种说法，不是存在一个执行环境栈嘛，当A函数里执行了B函数，那么B函数入栈，A函数可以想象成处于一种 “休眠” 状态，B函数才算真正被执行。所以B函数里的执行环境、变量对象被创建，变量对象被激活为活动对象。（Emmm，好像也有道理。哈！都是我的猜想😂）&lt;/p&gt;

&lt;p&gt;当函数执行完毕，它的执行环境会被销毁，活动对象也会跟着销毁。但这是在一般的情况下，如果是 &lt;strong&gt;&lt;a href=&#34;https://hueralin.github.io/2019/closure/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;闭包&lt;/a&gt;&lt;/strong&gt;，那就得另当别论。假设A函数里返回了B函数，B函数引用着A函数执行环境里的活动对象。当A函数执行完毕后，A函数的环境变量被销毁，但是活动对象依然存在于作用域的顶端。当返回的函数被调用时，会创建自己的执行环境和活动对象（此时应该就有两个活动对象），闭包函数的活动对象里面引用着上一个活动对象，当闭包函数执行完后，两个活动对象都将被销毁。&lt;/p&gt;

&lt;h3 id=&#34;作用域链&#34;&gt;作用域链&lt;/h3&gt;

&lt;p&gt;作用域分为两种：全局作用域 和 局部作用域。&lt;br /&gt;
前面说过，作用域链其实就是变量对象，但并不是一个，而是一串儿😂。我们所说的局部作用域其实就是当前执行环境的变量对象，我们在查找一个变量的时候，如果在当前变量对象里面查不到的话，就会顺着作用域链一级一级的向上查找，直到全局作用域，因此全局作用域处于作用域链的末端。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/36393048&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;最后，推荐一篇知乎上的帖子，上面讨论的很详细。（尤其是那几个图，很直观，我也就不再放图了😂）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(我听见你在说我懒了&amp;hellip;&amp;hellip;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JS闭包</title>
      <link>https://hueralin.github.io/2019/closure/</link>
      <pubDate>Fri, 30 Aug 2019 17:41:06 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/closure/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考资料：阮一峰&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考资料：MDN&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;之前简单学习过闭包，也会无意间使用过闭包，但如果你要问我闭包是什么我也答不上来。今天呢，重新学习闭包，做个总结。&lt;/p&gt;

&lt;h3 id=&#34;什么是闭包&#34;&gt;什么是闭包&lt;/h3&gt;

&lt;p&gt;相信你在学习闭包的时候肯定看过类似的许多文章是这么说的：“闭包就是一个能够访问 &lt;strong&gt;其他函数的变量&lt;/strong&gt; 的&lt;strong&gt;函数&lt;/strong&gt;”，如果你看过《你不知道的javascript》这本书中关于闭包的解释，你会觉得这句话很片面，也很浅陋，而这句话被当今好多博文所提及，给好多学习闭包的小伙伴造成了不少的误解。&lt;/p&gt;

&lt;p&gt;《你不知道的javascript》这本书中对于闭包是这么说的：“当一个函数能够访问定义它时所处环境的局部变量时，那么就形成了一个闭包（具体怎么说的我也记不太清楚了）”，重点是“形成了一个闭包”，而不是大多数人所说的闭包就是那个函数，闭包其实还跟环境有关。在MDN中也有类似的解释，开头第一句话就是“闭包是函数和声明该函数的词法环境的组合”。下面还有一段解释:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;“闭包是由函数以及创建该函数的词法环境组合而成，这个环境包含了这个闭包创建时所能访问的所有局部变量”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于什么是词法作用域请看 [词法作用域]()&lt;/p&gt;

&lt;p&gt;啪！MDN 还是说出了打脸的话，在makeAdder栗子中，它竟然说“add5 和 add10 都是闭包”（糟糕，我要下不来台了），为什么又说这两个函数是闭包呢，虽然后面还是扯上了词法作用域，但这让读者看起来挺迷啊（哼，双标狗！😂）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function parent() {                 // 外部函数
    let name = &#39;huer&#39;               // 内部变量
    return function children() {    // 内部函数
        console.log(name)
    }
}
let other = parent()
other()                             // ‘huer’
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说下我的简单理解，闭包既然被称为包，那我就可以把它想象成一个包结构（包袱），包裹着外部函数的内部变量和内部函数，并返回内部函数。&lt;strong&gt;注意：内部函数是要被返回的！&lt;/strong&gt; 如果内部函数没有被返回，那么当外部函数执行完毕后，外部函数里面的所有变量和函数都会被垃圾回收机制所清理。此时，我们就引出了闭包函数的一个重要特性，&lt;strong&gt;可以使某些变量长时间存在于内存中而不会被销毁&lt;/strong&gt;。正常情况下，执行完一个函数，即return一个值后，该函数及其内部所有变量就会被回收。而当我们在函数内部又定义了一个函数时，根据对词法作用域的理解，该内部函数可以访问外部函数所定义的变量，即内部函数对它所处的词法作用域有一种引用关系，如果我们将内部函数return出去，并返回给一个变量，那么该变量就是对内部函数的一个引用，从而也能访问外部函数所定义的变量。那么这就实现了某些变量能够一直存在于内存中而不会被销毁，并且还是私有的，其他外部的变量无法访问，只有return的内部函数才能访问。&lt;/p&gt;

&lt;p&gt;在好多博文给出的栗子中，内部函数总是使用了外部函数所定义的变量，这就使好多同学误解，返回的内部函数一定要使用外部函数定义的变量，其实这是不对的。打个比方，我们（内部函数）出生在家里（词法作用域），我们对家里的一切事物都可以够得到，摸得着（除掉‘3岁以下儿童勿碰’等乱七八糟的规则），都可以使用，这并不意味着这些东西此时就在我们手里，它们不在我们的手里，我们也对它们有使用权（即，内部函数对所处的词法作用域有引用关系）。这就是闭包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;形成闭包的条件：外部函数（词法作用域） + 返回一个内部函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们上面的代码只是访问了内部变量，其实我们返回的内部函数还能操作内部变量，是不是有点面向对象的感觉？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function parent() {
    let name = &#39;huer&#39;
    function getName() {
        return name
    }
    function setName(val) {
        name = val
    }
    return {
        getName,
        setName
    }
}
let obj = parent()
obj.getName()                   // &#39;huer&#39;
obj.setName(&#39;tuzi&#39;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看！不止返回函数才能形成闭包，返回对象也可以！（只要对你想留下的变量保持引用就可以）&lt;/p&gt;

&lt;p&gt;MDN 上还给出了一个使用闭包的情景：“通常你使用只有一个方法的对象的地方，都可以使用闭包” 原谅我没有get到点，不过下面给出的例子倒是比较明白：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 点击按钮，修改字体大小
function makeSizer(size) {
  return function() {
    document.body.style.fontSize = size + &#39;px&#39;;
  };
}

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);

document.getElementById(&#39;size-12&#39;).onclick = size12;
document.getElementById(&#39;size-14&#39;).onclick = size14;
document.getElementById(&#39;size-16&#39;).onclick = size16;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相信上面的代码大家应该都很明白，对于事件绑定，我们要传递的是一个函数，但是如果该函数还要传递参数那就比较棘手了，于是我们可以通过闭包的方式，将参数传递给makeSizer，将makeSizer执行完后返回的函数作为事件的回调函数，于是当我们触发事件的时候，回调函数仍能访问当初传递的参数。类似的关于事件处理函数传参的问题，比如 &lt;a href=&#34;https://hueralin.github.io/2019/bind/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;React中的bind绑定&lt;/a&gt;，我也使用了闭包。&lt;/p&gt;

&lt;p&gt;基于闭包，我们可以实现面向对象中的私有变量，外部无法访问，只能通过暴露出去的公共方法来操作这些私有变量。例如上面的setName和getName。&lt;/p&gt;

&lt;p&gt;MDN 上还有一个创建计时器的工厂函数，每个计时器内部的环境都是互相独立的，也就是说这些闭包互不干扰，关于这方面的知识，参见 [JS活动对象]()&lt;/p&gt;

&lt;h3 id=&#34;坑&#34;&gt;坑&lt;/h3&gt;

&lt;p&gt;闭包虽好，但也不能乱用，常见的一个坑就是在循环中使用了闭包：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 假设有五个按钮，点击按钮分别显示1，2，3，4，5
function NB() {
    var arr = [1,2,3,4,5]
    for(var i = 0;i&amp;lt;arr.length;i++){
        var item = arr[i]
        document.getElementById(&#39;五个button的ID&#39;).onclick = function() {
            alert(item)
        }
    }
}
NB()
// 以前在这里翻过车，总以为会按照期望弹出，结果是每个都弹出5  
// 这里确实有闭包，想想上面形成闭包的条件，外部函数NB有了，返回的内部函数有了  
// 这里的内部函数返回的不明显，即传给onclick的匿名函数，这些匿名函数会在点击的时候被调用。  
// 循环了五次，形成了五个闭包（因为每个匿名函数都不一样），但这五个闭包共享同一个词法作用域，  
// 即都引用了同一个arr数组，因为循环先于按钮被点击，所以当点击时，arr[i]已经是最后一个元素了，所以每次都弹出5。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出错的原因大家应该明白了，即五个闭包共享同一个词法作用股，确切的说是调用了同一个item(arr[i])，因为它本意是想弹出不同的item嘛，所以我们要做的就是使item不同：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function NB() {
    var arr = [1,2,3,4,5]
    for(var i = 0;i&amp;lt;arr.length;i++){
        (function(i) {  // 创建了5个不同的匿名函数（即5个不同的函数作用域）
            var item = arr[i]   // 每个作用域中的item都是独一无二的
            document.getElementById(&#39;五个button的ID&#39;).onclick = function() {
                alert(item)
            }
        })(i)   // 通过使用立即执行函数，传入i
    }
}
// 此时，每个闭包所引用的词法作用域都是立即执行函数产生的，都是不同的
NB()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;未完待续&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Git Stash</title>
      <link>https://hueralin.github.io/2019/gitstash/</link>
      <pubDate>Mon, 26 Aug 2019 20:09:47 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitstash/</guid>
      <description>

&lt;h3 id=&#34;emmmm&#34;&gt;Emmmm&lt;/h3&gt;

&lt;p&gt;最近在实习的项目中经常使用 git stash 这个命令，现在来做一些总结。&lt;/p&gt;

&lt;p&gt;你可能会遇到这样一种情况，就是当你在进行开发或修改某个BUG的时候突然来了一个新任务（新任务与当前的开发项目属于同一个项目），时间紧迫，你需要立即切换分支去执行，可是你当前的任务还没有做完，切分支的话会被拒绝，怎么办呢？有种方法是先add再commit，确实可以，但是我感觉这么做的话会添加一个毫无意义的提交记录，虽然以后可以修改，但是太过麻烦。那么，就来试试 git stash 吧。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%EF%BC%88Stashing%EF%BC%89&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;git stash 官方文档第一版&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;git stash 官方文档第二版&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;git-stash-应用场景&#34;&gt;git stash 应用场景&lt;/h3&gt;

&lt;p&gt;git stash 的作用是将当前为提交的修改存储起来，让仓库还原到最后一次提交的状态。&lt;br /&gt;
使用场景：&lt;br /&gt;
1. 工作未完成，需要切换分支，但不想提交（常用）。&lt;br /&gt;
2. 开发一个feature分支（未完成），此时想要合并一下主分支，看看做了哪些修改，提前解决冲突。&lt;/p&gt;

&lt;p&gt;现在来看看场景二的解决方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 假设我在feature分支上开发，突然得知主分支更新了，于是我想要将主分支合并到当前分支，看看有没有冲突，有的话直接解决。
git checkout master  // 报错！会提示当前某些修改未存储提交  
// 当然，我是不想提交的，毕竟还没做完...于是，
git stash save &amp;quot;先搁这儿，我去瞅瞅主分支，拉下代码～&amp;quot;   // save 类似于 commit 的 -m 选项，即注释信息  
git stash list // 列出来所有的存储信息，看看有木有～  
git checkout master  // 切换到主分支
git pull origin master // 将远程主机的master分支拉下来  
git checkout feature    // 切回feature分支  
git merge master    // 将master分支合并到feature（可能会有冲突）  
git stash pop   // 将先前feature分支做的修改释放出来（可能会有冲突）  
// 有冲突合并即可，合并完，feature拥有了master分支最新的修改以及当前的特性开发。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;git-stash&#34;&gt;git stash&lt;/h3&gt;

&lt;p&gt;git stash 实际上是一个栈结构，它可以获取工作目录中的中间状态（包括对已追踪文件的修改和暂存的变更，使用 git status 查看），将它保存在一个栈结构中，方便以后使用。（注意！未被追踪的文件不在存储的范围内！）&lt;/p&gt;

&lt;p&gt;git stash 命令：&lt;br /&gt;
1. git stash（git stash push的简写）将当前工作目录的中间状态保存在栈中。&lt;br /&gt;
2. git stash list 列出所有的存储。&lt;br /&gt;
3. git stash apply stash@{0} apply后面是名字，表示要应用的存储（省略名字则应用最近的存储到仓库中），apply只是应用，并不会将存储弹出栈。&lt;br /&gt;
4. git stash pop 将最近的存储应用到仓库中（但会将存储弹出栈），也可以指定存储的名字，将指定的存储应用到仓库后弹出栈。&lt;br /&gt;
5. git stash clear 清空存储栈。&lt;br /&gt;
6. git stash drop 删除最近的存储，也可以指定名字（但不会被应用到仓库）。&lt;br /&gt;
7. git stash branch name 根据最近的stash创建一个分支，然后删除最近的stash，也可以指定存储名。（如场景二，如果最后应用stash的时候发生了冲突，可以使用这个命令，牵引出一个未合并的分支做副本）。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;讲解一下 git stash push 和 git stash save&lt;/strong&gt;&lt;br /&gt;
这两个命令都可以存储当前工作区中被追踪文件的修改，但是也有些区别。&lt;br /&gt;
语法：&lt;br /&gt;
1. git stash push -m &amp;lsquo;xxxxx&amp;rsquo; src/xxx&lt;br /&gt;
2. git stash save &amp;lsquo;xxxxx&amp;rsquo;&lt;br /&gt;
其中，git stash push能指定路径，存储指定的文件，而指定路径对git stash save来说无效，它会存储工作区中所有的被追踪文件的修改。&lt;/p&gt;

&lt;h3 id=&#34;使用-git-stash-出现的问题&#34;&gt;使用 git stash 出现的问题&lt;/h3&gt;

&lt;p&gt;Q：“我新建了一个文件，用stash存储了一下，切分支后发现该文件被带进了另一个分支”&lt;br /&gt;
A：前面说过，新建的文件，如果没有add进暂存区，那么是不受stash管理的，git也不会追踪。所以对于新建的文件，应该在使用stash前先add一下。&lt;/p&gt;

&lt;p&gt;Q：“不是说我BUG还没改完切到其他分支会报错吗，要我必须提交修改。可是我没提交修改，切master分支成功了。但是！BUG修复的代码被带到master了！”&lt;br /&gt;
A：Emmmm&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mock 前端假数据</title>
      <link>https://hueralin.github.io/2019/mock/</link>
      <pubDate>Wed, 21 Aug 2019 16:09:41 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/mock/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;为什么需要前端做假数据？Emmmm，不用我说了吧～&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;官方文档看这里&lt;a href=&#34;http://mockjs.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;MockJs&lt;/a&gt;！&lt;/p&gt;

&lt;p&gt;数据模版之类的语法去看官方文档，我这里只简单介绍一下我的使用情况。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>伪类 与 伪元素</title>
      <link>https://hueralin.github.io/2019/weilei/</link>
      <pubDate>Wed, 21 Aug 2019 15:17:26 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/weilei/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;“请说一下伪类和伪元素的区别”，之前的面试中遇到过这个问题，当初表示只见过伪类，回答的基本上都是:hover之流，这道题就挂了&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如今，在实习中遇到了相关的需求，看来是时候深入学习一下了。其实，区分伪类和伪元素并不难，它俩最大的区别就在于应用场景。&lt;/p&gt;

&lt;h3 id=&#34;伪类&#34;&gt;伪类&lt;/h3&gt;

&lt;h4 id=&#34;顾名思义-它相当于一个类-是用来设置样式的-当你需要让一个元素在某种特殊状态下显示特殊的样式时-如-按钮悬浮特效-就该使用伪类&#34;&gt;顾名思义，它相当于一个类，是用来设置样式的；当你需要让一个元素在某种特殊状态下显示特殊的样式时（如：按钮悬浮特效），就该使用伪类。&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;下面我们来实现一下伪类：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需求：实现消息列表悬浮特效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 需求很明确，li元素在悬浮情况下应用样式 --&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;React&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Vue&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Angular&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;jQuery&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Webpack&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;NPM&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
li:hover {
    background: #eee;
}
&amp;lt;!-- 再简单不过了，当然也可以设置奇偶行样式不一 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他的伪类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;:active :empty  :enabled    :first  :first-child    :first-child  
:first-of-type  :focus  :hover  :visited    :nth-child  :nth-of-type    :link
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;伪元素&#34;&gt;伪元素&lt;/h3&gt;

&lt;h4 id=&#34;顾名思义-它是一个元素-可以是现有的元素-也可以是新增的元素-这些元素往往有自己的特殊位置-如-段落首字母突出样式-往往被作为附加的标记&#34;&gt;顾名思义，它是一个元素，可以是现有的元素，也可以是新增的元素，这些元素往往有自己的特殊位置（如：段落首字母突出样式）往往被作为附加的标记。&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;下面我们来实现一下伪元素&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需求：表单必填项前面加一个标识（这也是我这次的需求）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;label&amp;gt;页面地址&amp;lt;/label&amp;gt;
&amp;lt;input type=&#39;text&#39; placeholder=&amp;quot;请输入页面地址&amp;quot;/&amp;gt;
label::before {
    content: &#39;*&#39;;
    color: red;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;img src=&#34;https://hueralin.github.io/img/posts/xinghao.jpg&#34; alt=&#34;必填项前加星号&#34; /&gt;&lt;/p&gt;

&lt;p&gt;伪元素并不多：&lt;br /&gt;
1. ::before&lt;br /&gt;
2. ::after&lt;br /&gt;
3. ::first-letter 段落首字母&lt;br /&gt;
4. ::first-line 段落首行&lt;br /&gt;
5. ::selection 这个很有意思，代表被用户高亮的部分（例如鼠标选中）&lt;/p&gt;

&lt;h3 id=&#34;before-和-after&#34;&gt;::before 和 ::after&lt;/h3&gt;

&lt;p&gt;这两个伪元素比较特殊，属于扩增原元素一类（我自己瞎起的名字）&lt;br /&gt;
::before 创建一个伪元素，并作为匹配元素的第一个子元素，::after则相反；这个新增的元素默认为“行内元素”&lt;br /&gt;
语法参照&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;MDN&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/* CSS3 语法 */
element::before { 样式 }  
/* （单冒号）CSS2 过时语法 (仅用来支持 IE8) */
element:before  { 样式 }  
/* 在每一个p元素前插入内容 */
p::before { content: &amp;quot;Hello world!&amp;quot;; } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MDN上关于这一节的最后一个例子不错，大家可以尝试一下！&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>