<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>狐耳的雪原 on 狐耳的雪原</title>
    <link>https://hueralin.github.io/</link>
    <description>Recent content in 狐耳的雪原 on 狐耳的雪原</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Oct 2019 20:00:01 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>浏览器缓存策略</title>
      <link>https://hueralin.github.io/2019/httpcache/</link>
      <pubDate>Wed, 09 Oct 2019 20:00:01 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/httpcache/</guid>
      <description>

&lt;p&gt;我再也不废话了&amp;hellip;&amp;hellip;切入正题!&lt;/p&gt;

&lt;p&gt;缓存是干啥的也不用咱说了,浏览器缓存即基于HTTP头的缓存.&lt;/p&gt;

&lt;p&gt;浏览器缓存策略有两种:强缓存和协商缓存.&lt;/p&gt;

&lt;p&gt;先大体说一下浏览器缓存的过程:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;浏览器向服务器发起请求前首先向浏览器缓存查询是否有该请求的结果及缓存标识.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;有,则从缓存中读取(强缓存成功),否则再去询问服务器(协商缓存 or 直接请求).&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;强缓存策略&#34;&gt;强缓存策略&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;强缓存的三种情况:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;请求前先去询问浏览器缓存,若有缓存且未失效,则直接从浏览器缓存读取结果,此被称之为&amp;rdquo;强缓存成功&amp;rdquo;.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;强缓存失败&amp;rdquo;, 若有缓存,但已失效,则执行&lt;strong&gt;&amp;ldquo;协商缓存&amp;rdquo;策略.&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;强缓存失败&amp;rdquo;, 若无缓存, 则向服务器正式发起请求.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;强缓存策略涉及到的HTTP头部: &lt;strong&gt;Cache-Control / expires&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;expires 是 HTTP/1.0 的产物,它的值是一个绝对值,即缓存失效的时间.浏览器会拿客户端的时间和缓存中的此标识做对比,来判断缓存是否过期.所以它的缺陷比较明显,因为客户端和服务器的时间并不总是同步的,也就是说可能出现误差.(可能影响并不多大,别喷我&amp;hellip;&amp;hellip;)&lt;/p&gt;

&lt;p&gt;Cache-Control 是 HTTP/1.1 的产物,它的值就丰富多了:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;public&lt;/strong&gt;   所有内容都将被缓存(客户端和代理服务器都可以)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;private&lt;/strong&gt;  默认值,只有客户端才能缓存&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;no-cache&lt;/strong&gt; 只有客户端缓存,但是否使用缓存需要经过协商缓存来确定&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;no-store&lt;/strong&gt; 所有内容都不缓存&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;max-age=xxx&lt;/strong&gt;  缓存将于xxx秒后失效&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们一般使用第五种方式&lt;/p&gt;

&lt;p&gt;可以看到cache-control使用的是相对时间,弥补了expires的时间误差缺陷. 在实际应用过程中这两种方式都会有,但是cache-control的优先级要高一些.&lt;/p&gt;

&lt;h3 id=&#34;协商缓存策略&#34;&gt;协商缓存策略&lt;/h3&gt;

&lt;p&gt;协商缓存发生在有缓存但到期的情况下. 实际上, 服务器设置的过期时间是用来表明此时的缓存可能会过期, 但我不能保证, 届时你得向我确认一下, 所以, 缓存并不一定失效了. 和商品的保质期一个道理.&lt;/p&gt;

&lt;p&gt;此时, 我们需要向服务器发起请求, 询问这个缓存能不能用, 如果服务器表示能用, 返回304, 那我们就去缓存中读取, 否则我们再向服务器请求新的数据.&lt;/p&gt;

&lt;p&gt;协商缓存策略涉及到的HTTP头部: &lt;strong&gt;Last-Modified / If-Modified-Since 以及 Etag / If-None-Match&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Last-Modified / If-Modified-Since&lt;/strong&gt; 是 HTTP/1.1 的产物, last-modified 标识的是资源的最后修改时间, 协商缓存开始时会发请求, 将last-modified的值赋给 请求头 if-modified-since, 向服务器发起询问 &amp;ldquo;这个资源在这个时间后修改了么?&amp;rdquo; 如果没有修改, 则返回304, 浏览器就会从缓存中读取数据, 否则会请求新的数据, 并更新缓存.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Etag / If-None-Match&lt;/strong&gt; 也是 HTTP/1.1 的产物, 过程和上面一样, 只不过Etag是由服务器根据资源内容生成的唯一标识, 具有唯一性. 用资源的最后修改时间作为标识的话不太准确, 因为可能会在1秒内多次修改文件的情况.&lt;/p&gt;

&lt;p&gt;Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高.&lt;/p&gt;

&lt;h3 id=&#34;缓存的位置&#34;&gt;缓存的位置&lt;/h3&gt;

&lt;p&gt;浏览器缓存的位置一般有两个: 硬盘缓存(disk cache) 和 内存缓存(memory cache), 我们打开F12, 可在network选项卡中网络请求的size列查看.&lt;br /&gt;
内存缓存会将编译解析后的文件存放在当前标签页进程的内存中, 读取速度较快.&lt;/p&gt;

&lt;p&gt;硬盘缓存则是将资源放入硬盘中, 需要进行对硬盘文件做I/O操作, 速度较慢.&lt;/p&gt;

&lt;p&gt;存在内存中的缓存文件, 会在刷新页面后被直接读取, 如果关闭了该标签页, 再次打开页面会重新请求. 而在硬盘中的缓存文件不会这样.&lt;/p&gt;

&lt;p&gt;浏览器对不同类型的文件选取不同的存储位置, 像JS, img等会被放进内存缓存, 而CSS会被放进硬盘缓存.&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;强缓存的优先级高于协商缓存, 强缓存失效才会进行协商缓存. 强缓存失效不代表缓存过期, 只是不确定其是否真的过期, 所以需要协商缓存过程来确认一下.&lt;/p&gt;

&lt;p&gt;桥豆麻袋! 不够细, 还有些没深入&amp;hellip;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>清除浮动</title>
      <link>https://hueralin.github.io/2019/float/</link>
      <pubDate>Wed, 09 Oct 2019 15:16:09 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/float/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;清除浮动是个老生常谈的问题了，面对这个问题我们往往能说出一两个解决方法，但你是否知道其背后的原理呢？《CSS世界》这本书给出了很好的解答，现推荐下张鑫旭近10年前的博客。&lt;br /&gt;
&lt;a href=&#34;https://www.zhangxinxu.com/wordpress/2010/01/css-float%e6%b5%ae%e5%8a%a8%e7%9a%84%e6%b7%b1%e5%85%a5%e7%a0%94%e7%a9%b6%e3%80%81%e8%af%a6%e8%a7%a3%e5%8f%8a%e6%8b%93%e5%b1%95%e4%b8%80/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;CSS float浮动的深入研究、详解及拓展(一)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.zhangxinxu.com/wordpress/2010/01/css-float%e6%b5%ae%e5%8a%a8%e7%9a%84%e6%b7%b1%e5%85%a5%e7%a0%94%e7%a9%b6%e3%80%81%e8%af%a6%e8%a7%a3%e5%8f%8a%e6%8b%93%e5%b1%95%e4%ba%8c/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;CSS float浮动的深入研究、详解及拓展(二)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#39;#4&#39;&gt;别废话!切入正题!&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;a-href-1-name-1-清除浮动的原因-a&#34;&gt;&lt;a href=&#39;#1&#39; name=&#39;1&#39;&gt;清除浮动的原因&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;浮动布局时不小心高度塌陷了呗~&lt;/p&gt;

&lt;h3 id=&#34;a-href-2-name-2-浮动的真正目的-a&#34;&gt;&lt;a href=&#39;#2&#39; name=&#39;2&#39;&gt;浮动的真正目的&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;浮动的出现仅仅是为了让&lt;strong&gt;文字围绕图片&lt;/strong&gt;而已，就像WORD中的“文字环绕”一样。&lt;/p&gt;

&lt;h3 id=&#34;a-href-3-name-3-浮动的原理-a&#34;&gt;&lt;a href=&#39;#3&#39; name=&#39;3&#39;&gt;浮动的原理&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在张鑫旭的两篇文章中将浮动的本质定义为“包裹与破坏”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#39;#31&#39; name=&#39;31&#39;&gt;1. 浮动的包裹性&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;浮动就是个带有方位的display: inline-block; inline-block就是让一个块级盒子变成一个内联盒子，不让其独占一行，而是将其内容紧紧地包裹起来。而在块级盒子上应用了浮动，你会发现其确实变成了一个内联盒子。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#39;#32&#39; name=&#39;32&#39;&gt;2. 浮动的破坏性&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;结合“浮动的本职工作是实现文字环绕图片”来说明其&lt;strong&gt;“破坏性”&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;文字之所以会环绕含有float属性的图片时因为&lt;strong&gt;浮动破坏了正常的line boxes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#39;#33&#39; name=&#39;33&#39;&gt;line box模型&lt;/a&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;float的本职工作是实现&amp;lt;em&amp;gt;文字环绕图片&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;!-- 
    上面代码包含四个box
    1. inline box：‘float的本职工作是实现’是匿名的inline box，‘&amp;lt;em&amp;gt;文字环绕图片&amp;lt;/em&amp;gt;’是inline box。
    2. line box：一个个的inline box排成一行就是一个line box，多行则有多个line box。
    3. content area：在我理解就是内容区域包含上面所有的一种box。
    4. &amp;lt;p&amp;gt;标签所在的containing box，此box包含了其他的boxes。
    以上3，4解释不够严谨或有错误，可不做参考，日后修正。
--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认无浮动的图文混排是这个样子的（借用下图片）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://image.zhangxinxu.com/image/blog/201001/2010-01-20_230801.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图片本身就是个inline box，和两侧的inline box共同组成了line box，line box的高度由最高的inline box决定，第二行文本属于另一个line box，且一张图片只能与一个line box对其。&lt;/p&gt;

&lt;p&gt;给图片加了浮动之后：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://image.zhangxinxu.com/image/blog/201001/2010-01-20_234149.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图片不再和其他的inline box在一块了，可见浮动使图片丧失了inline box特性。而&lt;strong&gt;丧失了inline box特性的后果就是高度塌陷&lt;/strong&gt;。为什么呢？&lt;/p&gt;

&lt;p&gt;在CSS中，所有的高度都是有两个CSS模型产生的。box模型，line box模型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;box模型&lt;/strong&gt;：height + padding + margin&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;line box模型&lt;/strong&gt;：line-height&lt;/p&gt;

&lt;p&gt;HEIGHT（line box） = HEIGHT（inline box）* n&lt;/p&gt;

&lt;p&gt;HEIGHT（containing box） = HEIGHT（line box）* n  即div或p标签的高度。&lt;/p&gt;

&lt;p&gt;而一旦没了inline box特性，这个高度势必大打折扣。要么完全塌陷，要么由其他inline box的高度顶替。&lt;/p&gt;

&lt;p&gt;个人认为，line boxes掌管的是box内容的高度。而一个元素真正的高度由box代表的外层高度和line box代表的内层高度组成。&lt;/p&gt;

&lt;p&gt;我们要实现文字环绕就必须使图片和多行文本对齐，而如果不能打破inline box特性，就只能和一行文本对齐。所以浮动一定要打破inline box特性。&lt;/p&gt;

&lt;p&gt;浮动的元素并没有脱离文档流，所以其他文本（inline box）并不会与之发生重合。并且，丧失inline box特性仅仅让其&lt;strong&gt;不在容器中占据高度&lt;/strong&gt;，其自身高度还是有的，而且在容器中还占据着宽度，这就实现了文本绕它而行，给围了起来。&lt;/p&gt;

&lt;p&gt;接下来说包裹性，实际上浮动只是将元素变成了类似inline-box的样式，只保留了其包裹性，而inline box的特性被抛弃了。&lt;/p&gt;

&lt;p&gt;下面我们来看一下张鑫旭大神给个例子：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;单个无浮动的li&lt;br /&gt;
&lt;img src=&#34;http://image.zhangxinxu.com/image/blog/201001/2010-01-21_202917.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单个左浮动的li&lt;br /&gt;
&lt;img src=&#34;https://image.zhangxinxu.com/image/blog/201001/2010-01-21_205119.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
呈现了包裹性。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多个左浮动的li&lt;br /&gt;
&lt;img src=&#34;https://image.zhangxinxu.com/image/blog/201001/2010-01-21_214516.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
呈现了包裹性，于是排列成一行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个左浮动一个无浮动&lt;br /&gt;
&lt;img src=&#34;https://image.zhangxinxu.com/image/blog/201001/2010-01-21_230302.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
第一个li因为浮动导致其“上浮”，为什么会“上浮”？因为它失去了inline box的特性，没了高度，第二个li顶了上来，呈现了第一个li上浮的假象。即便“上浮”，但并没有覆盖掉下面的li内容，因为浮动并没有使其内容脱离文档流，第一个li中的图片仍占据着空间，导致第二个li的图片紧贴在第一张图片的后面（第二个li没有浮动，其宽度是100%）。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原理部分就讲那么多，其实原文牵扯了不少内容，我总结引用的也不是很好。下面来终于到了重点内容！&lt;/p&gt;

&lt;h3 id=&#34;a-href-4-name-4-如何清除浮动-解决高度塌陷-a&#34;&gt;&lt;a href=&#39;#4&#39; name=&#39;4&#39;&gt;如何清除浮动，解决高度塌陷&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;高度为什么会塌陷？&lt;/p&gt;

&lt;p&gt;浮动使元素变成了inline-box，然后破坏其inline box特性，导致line box没了高度，进而使contain box（div、p等的内容高度）没了高度，于是塌陷。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.最简洁的方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 将下面代码放到父元素中作为最后一个子标签 --&amp;gt;
&amp;lt;div class=&#39;clear&#39;&amp;gt;.clear { clear: both; }&amp;lt;/div&amp;gt;
&amp;lt;!-- 我觉得挺好的，不过别人都说增加了无意义的标签，Emmm --&amp;gt;
&amp;lt;!-- 张鑫旭大大的原话 --&amp;gt;
&amp;lt;!-- 我从来不用，因为我看到的是个巨大的浪费，浪费了一个标签，
而且只能使用一次，我个人是无法容忍的，所以这个方法不推荐。
而且有时候一不留神中间多了个空格会产生一段空白高度的。 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.overflow + zoom方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.parent{
    overflow:hidden; 
    zoom:1; /* 值可为 normal, 倍数, 百分比 */
}
/* zoom是设置或检索对象的缩放比例的,除了火狐其他浏览器都兼容. */
/* 不过overflow:hidden容易裁剪 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.after + zoom方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.parent{zoom:1;}
.parent:after{display:block; content:&#39;clear&#39;; clear:both; line-height:0; visibility:hidden;}
/* 张鑫旭大大鼎力推荐,after里可以只写display,content,clear. */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.破罐破摔法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;手动给父元素加高度&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;zoom这个属性是&lt;strong&gt;ie&lt;/strong&gt;专有属性，除了设置或者检索对象的缩放比例之外，它还有可以触发ie的haslayout属性，清除浮动，清除margin重叠等作用。 不过值得注意的一点就是火狐浏览器不支持zoom属性，但是在webkit内核浏览器中zoom这个属性也是可以被支持的。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Git Reflog</title>
      <link>https://hueralin.github.io/2019/gitreflog/</link>
      <pubDate>Mon, 07 Oct 2019 22:13:09 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitreflog/</guid>
      <description>

&lt;h1 id=&#34;是不是-git-reset-hard-之后傻眼了-嗯&#34;&gt;是不是 git reset &amp;ndash;hard 之后傻眼了~~~嗯？&lt;/h1&gt;

&lt;p&gt;来咯来咯~ git reflog 真的来咯~~&lt;/p&gt;

&lt;h3 id=&#34;git-reflog&#34;&gt;git reflog&lt;/h3&gt;

&lt;p&gt;git reflog 工具会记录你每次对HEAD的更改，即当你提交、切换分支或者reset后，HEAD都会更改，reflog都会记录下来你的操作。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// git log --oneline
b2d387d (HEAD -&amp;gt; master) add index.css
9515998 initial reset
29adb97 (origin/master, origin/HEAD) add branch_learn
1563c0f add log.md
53b7acc add What&#39;s commit/log.md
f318db2 git add --all

// 现在我们不小心回退到 1563c0f 这个提交
// git reset --hard 1563c0f
// git log --oneline
1563c0f (HEAD -&amp;gt; master) add log.md
53b7acc add What&#39;s commit/log.md
f318db2 git add --all
// 此时，暂存区和工作目录都回退到了指定的提交，那些未保存的修改都没了......

// 因为Git记录下来了我们每次对HEAD进行的更改，所以我们可以使用git reflog命令查看所有的HEAD改动记录。
// git reflog
1563c0f (HEAD -&amp;gt; master) HEAD@{0}: reset: moving to 1563c0f
b2d387d HEAD@{1}: commit: add index.css
9515998 HEAD@{2}: commit: initial reset
// 可以看到，第一条就是我们的reset命令。
// 第二条是最近的一次提交记录，即我们刚刚回退的记录，前面有它的散列值。
// 我们再次执行 git reset --hard，为什么要加上hard呢？因为我们要复原，暂存索引和工作目录都要。
// git reset --hard b2d387d
// git log --oneline
b2d387d (HEAD -&amp;gt; master) add index.css
9515998 initial reset
29adb97 (origin/master, origin/HEAD) add branch_learn
1563c0f add log.md
53b7acc add What&#39;s commit/log.md
f318db2 git add --all
// 看！又回来了！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实，我只是为了简单介绍这个命令而举的这个例子，并不具有代表性，在实际过程中遇到的问题比这个复杂得多，所以还要随机应变，和其他命令配合。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LearnGitWithBitbucketCloud(3-4-4)-Git Reset</title>
      <link>https://hueralin.github.io/2019/gitreset-translation/</link>
      <pubDate>Mon, 07 Oct 2019 11:30:54 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitreset-translation/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;[假面包屑导航]&lt;/strong&gt; &lt;a href=&#34;https://www.atlassian.com/git/tutorials&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Git tutorials&lt;/a&gt; / &lt;a href=&#34;https://www.atlassian.com/git/tutorials/setting-up-a-repository&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Getting Started&lt;/a&gt; / &lt;a href=&#34;https://www.atlassian.com/git/tutorials/undoing-changes&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;UndoingChanges&lt;/a&gt; / git-reset&lt;/p&gt;

&lt;p&gt;“这是一篇译文”，本人水平有限，若有错误请&lt;a href=&#34;https://www.atlassian.com/git/tutorials/undoing-changes/git-reset&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考原文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The git reset command is a complex and versatile tool for undoing changes. It has three primary forms of invocation. These forms correspond to command line arguments &amp;ndash;soft, &amp;ndash;mixed, &amp;ndash;hard. The three arguments each correspond to Git&amp;rsquo;s three internal state management mechanism&amp;rsquo;s, The Commit Tree (HEAD), The Staging Index, and The Working Directory.&lt;/p&gt;

&lt;p&gt;git reset 命令是用于撤销更改的复杂而又通用的工具。它有三种主要的调用形式，这三种形式分别对应着命令行参数 &amp;ndash;soft, &amp;ndash;mixed, &amp;ndash;hard。这三种参数分别对应着Git的三种内部状态管理机制，The Commit Tree (HEAD), The Staging Index, and The Working Directory。&lt;/p&gt;

&lt;h1 id=&#34;git-reset-three-trees-of-git&#34;&gt;Git Reset &amp;amp; Three Trees of Git&lt;/h1&gt;

&lt;p&gt;To properly understand git reset usage, we must first understand Git&amp;rsquo;s internal state management systems. Sometimes these mechanisms are called Git&amp;rsquo;s &amp;ldquo;three trees&amp;rdquo;. Trees may be a misnomer, as they are not strictly traditional tree data-structures. They are, however, node and pointer-based data structures that Git uses to track a timeline of edits. The best way to demonstrate these mechanisms is to create a changeset in a repository and follow it through the three trees.&lt;/p&gt;

&lt;p&gt;为了更适当的理解 git reset 的用法，我们必须首先了解Git的内部状态管理系统。有时这些机制被称为&lt;strong&gt;Git的三棵树&lt;/strong&gt;，尽管它们不是严格意义上的传统的“树”数据结构。而是Git用来跟踪编辑时间轴的基于结点和指针的数据结构。演示这种机制的最好方法是在仓库中创建一个“改动集合”，然后通过着三棵树来跟踪它。&lt;/p&gt;

&lt;p&gt;To get started we will create a new repository with the commands below:&lt;br /&gt;
首先，我们使用以下的命令行创建一个仓库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ mkdir git_reset_test
$ cd git_reset_test/
$ git init .
Initialized empty Git repository in /git_reset_test/.git/
$ touch reset_lifecycle_file
$ git add reset_lifecycle_file
$ git commit -m&amp;quot;initial commit&amp;quot;
[master (root-commit) d386d86] initial commit
1 file changed, 0 insertions(+), 0 deletions(-)
create mode 100644 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above example code creates a new git repository with a single empty file, reset_lifecycle_file. At this point, the example repository has a single commit (d386d86) from adding reset_lifecycle_file.&lt;/p&gt;

&lt;p&gt;上面的示例代码创建了一个仓库，里面只有一个空文件 reset_lifecycle_file。此时，这个仓库里面只有一个刚刚初始化的提交。&lt;/p&gt;

&lt;h1 id=&#34;the-working-directory&#34;&gt;The working directory&lt;/h1&gt;

&lt;p&gt;The first tree we will examine is &amp;ldquo;The Working Directory&amp;rdquo;. This tree is in sync with the local filesystem and is representative of the immediate changes made to content in files and directories.&lt;/p&gt;

&lt;p&gt;我们将要了解的第一棵树叫做“工作目录”。这棵树和本地文件系统是同步的，并且文件或目录中内容的更改它都能立即显示出来。（说白了就是你本地的工作目录）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ echo &#39;hello git reset&#39; &amp;gt; reset_lifecycle_file  
$ git status  
On branch master  
Changes not staged for commit:  
(use &amp;quot;git add ...&amp;quot; to update what will be committed)  
(use &amp;quot;git checkout -- ...&amp;quot; to discard changes in working directory)  
modified: reset_lifecycle_file // (假装是红色的)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our demo repository, we modify and add some content to the reset_lifecycle_file. Invoking git status shows that Git is aware of the changes to the file. These changes are currently a part of the first tree, &amp;ldquo;The Working Directory&amp;rdquo;. Git status can be used to show changes to the Working Directory. They will be displayed in the red with a &amp;lsquo;modified&amp;rsquo; prefix.&lt;/p&gt;

&lt;p&gt;在我们的示例仓库中，我们修改了 reset_lifecycle_file 文件的内容。调用 git status 命令，可以看到Git已经追踪到了文件的修改。这些修改是当前“工作目录”的一部分。&lt;code&gt;git status&lt;/code&gt; 用来显示工作目录的修改。这些改动将会以红色的‘modified’前缀显示。&lt;/p&gt;

&lt;h1 id=&#34;staging-index&#34;&gt;Staging index&lt;/h1&gt;

&lt;p&gt;Next up is the &amp;lsquo;Staging Index&amp;rsquo; tree. This tree is tracking Working Directory changes, that have been promoted with git add, to be stored in the next commit. This tree is a complex internal caching mechanism. Git generally tries to hide the implementation details of the Staging Index from the user.&lt;/p&gt;

&lt;p&gt;接下来是“暂存索引”树。这棵树是用来追踪工作目录的修改的，且已经调用过 &lt;code&gt;git add&lt;/code&gt;。这棵树是一个复杂的内部缓存机制。Git一般情况下会对用户隐藏暂存索引的实现细节。&lt;/p&gt;

&lt;p&gt;To accurately view the state of the Staging Index we must utilize a lesser known Git command git ls-files. The git ls-files command is essentially a debug utility for inspecting the state of the Staging Index tree.&lt;/p&gt;

&lt;p&gt;为了准确的观察“暂存索引”的状态，我们必须使用一个不常见的Git命令 &lt;code&gt;git ls-files&lt;/code&gt; 。这个命令实际上是一个为了检查“暂存索引”树的状态的调试命令。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;git ls-files -s  
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0 reset_lifecycle_file  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have executed git ls-files with the -s or &amp;ndash;stage option. Without the -s option the git ls-files output is simply a list of file names and paths that are currently part of the index. The -s option displays additional metadata for the files in the Staging Index. This metadata is the staged contents&amp;rsquo; mode bits, object name, and stage number. Here we are interested in the object name, the second value (d7d77c1b04b5edd5acfc85de0b592449e5303770). This is a standard Git object SHA-1 hash. It is a hash of the content of the files. The Commit History stores its own object SHA&amp;rsquo;s for identifying pointers to commits and refs and the Staging Index has its own object SHA&amp;rsquo;s for tracking versions of files in the index.&lt;/p&gt;

&lt;p&gt;接下来，我们执行 git ls-files -s / &amp;ndash;stage。如果没有 -s 选项，那么 git ls-files 只会输出一个简单的包含文件名和路径的文件列表。-s 选项展示了暂存索引树中文件的额外的元数据。这些元数据包括暂存内容的位模式，对象名以及暂存号。这里我们主要看对象名，即列表项的第二个值。这是一个标准的Git对象SHA-1散列。它是文章内容的hash值。提交历史（git log）保存了它自身的对象SHA，用于标识提交和引用的指针，并且暂存索引也有它自己的用来跟踪索引中文件版本的对象SHA。&lt;/p&gt;

&lt;p&gt;Next, we will promote the modified reset_lifecycle_file into the Staging Index.&lt;/p&gt;

&lt;p&gt;接下来，我们将修改后的 reset_lifecycle_file 文件加入到暂存索引中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git add reset_lifecycle_file   
$ git status   
On branch master Changes to be committed:   
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)   
modified: reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have invoked git add reset_lifecycle_file which adds the file to the Staging Index. Invoking git status now shows reset_lifecycle_file in green under &amp;ldquo;Changes to be committed&amp;rdquo;. It is important to note that git status is not a true representation of the Staging Index. The git status command output displays changes between the Commit History and the Staging Index. Let us examine the Staging Index content at this point.&lt;/p&gt;

&lt;p&gt;这里我们调用了 git add reset_lifecycle_file 命令，将文件加入了暂存索引中。在调用 git status 命令，可以看到输出显示 reset_lifecycle_file 文件以绿色标识在“Changes to be committed”下面。注意，git status 并不是暂存索引的真正体现。git status 命令输出显示是 提交历史 和 暂存索引 之间的改动。现在让我们检查一下暂存索引的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git ls-files -s  
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that the object SHA for reset_lifecycle_file has been updated from e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 to d7d77c1b04b5edd5acfc85de0b592449e5303770.&lt;/p&gt;

&lt;p&gt;我们可以看到 reset_lifecycle_file 文件的对象SHA发生了变化。&lt;/p&gt;

&lt;h1 id=&#34;commit-history&#34;&gt;Commit history&lt;/h1&gt;

&lt;p&gt;The final tree is the Commit History. The git commit command adds changes to a permanent snapshot that lives in the Commit History. This snapshot also includes the state of the Staging Index at the time of commit.&lt;/p&gt;

&lt;p&gt;最后一棵树是“提交历史”。git commit 命令将文件的改动添加进一个永久的快照中，这个快照保存在“提交历史”树中。这个快照还包含了提交时暂存索引的状态。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git commit -am&amp;quot;update content of reset_lifecycle_file&amp;quot;
[master dc67808] update content of reset_lifecycle_file
1 file changed, 1 insertion(+)
$ git status
On branch master
nothing to commit, working tree clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have created a new commit with a message of &amp;ldquo;update content of resetlifecyclefile&amp;rdquo;. The changeset has been added to the Commit History. Invoking git status at this point shows that there are no pending changes to any of the trees. Executing git log will display the Commit History. Now that we have followed this changeset through the three trees we can begin to utilize git reset.&lt;/p&gt;

&lt;p&gt;我们创建了一个提交，将之前所做的修改作为一个集合添加进提交历史。调用 git status 命令，可以看到没有需要添加进任何树中的等待中的修改。执行 git log 命令会显示提交历史。既然我们已经通过三棵树跟踪了这个变更集，我们就可以开始使用git reset了。&lt;/p&gt;

&lt;h1 id=&#34;how-it-works&#34;&gt;How it works&lt;/h1&gt;

&lt;p&gt;At a surface level, git reset is similar in behavior to git checkout. Where git checkout solely operates on the HEAD ref pointer, git reset will move the HEAD ref pointer and the current branch ref pointer. To better demonstrate this behavior consider the following example:&lt;/p&gt;

&lt;p&gt;表面上，git reset 在行为上和 git checkout 相似。git checkout 仅仅操作在HEAD的引用指针上，而 git reset 会移动到HEAD的引用指针以及当前分支的引用指针上。为了更好地演示这种行为，我们考虑下下面的例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wac-cdn.atlassian.com/dam/jcr:b02e7b60-742a-449d-921d-53c32410576d/git-sequence-transparent.png?cdnVersion=612&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;git checkout b&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wac-cdn.atlassian.com/dam/jcr:73e231c7-ddee-4f32-94d6-a3e31e835690/git-checkout-transparent.png?cdnVersion=612&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With git checkout, the master ref is still pointing to d. The HEAD ref has been moved, and now points at commit b. The repo is now in a &amp;lsquo;detached HEAD&amp;rsquo; state.&lt;/p&gt;

&lt;p&gt;调用了 git checkout ，master分支的引用仍然指向d。HEAD引用移动了，现在指向了 commit b。仓库现在处于HEAD指向的状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;git reset b&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wac-cdn.atlassian.com/dam/jcr:29e29d3d-dddd-480b-afd9-77169a7b0230/git-reset-transparent.png?cdnVersion=612&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Comparatively, git reset, moves both the HEAD and branch refs to the specified commit.&lt;/p&gt;

&lt;p&gt;相对而言，git reset 将HEAD引用和分支引用都移动到了特定的提交上。&lt;/p&gt;

&lt;p&gt;In addition to updating the commit ref pointers, git reset will modify the state of the three trees. The ref pointer modification always happens and is an update to the third tree, the Commit tree. The command line arguments &amp;ndash;soft, &amp;ndash;mixed, and &amp;ndash;hard direct how to modify the Staging Index, and Working Directory trees.&lt;/p&gt;

&lt;p&gt;除了更新提交引用指针，git reset 还会修改三棵树的状态。引用指针的改变经常会发生，并且是对第三棵树&amp;mdash;“提交树”的更新。命令行参数 &amp;ndash;soft，&amp;ndash;mixed 以及 &amp;ndash;hard 如何修改这三棵树呢。&lt;/p&gt;

&lt;h1 id=&#34;main-options&#34;&gt;Main Options&lt;/h1&gt;

&lt;p&gt;The default invocation of git reset has implicit arguments of &amp;ndash;mixed and HEAD. This means executing git reset is equivalent to executing git reset &amp;ndash;mixed HEAD. In this form HEAD is the specified commit. Instead of HEAD any Git SHA-1 commit hash can be used.&lt;/p&gt;

&lt;p&gt;调用 git reset 默认会有两个隐式的参数 &amp;ndash;mixed 和 HEAD。也就是说执行 git reset 等同于执行 git reset &amp;ndash;mixed HEAD。在这种形式中，HEAD就是一个指定的提交。可以使用任何提交对象的散列值来代替HEAD。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wac-cdn.atlassian.com/dam/jcr:7fb4b5f7-a2cd-4cb7-9a32-456202499922/03%20(8).svg?cdnVersion=612&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;hard&#34;&gt;&amp;ndash;hard&lt;/h1&gt;

&lt;p&gt;This is the most direct, DANGEROUS, and frequently used option. When passed &amp;ndash;hard The Commit History ref pointers are updated to the specified commit. Then, the Staging Index and Working Directory are reset to match that of the specified commit. Any previously pending changes to the Staging Index and the Working Directory gets reset to match the state of the Commit Tree. This means any pending work that was hanging out in the Staging Index and Working Directory will be lost.&lt;/p&gt;

&lt;p&gt;这是一个最直接，&lt;strong&gt;最危险&lt;/strong&gt;，且使用最频繁的一个选项。当使用 &amp;ndash;hard 后，提交历史的引用指针会更新到指定的提交。然后，暂存索引和工作目录也会重置到指定提交的状态。任何先前暂存索引和工作目录中的等待中的修改都会被重置到提交记录树种的指定的状态。也就是说任何暂存索引和工作目录中挂起的工作都会丢失。&lt;/p&gt;

&lt;p&gt;To demonstrate this, let&amp;rsquo;s continue with the three tree example repo we established earlier. First let&amp;rsquo;s make some modifications to the repo. Execute the following commands in the example repo:&lt;/p&gt;

&lt;p&gt;为了演示，我们继续使用之前的仓库。首先我们做些修改，然后执行下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ echo &#39;new file content&#39; &amp;gt; new_file
$ git add new_file
$ echo &#39;changed content&#39; &amp;gt;&amp;gt; reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These commands have created a new file named new_file and added it to the repo. Additionally, the content of reset_lifecycle_file will be modified. With these changes in place let us now examine the state of the repo using git status.&lt;/p&gt;

&lt;p&gt;创建一个新文件，并添加进仓库。然后对 reset_lifecycle_file 文件做一些修改，再执行 git status：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git status
On branch master
Changes to be committed:
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)
new file: new_file
Changes not staged for commit:
(use &amp;quot;git add ...&amp;quot; to update what will be committed)
(use &amp;quot;git checkout -- ...&amp;quot; to discard changes in working directory)
modified: reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that there are now pending changes to the repo. The Staging Index tree has a pending change for the addition of new_file and the Working Directory has a pending change for the modifications to reset_lifecycle_file.&lt;/p&gt;

&lt;p&gt;现在我们能看到仓库中有一些等待中的修改。暂存索引树中等待中的修改是新文件的增加，工作目录书树的等待中的修改是 reset_lifecycle_file 文件的改动。&lt;/p&gt;

&lt;p&gt;Before moving forward let us also examine the state of the Staging Index:&lt;/p&gt;

&lt;p&gt;在使用 git reset 移动之前，我们先来看一下暂存索引：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git ls-files -s
100644 8e66654a5477b1bf4765946147c49509a431f963 0 new_file
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that new_file has been added to the index. We have made updates to reset_lifecycle_file but the Staging Index SHA (d7d77c1b04b5edd5acfc85de0b592449e5303770) remains the same. This is expected behavior because have not used git add to promote these changes to the Staging Index. These changes exist in the Working Directory.&lt;/p&gt;

&lt;p&gt;我们可以看到新文件被添加进了暂存索引。我们对 reset_lifecycle_file 文件做了修改，但是它的暂存索引中的SHA并没有改变。这是意料之中的事，因为我们并没有使用 git add 命令将修改添加进暂存索引。这些修改仍然存在于工作目录中。&lt;/p&gt;

&lt;p&gt;Let us now execute a git reset &amp;ndash;hard and examine the new state of the repository.&lt;/p&gt;

&lt;p&gt;让我们执行下 git reset &amp;ndash;hard 然后看看仓库中当前的状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git reset --hard
HEAD is now at dc67808 update content of reset_lifecycle_file
$ git status
On branch master
nothing to commit, working tree clean
$ git ls-files -s
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have executed a &amp;ldquo;hard reset&amp;rdquo; using the &amp;ndash;hard option. Git displays output indicating that HEAD is pointing to the latest commit dc67808. Next, we check the state of the repo with git status. Git indicates there are no pending changes. We also examine the state of the Staging Index and see that it has been reset to a point before new_file was added. Our modifications to reset_lifecycle_file and the addition of new_file have been destroyed. This data loss cannot be undone, this is critical to take note of.&lt;/p&gt;

&lt;p&gt;现在HEAD指向了最近的一次提交 dc67808。执行 git status，发现Git说此时没有等待中的修改。执行  git ls-files -s ，查看暂存索引树，发现回到了添加新文件之前的状态。我们对新文件的添加和对旧文件的修改都被销毁了。这些数据丢失了，也不能重做，注意这一点很重要。&lt;/p&gt;

&lt;h1 id=&#34;mixed&#34;&gt;&amp;ndash;mixed&lt;/h1&gt;

&lt;p&gt;This is the default operating mode. The ref pointers are updated. The Staging Index is reset to the state of the specified commit. Any changes that have been undone from the Staging Index are moved to the Working Directory. Let us continue.&lt;/p&gt;

&lt;p&gt;&amp;ndash;mixed 是默认选项。引用指针会被更新。暂存索引被重置到指定的提交。从暂存索引中撤消的任何更改都将移动到工作目录。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ echo &#39;new file content&#39; &amp;gt; new_file
$ git add new_file
$ echo &#39;append content&#39; &amp;gt;&amp;gt; reset_lifecycle_file
$ git add reset_lifecycle_file
$ git status
On branch master
Changes to be committed:
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)
new file: new_file
modified: reset_lifecycle_file
$ git ls-files -s
100644 8e66654a5477b1bf4765946147c49509a431f963 0 new_file
100644 7ab362db063f9e9426901092c00a3394b4bec53d 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above we have made some modifications to the repository. Again, we have added a new_file and modified the contents of reset_lifecycle_file. These changes are then applied to the Staging Index with git add. With the repo in this state, we will now execute the reset.&lt;/p&gt;

&lt;p&gt;新文件的增加和旧文件的修改都被执行了 git add ，添加进了暂存索引。然后，我们执行reset：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git reset --mixed
$ git status
On branch master
Changes not staged for commit:
(use &amp;quot;git add ...&amp;quot; to update what will be committed)
(use &amp;quot;git checkout -- ...&amp;quot; to discard changes in working directory)
modified: reset_lifecycle_file
Untracked files:
(use &amp;quot;git add ...&amp;quot; to include in what will be committed)
new_file
no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)
$ git ls-files -s
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have executed a &amp;ldquo;mixed reset&amp;rdquo;. To reiterate, &amp;ndash;mixed is the default mode and the same effect as executing git reset. Examining the output from git status and git ls-files, shows that the Staging Index has been reset to a state where reset_lifecycle_file is the only file in the index. The object SHA for reset_lifecycle_file has been reset to the previous version.&lt;/p&gt;

&lt;p&gt;我们可以看到，&amp;ndash;mixed 和 &amp;ndash;hard 对使用 git ls-files 命令的结果一样，暂存索引中只有reset_lifecycle_file。暂存索引回退到之前的状态。&lt;/p&gt;

&lt;p&gt;The important things to take note of here is that git status shows us that there are modifications to reset_lifecycle_file and there is an untracked file: new_file. This is the explicit &amp;ndash;mixed behavior. The Staging Index has been reset and the pending changes have been moved into the Working Directory. Compare this to the &amp;ndash;hard reset case where the Staging Index was reset and the Working Directory was reset as well, losing these updates.&lt;/p&gt;

&lt;p&gt;需要注意的是，git status 显示，reset_lifecycle_file 被修改了， new_file 未被跟踪。暂存索引被重置，等待中的修改都被放进了工作目录。而 &amp;ndash;hard ，暂存索引和工作目录都被重置了，所做的修改都丢失了。&lt;/p&gt;

&lt;h1 id=&#34;soft&#34;&gt;&amp;ndash;soft&lt;/h1&gt;

&lt;p&gt;When the &amp;ndash;soft argument is passed, the ref pointers are updated and the reset stops there. The Staging Index and the Working Directory are left untouched. This behavior can be hard to clearly demonstrate. Let&amp;rsquo;s continue with our demo repo and prepare it for a soft reset.&lt;/p&gt;

&lt;p&gt;使用 &amp;ndash;soft，引用指针被更新，重置就停止在那里。暂存索引和工作目录保持不变。这个行为不好演示，我们继续使用这个仓库，为 soft reset 做好准备。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git add reset_lifecycle_file   
$ git ls-files -s   
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file   
$ git status   
On branch master   
Changes to be committed:   
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)   
modified: reset_lifecycle_file   
Untracked files:   
(use &amp;quot;git add ...&amp;quot; to include in what will be committed)   
new_file  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have again used git add to promote the modified reset_lifecycle_file into the Staging Index. We confirm that the index has been updated with the git ls-files output. The output from git status now displays the &amp;ldquo;Changes to be committed&amp;rdquo; in green. The new_file from our previous examples is floating around in the Working Directory as an untracked file. Lets quickly execute rm new_file to delete the file as we will not need it for the upcoming examples.&lt;/p&gt;

&lt;p&gt;这里，我们修改了旧文件，并添加进了暂存索引。执行 git status 可以看到旧文件处于待提交状态，新文件处于待暂存状态。让我们快速执行rm new_file来删除文件，因为在接下来的示例中不需要它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git reset --soft
$ git status
On branch master
Changes to be committed:
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)
modified: reset_lifecycle_file
$ git ls-files -s
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have executed a &amp;lsquo;soft reset&amp;rsquo;. Examining the repo state with git status and git ls-files shows that nothing has changed. This is expected behavior. A soft reset will only reset the Commit History. By default, git reset is invoked with HEAD as the target commit. Since our Commit History was already sitting on HEAD and we implicitly reset to HEAD nothing really happened.&lt;/p&gt;

&lt;p&gt;执行完 git reset &amp;ndash;soft 以及 git status 后，显示xxx。soft reset 只会重置提交历史。因为我们的提交历史已经被设置为HEAD了，我们隐式地将其重置为HEAD，所以实际上什么也没有发生。&lt;/p&gt;

&lt;p&gt;To better understand and utilize &amp;ndash;soft we need a target commit that is not HEAD. We have reset_lifecycle_file waiting in the Staging Index. Let&amp;rsquo;s create a new commit.&lt;/p&gt;

&lt;p&gt;为了更好的理解 &amp;ndash;soft 用法，我们需要一个非HEAD的提交记录。暂存索引中 reset_lifecycle_file 文件还在等着被提交，那我们就提交它吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git commit -m&amp;quot;prepend content to reset_lifecycle_file&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, our repo should have three commits. We will be going back in time to the first commit. To do this we will need the first commit&amp;rsquo;s ID. This can be found by viewing output from git log.&lt;/p&gt;

&lt;p&gt;此时，仓库应该有3个提交记录。为了回退到第一个提交记录，我们需要它的提交ID，执行 git log 即可查看。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git log
commit 62e793f6941c7e0d4ad9a1345a175fe8f45cb9df
Author: bitbucket 
Date: Fri Dec 1 15:03:07 2017 -0800
prepend content to reset_lifecycle_file
commit dc67808a6da9f0dec51ed16d3d8823f28e1a72a
Author: bitbucket 
Date: Fri Dec 1 10:21:57 2017 -0800
update content of reset_lifecycle_file
commit 780411da3b47117270c0e3a8d5dcfd11d28d04a4
Author: bitbucket 
Date: Thu Nov 30 16:50:39 2017 -0800
initial commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Keep in mind that Commit History ID&amp;rsquo;s will be unique to each system. This means the commit ID&amp;rsquo;s in this example will be different from what you see on your personal machine. The commit ID we are interested in for this example is 780411da3b47117270c0e3a8d5dcfd11d28d04a4. This is the ID that corresponds to the &amp;ldquo;initial commit&amp;rdquo;. Once we have located this ID we will use it as the target for our soft reset.&lt;/p&gt;

&lt;p&gt;注意，每个系统的提交历史的ID都是独一无二的。我们需要的是第一个提交历史的ID 780411da3b47117270c0e3a8d5dcfd11d28d04a4 ，将用它准备调用 git reset &amp;ndash;soft。&lt;/p&gt;

&lt;p&gt;Before we travel back in time lets first check the current state of the repo.&lt;/p&gt;

&lt;p&gt;回退之前我们先看一下仓库当前的状态。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git status &amp;amp;&amp;amp; git ls-files -s
On branch master
nothing to commit, working tree clean
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始回退&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$git reset --soft 780411da3b47117270c0e3a8d5dcfd11d28d04a4
$ git status &amp;amp;&amp;amp; git ls-files -s
On branch master
Changes to be committed:
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)
modified: reset_lifecycle_file
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above executes a &amp;ldquo;soft reset&amp;rdquo; and also invokes the git status and git ls-files combo command, which outputs the state of the repository. We can examine the repo state output and note some interesting observations. First, git status indicates there are modifications to reset_lifecycle_file and highlights them indicating they are changes staged for the next commit. Second, the git ls-files input indicates that the Staging Index has not changed and retains the SHA 67cc52710639e5da6b515416fd779d0741e3762e we had earlier.&lt;/p&gt;

&lt;p&gt;首先，根据状态输出，我们能够看到对 reset_lifecycle_file 文件的修改仍然存在，仍然在等着被提交。其次，根据暂存索引输出，我们发现 reset_lifecycle_file 的SHA也没有变化。&lt;/p&gt;

&lt;p&gt;To further clarify what has happened in this reset let us examine the git log:&lt;/p&gt;

&lt;p&gt;为了更进一步地解释执行 &amp;ndash;soft 发生了什么，我们执行 git log 查看一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git log
commit 780411da3b47117270c0e3a8d5dcfd11d28d04a4
Author: bitbucket 
Date: Thu Nov 30 16:50:39 2017 -0800
initial commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The log output now shows that there is a single commit in the Commit History. This helps to clearly illustrate what &amp;ndash;soft has done. As with all git reset invocations, the first action reset takes is to reset the commit tree. Our previous examples with &amp;ndash;hard and &amp;ndash;mixed have both been against the HEAD and have not moved the Commit Tree back in time. During a soft reset, this is all that happens.&lt;/p&gt;

&lt;p&gt;日志输出显示了这确实是第一次提交历史。与所有 git reset 调用一样，重置的第一个操作是重置提交树。我们前面的例子 &amp;ndash;hard 和 &amp;ndash;mixed 都是针对HEAD的，没有及时地将提交树向后移动。但是在 &amp;ndash;soft 中，这些都做过了。&lt;/p&gt;

&lt;p&gt;This may then be confusing as to why git status indicates there are modified files. &amp;ndash;soft does not touch the Staging Index, so the updates to our Staging Index followed us back in time through the commit history. This can be confirmed by the output of git ls-files -s showing that the SHA for reset_lifecycle_file is unchanged. As a reminder, git status does not show the state of &amp;lsquo;the three trees&amp;rsquo;, it essentially shows a diff between them. In this case, it is displaying that the Staging Index is ahead of the changes in the Commit History as if we have already staged them.&lt;/p&gt;

&lt;p&gt;为什么 git status 表明存在修改过的文件？这可能会让人感到困惑。因为 &amp;ndash;soft 没有触及暂存索引，因此对暂存索引的更新在提交历史中一直跟随我们。这可以通过git ls-files -s的输出得到确认，其中 reset_lifecycle_file 的SHA没有改变。提醒一下，git status 并不显示“三棵树”的状态，它实际上显示了它们之间的差异。在本例中，它将显示暂存索引先于提交历史记录中的更改，就好像我们已经暂存了它们一样。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>call, apply, bind</title>
      <link>https://hueralin.github.io/2019/callapplybind/</link>
      <pubDate>Sun, 06 Oct 2019 13:27:32 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/callapplybind/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;call apply bind 这三个函数的作用都是将一个函数的this指向另一个对象，使得该对象可以调用这个它自身没有的函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;func-call-thisobj-arg1-arg2&#34;&gt;Func.call(thisObj, [arg1,arg2,&amp;hellip;.])&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;thisObj&lt;/strong&gt; 作为Func内部的this，它的取值有四种情况：&lt;br /&gt;
1. null/undefined/不传 Func的this &amp;mdash;-&amp;gt; window&lt;br /&gt;
2. 函数名 Func的this &amp;mdash;-&amp;gt; 该函数的引用&lt;br /&gt;
3. 数值/字符串/布尔值 Func的this &amp;mdash;-&amp;gt; Number/String/Boolean&lt;br /&gt;
4. 对象 Func的this &amp;mdash;-&amp;gt; 对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Func(){
    console.log(this)
}
function Test(){console.log(&#39;Test&#39;)}
var obj = { name: &#39;huer&#39; }
Func.call() // window
Func.call(null) // window
Func.call(undefined) // window
Func.call(Test) // Test(){console.log(&#39;Test&#39;)}
Func.call(666) // Number {666}
Func.call(&#39;666&#39;) // String {&amp;quot;666&amp;quot;}
Func.call(true) // Boolean {true}
Func.call(obj)  // {name: &amp;quot;huer&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三个函数除了由上面的功能外，还有一个功能。还能给对象添加新属性，例如在继承中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person(name, age) {
    this.name = name;
    this.age = age; 
}
let dog = {}
Person.call(dog, &#39;wangcai&#39;, 5);
console.log(dog);   // {name: &amp;quot;wangcai&amp;quot;, age: 5}
// dog调用了Person构造函数，于是Person函数中的this指向dog，然后给dog添加了两个属性。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;func-apply-thisobj-args&#34;&gt;Func.apply(thisObj, [args[]])&lt;/h3&gt;

&lt;p&gt;功能和call一样，只不过第二个参数是一个参数数组（或伪数组，如arguments），而不是参数列表。&lt;/p&gt;

&lt;h3 id=&#34;func-bind-thisobj-arg1-arg2&#34;&gt;Func.bind(thisObj, [arg1, arg2&amp;hellip;])&lt;/h3&gt;

&lt;p&gt;功能和上面两个一样，只不过该函数并不会立即执行Func，而是返回一个绑定后的函数。它常用于事件绑定中，因为事件绑定要求传入函数引用而不是函数的执行结果，bind的其他参数和call一样，是一个参数列表。&lt;/p&gt;

&lt;p&gt;bind函数返回一个原函数的拷贝，并拥有指定的this值和初始参数。&lt;/p&gt;

&lt;p&gt;bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;bind函数用法1：创建一个绑定函数。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 9;
var module = {
  x: 81,
  getX: function() { return this.x; }
};

module.getX(); // 81

var retrieveX = module.getX;
retrieveX();   
// 返回9 - 因为函数是在全局作用域中调用的

// 创建一个新函数，把 &#39;this&#39; 绑定到 module 对象
var boundGetX = retrieveX.bind(module);
boundGetX(); // 81
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;bind函数用法2：创建一个偏函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 偏函数，即拥有预设参数的函数
// 只要将这些参数（如果有的话）作为bind()的参数写在this后面。
// 当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。

function sum(a, b) {
    return a + b;
}
function toArr() {
    return Array.prototype.slice.call(arguments);
}

let FuncA = sum.bind(null, 666);    // 将666作为第一个参数的预设
console.log(FuncA(10)); // 676
console.log(FuncA(10, 20)); // 676, 第二个参数实际上被作为第三个参数而忽略掉

let FuncB = toArr.bind(null, 6, 7, 8);  // 将6，7，8作为预设参数
console.log(FuncB());   // [6, 7, 8]
console.log(FuncB(9, 10));   // [6, 7, 8, 9, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bind函数用法3-配合settimeout&#34;&gt;bind函数用法3: 配合setTimeout&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// setTimeout实际上是window.setTimeout
// 下面计时器的执行过程是，3秒后，将匿名函数放进事件队列，事件循环到它时执行
// 这个执行和 function A(){xxx} A()一样，即在全局环境下执行匿名函数，里面的this指向window
setTimeout(function() {
    console.log(&#39;this is: &#39;, this)
}, 3000)

// 比如有个绘制函数
let canvas = {
    render: function() {
        this.update();
        this.draw();
    }
    update: function(){xxx}
    draw: function(){xxx}
}

window.setInterval(canvas.render, 1000 / 60)
// 这样的话，render函数里的this很容易指向window，导致报错！

// 所以我们可以显式地将this绑定到canvas
window.setInterval(canvas.render.bind(canvas), 1000);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>setState</title>
      <link>https://hueralin.github.io/2019/state-async/</link>
      <pubDate>Fri, 04 Oct 2019 23:57:30 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/state-async/</guid>
      <description>

&lt;h3 id=&#34;state机制&#34;&gt;State机制&lt;/h3&gt;

&lt;p&gt;setState函数是React管理组件状态的一种方法，修改组件的状态时必须使用该方法，而不能直接在this.state上赋值。但是，如果我们在调用完setState之后直接去访问State时，拿到的是修改前的值。也就是说，setState并不保证“同步执行”。&lt;/p&gt;

&lt;p&gt;如果在一次操作中多次调用setState，那么React会将这几次操作暂存起来，然后统一集中合并，根据合并后的结果去计算新的虚拟DOM，最后执行渲染。　　&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 初始 count = 0
this.setState({ count: this.state.count + 1 })
console.log(this.state.count)       // 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么如果和解决上面的问题呢？&amp;mdash;&amp;ndash;回调函数&lt;/p&gt;

&lt;p&gt;setState函数的参数有两个，第一个参数是对象，第二个参数是回调函数。回调函数在State合并更新完后才会被调用，所以可以拿到更新后的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;this.setState({
    count: this.state.count + 1
}, () =&amp;gt; {
    console.log(this.state.count)   // count = 1
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面来看另一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;this.setState({ count: this.state.count + 1 })
this.setState({ count: this.state.count + 1 })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该会怎么执行呢？结果是2么？不对！结果是1。&lt;br /&gt;
上面提到过，多次调用setState会被合并为一次操作。上面的代码类似于下面这段：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.assign(state, {count: state.count+1}, {count: state.count+1})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;都是操作的count，合并时只执行最后一个。&lt;/p&gt;

&lt;p&gt;那么如何做到增加两次呢？其实setState函数的第一个参数也可以为函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;this.setState((preState, props) =&amp;gt; {count: preState.count + 1})
this.setState((preState, props) =&amp;gt; {count: preState.count + 1})
console.log(this.state.count)   // 仍然是10，但页面渲染的是2

// preState为之前的State，props为State更新执行瞬间的props
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，每次调用都是在上一次state的基础上修改。&lt;/p&gt;

&lt;p&gt;上面代码相当于:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[{increment: 1}, {increment: 1}, {increment: 1}].reduce((preState, props) =&amp;gt; {
    count: preState.count + props.increment
})
// 累加器
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实，React的内部会维护一个State的更新队列，会将当前所有的State修改操作都推入队列中，然后集中合并处理，再调用回调函数，最后计算新的虚拟DOM，执行渲染。&lt;/p&gt;

&lt;h3 id=&#34;setstate真的是异步的么-非也&#34;&gt;setState真的是异步的么？非也！&lt;/h3&gt;

&lt;p&gt;React为了实现跨平台，保证兼容性，内部封装了自己的事件机制，来代替原生事件。React内部会维护一个isBatchingUpdate的标识，来决定是同步修改还是异步修改。在这些合成事件和生命周期函数里执行setState的时候，React将isBatchingUpdate设置为true，即批处理修改，也就是说异步修改。而在原生事和setTimeout函数里面使用setState的时候则是同步修改。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sisterAn/blog/issues/26&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>技术分享之Redux思想</title>
      <link>https://hueralin.github.io/2019/share/</link>
      <pubDate>Wed, 18 Sep 2019 13:40:10 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/share/</guid>
      <description>

&lt;h1 id=&#34;redux&#34;&gt;Redux&lt;/h1&gt;

&lt;h3 id=&#34;普通的状态管理&#34;&gt;普通的状态管理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 状态
let state = {
    // 计数
    count: 0
}···
// 修改状态
state.count = 1
// 获取状态
console.log(state.count)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：状态改变，依赖状态的地方得不到通知&lt;/p&gt;

&lt;h3 id=&#34;带有发布订阅的状态管理&#34;&gt;带有发布订阅的状态管理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 状态
let state = {
    // 计数
    count: 0
}
// 集中管理订阅
let listeners = []
// 订阅函数
function subscribe(callback) {
    listeners.push(callback)
}
// 修改状态的函数
function changState(newVal) {
    state.count = newVal
    for(let i=0;i&amp;lt;listeners.length;i++){
        listeners[i]()
    }
}
// main
subscribe(() =&amp;gt; {
    console.log(&#39;count&#39;, state.count)
})
changState(1)  // 1
changState(2)  // 2
changState(3)  // 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：只对count（即单个状态）有效，应将公共操作封装起来。&lt;/p&gt;

&lt;h3 id=&#34;封装后的版本&#34;&gt;封装后的版本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//  创建store的函数
function createStore(initState) {
    let state = initState || {}
    let listeners = []
    // 订阅函数
    function subscribe(callback) {
        listeners.push(callback)
    }
    // 修改状态的函数
    function changeState(newState) {
        state = newState
        for(let i=0;i&amp;lt;listeners.length;i++){
            listeners[i]()
        }
    }
    //  获取状态
    function getState() {
        return state
    }
    // 返回一个store对象
    return {
        subscribe,
        changeState,
        getState
    }
}
// main
let initState = {
    count: 0,
    user: {
        name: &#39;huer&#39;,
        age: 20,
        sex: &#39;male&#39;
    }
}
let store = createStore(initState)
store.subscribe(() =&amp;gt; {
    let count = store.getState().count
    console.log(`count: ${count}`)
})
store.subscribe(() =&amp;gt; {
    let user = store.getState().user
    console.log(`name: ${user.name}`)
})
store.changeState(Object.assign({}, store.getState(), {count: 1}))
store.changeState(Object.assign({}, store.getState(), {user: &#39;malin&#39;}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：state可以被随便改，没有约束。&lt;/p&gt;

&lt;h3 id=&#34;带计划的状态管理&#34;&gt;带计划的状态管理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//  以计数器为例
/*
    {
        type: &#39;ADD&#39;,
        count: 2
    }
*/
// 计划函数 plan
function plan(state = {}, action) {
    switch(action.type) {
        case &#39;ADD&#39;: return Object.assign({}, state, {count: state.count + 1});break;
        case &#39;SUB&#39;: return Object.assign({}, state, {count: state.count - 1});break;
        default: return state;
    }
}
//  改进封装后的changeState函数
function changeState(action) {
    // 按计划修改状态
    state = plan(state, action)
    for(let i=0;i&amp;lt;listeners.length;i++){
        listeners[i]()
    }
}
// main
// 自增
store.changeState({
  type: &#39;ADD&#39;
})
// 自减
store.changeState({
  type: &#39;SUB&#39;
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过Action，使得状态变化的结果可预测。&lt;/p&gt;

&lt;p&gt;changeState &amp;ndash;&amp;gt; dispatch&lt;br /&gt;
plan &amp;mdash;&amp;gt; Reducer&lt;/p&gt;

&lt;p&gt;Store的角色是整个应用的数据存储中心，集中大部分页面需要的状态数据。&lt;/p&gt;

&lt;p&gt;Redux工作流程：用户通过界面组件 触发Action，携带Store中的旧State与Action 流向Reducer, Reducer返回新的state，并更新界面。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hueralin/Rimage&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Rimage&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zmage.caldis.me/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Zmage&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP流量控制、拥塞控制</title>
      <link>https://hueralin.github.io/2019/tcpys/</link>
      <pubDate>Mon, 09 Sep 2019 12:51:57 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/tcpys/</guid>
      <description>

&lt;p&gt;计算机网络推荐书籍：计算机网络（谢希仁）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/37379780&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;TCP流量控制、拥塞控制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在前端面试中关于计算机网络的知识多半是HTTP协议、TCP/IP协议，拥塞控制之类的。昨天看了几篇关于拥塞控制的文章，现来做一些总结。&lt;/p&gt;

&lt;h2 id=&#34;tcp流量控制&#34;&gt;TCP流量控制&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;一、 流量控制的原因&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;双方在通信时会涉及到通信速率的问题，即发送速率和处理速率，这两个速率往往是不一样的。如果发送方的发送速率太快，接收方来不及处理，就会将报文放进缓存，若发送方仍不控制发送速率，那么缓存终会爆满，导致丢包，浪费网络资源，所以应该对发送方的发送速率进行控制，使发送方和接收方达到一种动态平衡。&lt;/p&gt;

&lt;p&gt;流量控制，即控制发送方的发送速率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、滑动窗口&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;滑动窗口协议：TCP协议中的一种应用，用于网络数据传输中的流量控制。&lt;/p&gt;

&lt;p&gt;该协议允许发送方在停止并等待确认报文前发送多个数据，不必每发完一段数据就定下来等待确认，提高网络的吞吐量，所以TCP定义了一个&lt;strong&gt;滑动窗口协议&lt;/strong&gt;，滑动窗口包括&lt;strong&gt;发送窗口&lt;/strong&gt;和&lt;strong&gt;接受窗口&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关概念&lt;/strong&gt;&lt;br /&gt;
1. 窗口：一段可以被发送者连续发送的字节序列范围。&lt;br /&gt;
2. 滑动：“窗口”的大小会随着发送过程变化，这种变化是在字节序列上按顺序滑动的。&lt;/p&gt;

&lt;p&gt;因为TCP协议是全双工协议，所以双方都有一个&lt;strong&gt;发送缓冲区&lt;/strong&gt;和&lt;strong&gt;接收缓冲区&lt;/strong&gt;。&lt;br /&gt;
发送缓冲区接收来自应用层的数据（一长条字节流？），而发送窗口框住了其中的一部分（前面说了，窗口其实是一段范围）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;发送缓存区&lt;/strong&gt;相关的四个概念：&lt;br /&gt;
1. 已发送并受到确认&lt;br /&gt;
2. 已发送但未收到确认&lt;br /&gt;
3. 允许发送但未发送&lt;br /&gt;
4. 不允许发送&lt;/p&gt;

&lt;p&gt;其中，允许发送的数据都在发送窗口内。每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送。&lt;/p&gt;

&lt;p&gt;下面，我借由计算机网络（谢希仁）中的图片来讲解一下过程(后来发现copy率达到99.9%)：&lt;br /&gt;
A B 双方在建立TCP连接的时候，B就已经向A给出了自己的窗口值，发送方A会根据这个值来构造自己的发送窗口。&lt;br /&gt;
&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp01.png&#34; alt=&#34;根据B给出的窗口值，A构造自己的发送窗口&#34; /&gt;&lt;br /&gt;
发送窗口表示：在没有收到B的确认情况下，A可以连续把发送窗口中的数据都发送出去。凡是发送过的数据在未收到确认前都应留在发送窗口内，以便超时重传。&lt;/p&gt;

&lt;p&gt;发送窗口的位置由前沿和后沿的位置来确定：&lt;br /&gt;
1. 前沿：不动或前移。不动，可能是因为没有收到确认，或收到了确认但接受窗口缩小了。&lt;br /&gt;
2. 后沿：不动或前移。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp02.png&#34; alt=&#34;A发送了11个字节的数据&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A发送了11个字节的数据，但未收到新的确认，所以前沿后沿都不变，即发送窗口的位置不变。&lt;br /&gt;
看B的接收窗口，32 33 未按序到达，因为接收方发送的确认号ack是由按序到达数据的最高序号决定的，所以B返回的确认号仍然是31。导致了A的发送窗口不变。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;描述一个发送窗口的状态&lt;/strong&gt;需要三个指针：p1、p2、p3。&lt;br /&gt;
1. 小于p1：已发送且已收到确认的部分&lt;br /&gt;
2. 大于p3：不允许发送的部分&lt;br /&gt;
3. p3 - p1：发送窗口&lt;br /&gt;
4. p2 - p1：已发送但未收到确认的部分&lt;br /&gt;
5. p3 - p2：允许发送但未发送的部分，又叫“可用窗口”、“有效窗口”&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp03.png&#34; alt=&#34;A收到了新的确认号，发送窗口向前滑动&#34; /&gt;&lt;/p&gt;

&lt;p&gt;B 收到了31，然后返回确认号34，表明31 32 33 都收到了，且已交付主机。A收到确认号后，发送窗口前移，后沿前移3位指向34。指针p2不动，可用窗口变大，可发送42-53的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp04.png&#34; alt=&#34;可用窗口内的数据已全部发送，但未收到确认&#34; /&gt;&lt;br /&gt;
42-53的数据都被发送了出去，p2指针与p3指针重合，但是没有收到确认，使得可用窗口为0，A不能再发送数据，必须等到B的确认。但是B发送的确认可能在网络中延时了，没有及时到达，A就会一直等，B也会一直等待A发送数据，造成死锁。所以A有一个超时计时器机制，一段时间后没有收到B的确认，会自动重传这部分数据并重置超时计时器，直到收到B的确认为止。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、如何控制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;流量控制主要依靠滑动窗口来实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;流量控制即接收方B向发送方A传递消息，使其不要发送太快～，是一种端到端的控制。利用B返回的报文中的接收窗口的大小来控制A的发送窗口大小。rwnd: 接收窗口&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp05.png&#34; alt=&#34;利用可变窗口进行拥塞控制&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图我们也可以看到，发送窗口是连续的一段一段的发送数据，比如上面连续发送了3段数据后才返回了一个ack。&lt;/p&gt;

&lt;p&gt;B的缓存区也会有满的情况，当缓存区满了后会发送rwnd=0通知A停止发送数据。等一段时间后B的缓存区有了空会发送非0的rwnd给A，但是如果这个报文中途丢失了，A一直收不到，双方一直在互相等待，造成死锁。所以TCP引入了持续计时器，即当A收到了0接收窗口通知时，启动该计时器，时间到了就会发送一个1字节的探测报文，接收方会回应自己的接收窗口大小，若仍为0，则重设计时器，继续等待。&lt;/p&gt;

&lt;h2 id=&#34;tcp拥塞控制&#34;&gt;TCP拥塞控制&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp06.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关概念：&lt;/strong&gt;&lt;br /&gt;
1. 慢开始门限：控制使用慢开始算法还是拥塞避免算法&lt;br /&gt;
2. 拥塞窗口&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关算法&lt;/strong&gt;&lt;br /&gt;
1. 慢开始  2. 拥塞避免  3. 快重传  4. 快恢复&lt;/p&gt;

&lt;p&gt;发送方维持一个叫做“拥塞窗口”的状态变量，其大小取决于网络的拥塞程度，且会动态变化。发送方的发送窗口等于拥塞窗口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;发送方控制拥塞窗口的原则&lt;/strong&gt;：当网络没有发生拥塞时，我可以让窗口再增大一些，发出更多的分组。若出现了拥塞，就让拥塞窗口减小一些，缓解拥塞。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网络中出现拥塞的依据&lt;/strong&gt;：分组丢失/超时。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>字节跳动面试题</title>
      <link>https://hueralin.github.io/2019/bytedance/</link>
      <pubDate>Wed, 04 Sep 2019 16:18:24 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/bytedance/</guid>
      <description>

&lt;h3 id=&#34;实现sleep函数-将程序挂起一段时间-阻塞运行&#34;&gt;实现sleep函数（将程序挂起一段时间，阻塞运行）&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;我能想到的方法就是ES6的 async/await
function my_sleep (time) {
    return new Promise((resolve) =&amp;gt; {
        setTimeout(() =&amp;gt; {
            resolve()
        }, time)
    })
}
async function main() {
    console.log(&#39;start&#39;)
    await my_sleep(5000)
    console.log(&#39;end&#39;)
}
main()
网上还有一种解法，利用循环+Date()，不断的循环，检测当前时间是否超出了间隔时间  
原理就是一直在执行同步任务，阻塞下面同步任务的执行
function my_sleep (time) {
    let start = new Date().getTime()    // 一串长数字
    let end = start + time  // time是毫秒
    while(new Date().getTime() &amp;lt;= end){}
}
console.log(&#39;start&#39;)
my_sleep(5000)
console.log(&#39;end&#39;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>用友笔试题</title>
      <link>https://hueralin.github.io/2019/yongyou/</link>
      <pubDate>Wed, 04 Sep 2019 15:07:51 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/yongyou/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;21题&lt;br /&gt;
css 中经常有类似 background-image 这种通过 - 连接的字符，通过 javascript 设置样式的时候需要将这种样式转换成 backgroundImage 驼峰格式，请完成此转换功能。&lt;br /&gt;
输入：-webkit-background-image&lt;br /&gt;
输出：webkitBackgroundImage&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;解法一、  
思路：将输入按照‘-’分开，得到一个数组，例如：[&#39;&#39;, &#39;webkit&#39;, &#39;background&#39;, &#39;image&#39;]  
然后从第三个元素开始，将首字母变大写（注意字符串是不可变的）
function func(pre){
    let splitArr = pre.split(&#39;-&#39;)
    for(let i=2;i&amp;lt;splitArr.length;i++){
        splitArr[i] = splitArr[i][0].toUpperCase() + splitArr[i].slice(1)
    }
    return splitArr.join(&#39;&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;解法二、  
思路：
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;22题&lt;br /&gt;
请实现一个简单的事件机制，能够实现对事件的触发和监听。
如：EventEmitter.on(); EventEmitter.trigger();&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;思路：封装一个对象，该对象有两个方法：on、trigger。on方法接收两个参数，事件名和回调函数，如果一个事件可以绑定过个回调，可以考虑使用数组。trigger方法接受一个参数，即事件名，拿到指定事件，将该事件下的所有回调函数执行一遍。
这种写法只是实现了时间的触发和更新，并没有将事件绑定到某个元素上。
function EventEmitter () {
    let eventObj = {}

    function on (eventName, callback) {
        if (!eventObj[eventName]) {
            eventObj[eventName] = []
        }
        eventObj[eventName].push(callback)
    }

    function trigger (eventName) {
        if (!eventObj[eventName]) {
            return
        }
        for(let i=0;i&amp;lt;eventObj[eventName].length;i++){
            eventObj[eventName][i]()
        }
    }

    return {
        on: on,
        trigger: trigger
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>节流和防抖</title>
      <link>https://hueralin.github.io/2019/debounceandthrottle/</link>
      <pubDate>Tue, 03 Sep 2019 17:43:42 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/debounceandthrottle/</guid>
      <description>

&lt;h3 id=&#34;lodash-防抖源码解读&#34;&gt;lodash 防抖源码解读&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function debounce(func, wait, options) {
  let lastArgs,
    lastThis,
    maxWait,
    result,
    timerId,
    lastCallTime

  let lastInvokeTime = 0
  let leading = false
  let maxing = false
  let trailing = true

  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.
  const useRAF = (!wait &amp;amp;&amp;amp; wait !== 0 &amp;amp;&amp;amp; typeof root.requestAnimationFrame === &#39;function&#39;)

  if (typeof func !== &#39;function&#39;) {
    throw new TypeError(&#39;Expected a function&#39;)
  }
  wait = +wait || 0
  if (isObject(options)) {
    leading = !!options.leading
    maxing = &#39;maxWait&#39; in options
    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait
    trailing = &#39;trailing&#39; in options ? !!options.trailing : trailing
  }

  // 调用函数
  function invokeFunc(time) {
    const args = lastArgs
    const thisArg = lastThis

    lastArgs = lastThis = undefined
    lastInvokeTime = time
    result = func.apply(thisArg, args)
    return result
  }

  function startTimer(pendingFunc, wait) {
    if (useRAF) {
      root.cancelAnimationFrame(timerId)
      return root.requestAnimationFrame(pendingFunc)
    }
    return setTimeout(pendingFunc, wait)
  }

  function cancelTimer(id) {
    if (useRAF) {
      return root.cancelAnimationFrame(id)
    }
    clearTimeout(id)
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time
    // Start the timer for the trailing edge.
    timerId = startTimer(timerExpired, wait)
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result
  }

  function remainingWait(time) {
    const timeSinceLastCall = time - lastCallTime
    const timeSinceLastInvoke = time - lastInvokeTime
    const timeWaiting = wait - timeSinceLastCall

    return maxing
      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting
  }

  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime
    const timeSinceLastInvoke = time - lastInvokeTime

    // Either this is the first call, activity has stopped and we&#39;re at the
    // trailing edge, the system time has gone backwards and we&#39;re treating
    // it as the trailing edge, or we&#39;ve hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall &amp;gt;= wait) ||
      (timeSinceLastCall &amp;lt; 0) || (maxing &amp;amp;&amp;amp; timeSinceLastInvoke &amp;gt;= maxWait))
  }

  function timerExpired() {
    const time = Date.now()
    if (shouldInvoke(time)) {
      return trailingEdge(time)
    }
    // Restart the timer.
    timerId = startTimer(timerExpired, remainingWait(time))
  }

  function trailingEdge(time) {
    timerId = undefined

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing &amp;amp;&amp;amp; lastArgs) {
      return invokeFunc(time)
    }
    lastArgs = lastThis = undefined
    return result
  }

  function cancel() {
    if (timerId !== undefined) {
      cancelTimer(timerId)
    }
    lastInvokeTime = 0
    lastArgs = lastCallTime = lastThis = timerId = undefined
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(Date.now())
  }

  function pending() {
    return timerId !== undefined
  }

  function debounced(...args) {
    const time = Date.now()
    const isInvoking = shouldInvoke(time)

    lastArgs = args
    lastThis = this
    lastCallTime = time

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime)
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = startTimer(timerExpired, wait)
        return invokeFunc(lastCallTime)
      }
    }
    if (timerId === undefined) {
      timerId = startTimer(timerExpired, wait)
    }
    return result
  }
  debounced.cancel = cancel
  debounced.flush = flush
  debounced.pending = pending
  return debounced
}

export default debounce
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JS 事件循环</title>
      <link>https://hueralin.github.io/2019/eventloop/</link>
      <pubDate>Mon, 02 Sep 2019 18:56:56 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/eventloop/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;MDN 事件循环&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://html.spec.whatwg.org/multipage/webappapis.html#event-loops&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;详细的不知道该给这个链接命什么名好!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ahhhhhh, 这JS学的，不断刷新世界观~&lt;/p&gt;

&lt;p&gt;事件循环可谓是JS中的一大重点，如果说之前的&lt;a href=&#34;http://localhost:1313/2019/jsec/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS执行环境&lt;/a&gt;从微观角度上说明了函数内部的执行原理，那么事件循环则从宏观角度上说明了整个JS代码的执行情况。&lt;/p&gt;

&lt;p&gt;事件循环中的关键概念：执行栈、任务源、任务队列&lt;/p&gt;

&lt;h3 id=&#34;执行栈&#34;&gt;执行栈&lt;/h3&gt;

&lt;p&gt;由于JS是单线程的，一定时间内只能执行一个函数，所以这些函数就得按照一定的顺序排好队，但它并不是一个队列，因为函数调用会涉及到作用域链的问题，函数调用之间有着一定的嵌套关系，所以栈结构比较合适。那么由函数调用组成的栈，也被称为 “执行栈” ，函数被调用时压入栈，执行完毕弹出栈。结合 &lt;a href=&#34;http://localhost:1313/2019/jsec/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS执行环境&lt;/a&gt; 中所讲的内容，函数调用栈中的每一个帧都是一个执行环境，执行环境里面包含着变量对象（函数被调用时才会有）。&lt;/p&gt;

&lt;h3 id=&#34;任务源&#34;&gt;任务源&lt;/h3&gt;

&lt;p&gt;这个高大上的名词可能没见过，但是它本身却很常见。顾名思义，任务源就是分发任务的源头，绝大部分是异步任务。分发异步任务的源头有哪些呢？setTimeout ！setInterval ! promise !等等都是任务源，这些函数在被执行的时候都是立即执行的，但是它们所分发的任务需要在特定的情况下才会被执行，而这些特定的环境则需要事件循环机制来处理。任务源所分发的任务才会被放进任务队列中。&lt;/p&gt;

&lt;h3 id=&#34;任务队列&#34;&gt;任务队列&lt;/h3&gt;

&lt;p&gt;MDN 上叫“消息队列”，好像是从前的说法，讲的有些笼统。新标准下给了它们新的名字：任务队列，给异步任务做了更细致的划分。任务队列分为：“宏任务”和“微任务”。
宏任务包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI渲染。微任务包括：process.nextTick，Promise, Object.observe(已废弃), MutationObserver(html5新特性)。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;推荐两篇博客：&lt;br /&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/26229293&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;深入浅出JS事件循环机制（上）&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/26238030&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;深入浅出JS事件循环机制（下）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上面两篇博客涉及到了&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;WebpAPIs&lt;/a&gt;，文中给出了三种常见的WebAPIs，DOM相关、网络相关、定时器相关。&lt;/p&gt;

&lt;p&gt;下面用一个简单的例子来说明：&lt;br /&gt;
 &lt;img src=&#34;https://hueralin.github.io/img/posts/eventloop01.png&#34; alt=&#34;代码执行前&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在开始执行JS代码，main()入栈，执行到console.log()，log函数入栈，执行log函数，控制台输出&amp;rsquo;Hello world!&amp;rsquo;
 &lt;img src=&#34;https://hueralin.github.io/img/posts/eventloop02.png&#34; alt=&#34;main函数入栈，log函数入栈&#34; /&gt;&lt;/p&gt;

&lt;p&gt;log函数出栈，setTimeout函数入栈，执行栈发现setTimeout函数是WebAPIs，于是将setTimeout所分发的任务交由浏览器内核对应的timer模块处理，然后将setTimeout函数出栈。&lt;br /&gt;
 &lt;img src=&#34;https://hueralin.github.io/img/posts/eventloop03.png&#34; alt=&#34;setTimeout函数入栈&#34; /&gt;&lt;/p&gt;

&lt;p&gt;setTimeout函数出栈，console.log(&amp;lsquo;end&amp;rsquo;)入栈，执行完毕后控制台输出&amp;rsquo;end&amp;rsquo;，然后console.log()函数出栈，若timer模块计时结束就将回调函数放进任务队列。&lt;br /&gt;
 &lt;img src=&#34;https://hueralin.github.io/img/posts/eventloop04.png&#34; alt=&#34;console.log(&#39;end&#39;)入栈&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后执行栈中还剩下main()，main函数出栈，此时执行栈为空。开始检查任务队列，队列中有任务，就拿到执行栈中去执行。再依次出栈。&lt;br /&gt;
 &lt;img src=&#34;https://hueralin.github.io/img/posts/eventloop05.png&#34; alt=&#34;匿名回调函数入栈，console.log入栈&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个例子中只使用了setTimeout，是WebAPIs中的一个。其他的WebAPIs例如ajax请求，DOM等都由浏览器内核中不同的模块去处理。结合前面讲的任务源，来自不同任务源的任务会被放进不同的任务队列。即setTimeout分发的任务会进入setTimeout任务队列（因为可能会有多个setTimeout被调用），诸如setTimeout、setInterval等又同属于“宏任务”，而像promise等则属于“微任务”。既然有“宏任务”和“微任务”之分，那么当执行任务队列中的任务时先去哪个呢？下面来讲一下时间循环的具体流程。&lt;/p&gt;

&lt;h3 id=&#34;事件循环的流程&#34;&gt;事件循环的流程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;从script整体代码开始，执行同步任务。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当碰到异步任务时，会将异步任务交由对应的浏览器内核模块去执行，执行完毕后将其回调函数（即事件处理程序）放到对应的任务队列中，等待被执行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;第二步并不会阻塞下面同步代码的执行。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;当执行栈为空时，就会优先去检查“微任务”，“微任务”中有“process.nexttick任务队列”、“promise队列”等，前者优先级大于后者，拿出队首任务放到执行栈中执行，执行完出栈，继续拿下一个“微任务”，直到所有的“微任务队列”清空。&lt;strong&gt;此时，一轮循环结束！&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;下一轮循环从“宏任务”开始，“宏任务”包括“setTimeout任务队列”、“setInterval任务队列”等，拿出队首的宏任务放进执行栈中执行，执行完出栈。&lt;strong&gt;注意！当一个“宏任务”又创建了一个“微任务”的话，则会将该“宏任务”所在的“宏任务队列”清空后，再转去处理微任务，且微任务被清空后，才会执行下一个“宏任务队列”，也就是说，“微任务”可插队！。&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;事件循环机制会一直检测执行栈、宏任务队列、微任务队列，不断循环执行。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;例题&#34;&gt;例题&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;(function test() {
    setTimeout(function() {console.log(4)}, 0);
    new Promise(function executor(resolve) {
        console.log(1);
        for( var i=0 ; i&amp;lt;10000 ; i++ ) {
            i == 9999 &amp;amp;&amp;amp; resolve();
        }
        console.log(2);
    }).then(function() {
        console.log(5);
    });
    console.log(3);
})()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有更复杂的例题&lt;a href=&#34;https://www.jianshu.com/p/12b9f73c5a4f&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这波能反杀&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;q-a&#34;&gt;Q&amp;amp;A&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Q：&lt;/strong&gt; setTimeout又分发了一个setTimeout，会在当前循环中执行么？&lt;br /&gt;
&lt;strong&gt;A：&lt;/strong&gt; 不会，宏任务不会插队，新分发的宏任务会等到下一次循环。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(&#39;start&#39;)
setTimeout(() =&amp;gt; {
	console.log(&#39;out&#39;)
  	setTimeout(() =&amp;gt; {
    	console.log(&#39;in&#39;)
    }, 0)       // 最早1s后放进setTimeout队列
}, 1000)        // 最早1s后放进setTimeout队列

new Promise((resolve) =&amp;gt; {
	console.log(&#39;promise&#39;)
  	for(var i = 0;i&amp;lt;100;i++){
    	i == 99 &amp;amp;&amp;amp; resolve()
    }
}).then(() =&amp;gt; {
	console.log(&#39;then&#39;)
})
setInterval(() =&amp;gt; {
	console.log(new Date().toString())
}, 1000)       // 最早1s后放进setInterval队列
console.log(&#39;end&#39;)

/*
start
promise
end
then
out
Tue Sep 03 2019 16:14:57 GMT+0800 (中国标准时间)
in
*/
// 可以看到，setTimeout任务队列清空后执行的是setInterval任务队列，即使中途插入了新的setTimeout也没有被执行，而是老老实实的等下个循环。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在其他博文还看到另一个说法，就是在任务进入执行栈前会判断是同步任务还是异步任务，是异步任务的话，会有一个事件注册表的东西，来给相应的事件注册回调函数。&lt;/p&gt;

&lt;p&gt;回更!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>狐耳的技术栈</title>
      <link>https://hueralin.github.io/2019/stack/</link>
      <pubDate>Mon, 02 Sep 2019 17:08:32 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/stack/</guid>
      <description>

&lt;h3 id=&#34;javascript&#34;&gt;JavaScript&lt;/h3&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://hueralin.github.io/2019/closure/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS闭包&lt;/a&gt;&lt;br /&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://hueralin.github.io/2019/jsec/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JS执行环境/AO/VO&lt;/a&gt;&lt;br /&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 事件循环&lt;br /&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; async/await&lt;br /&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;html&#34;&gt;HTML&lt;/h3&gt;

&lt;h3 id=&#34;css&#34;&gt;CSS&lt;/h3&gt;

&lt;h3 id=&#34;性能优化手段&#34;&gt;性能优化手段&lt;/h3&gt;

&lt;h3 id=&#34;webpack&#34;&gt;webpack&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>JS执行环境，作用域链，变量对象/活动对象</title>
      <link>https://hueralin.github.io/2019/jsec/</link>
      <pubDate>Mon, 02 Sep 2019 11:20:42 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/jsec/</guid>
      <description>

&lt;p&gt;JS的重点内容之一，虽然不会在面试题中直接那么问，多半给你出一段代码，看输出什么。&lt;/p&gt;

&lt;p&gt;我觉得了解了这部分内容，能让我们对整个JS的执行流程有个详细、准确地认识，在面对工作中的一些错误也能快速且正确的排错。&lt;/p&gt;

&lt;h3 id=&#34;js执行环境&#34;&gt;JS执行环境&lt;/h3&gt;

&lt;p&gt;JS的执行环境又被称为执行上下文（Execution context），简称EC。顾名思义，JS执行环境就是JS执行时才会存在的环境，常见的执行环境有两种：全局执行环境和函数执行环境。当JS代码执行的时候，我们会进入不同的执行环境，这些执行环境会构成一个执行环境栈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EC的组成&lt;/strong&gt;：&lt;br /&gt;
1. 变量对象（VO）：包含变量的对象，无法被访问&lt;br /&gt;
2. [[scope]]：作用域链，由变量对象构成，该属性是指向作用域链头节点的指针&lt;br /&gt;
3. this指针：指向环境对象（也是一个普通对象），而不是执行环境EC&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EC的创建&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;EC是在调用函数的时候创建的，一个EC的生命周期分为两个阶段：创建阶段 和 执行阶段：&lt;br /&gt;
1. 创建阶段：此时EC创建变量对象，建立作用域链，确定this的指向，&lt;br /&gt;
2. 代码执行阶段：完成变量赋值，其他函数调用等代码的执行&lt;/p&gt;

&lt;p&gt;其中变量对象的创建也是个重点，这里涉及到了&lt;strong&gt;预编译&lt;/strong&gt;的问题：&lt;br /&gt;
&lt;strong&gt;变量对象的创建&lt;/strong&gt;：&lt;br /&gt;
1. 根据函数的参数，建立arguments对象（类数组，将参数值保存在下标中）。&lt;br /&gt;
2. 函数声明提升：扫描所有的函数声明，将函数名作为变量对象的属性名，属性值为函数在内存中的地址，如果属性名存在，则会被覆盖。&lt;br /&gt;
3. 变量声明提升：扫描所有的变量声明，将变量名作为变量对象的属性名，属性值初始化为undefined，如果属性名存在，则会跳过，不覆盖（防止同名的函数被覆盖为undefined，毕竟函数是一等公民嘛～）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：在代码执行阶段的时候，变量才会被赋值，之前一直都是undefined。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由上可知，作用域其实就是一个变量对象。那么什么是变量对象？&lt;/p&gt;

&lt;h3 id=&#34;变量对象-vo&#34;&gt;变量对象（VO）&lt;/h3&gt;

&lt;p&gt;变量对象存储了EC中定义的变量和函数声明，“这个对象是规范上的，或者说是引擎实现上的，不可在JS环境中访问到”。&lt;/p&gt;

&lt;h3 id=&#34;活动对象-ao&#34;&gt;活动对象（AO）&lt;/h3&gt;

&lt;p&gt;“活动对象其实就是变量对象的激活状态” 这是我在大多数博文中找到的介绍，即当执行流进入一个函数时，EC会被创建，变量对象会被创建，变量对象被激活成为活动对象。&lt;/p&gt;

&lt;p&gt;此处有&lt;strong&gt;争议&lt;/strong&gt;：&lt;br /&gt;
1. 根据“函数是被一级一级的调用的”，我是不是可以说这一级一级向下执行的函数的变量对象都是活动对象呢？毕竟这些函数都被执行了。所以说，我觉得 “活动对象” 应该是处于作用域链顶端的变量对象，该变量对象处于最近被执行的EC。&lt;br /&gt;
2. 另一种说法，不是存在一个执行环境栈嘛，当A函数里执行了B函数，那么B函数入栈，A函数可以想象成处于一种 “休眠” 状态，B函数才算真正被执行。所以B函数里的执行环境、变量对象被创建，变量对象被激活为活动对象。（Emmm，好像也有道理。哈！都是我的猜想😂）&lt;/p&gt;

&lt;p&gt;当函数执行完毕，它的执行环境会被销毁，活动对象也会跟着销毁。但这是在一般的情况下，如果是 &lt;strong&gt;&lt;a href=&#34;https://hueralin.github.io/2019/closure/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;闭包&lt;/a&gt;&lt;/strong&gt;，那就得另当别论。假设A函数里返回了B函数，B函数引用着A函数执行环境里的活动对象。当A函数执行完毕后，A函数的环境变量被销毁，但是活动对象依然存在于作用域的顶端。当返回的函数被调用时，会创建自己的执行环境和活动对象（此时应该就有两个活动对象），闭包函数的活动对象里面引用着上一个活动对象，当闭包函数执行完后，两个活动对象都将被销毁。&lt;/p&gt;

&lt;h3 id=&#34;作用域链&#34;&gt;作用域链&lt;/h3&gt;

&lt;p&gt;作用域分为两种：全局作用域 和 局部作用域。&lt;br /&gt;
前面说过，作用域链其实就是变量对象，但并不是一个，而是一串儿😂。我们所说的局部作用域其实就是当前执行环境的变量对象，我们在查找一个变量的时候，如果在当前变量对象里面查不到的话，就会顺着作用域链一级一级的向上查找，直到全局作用域，因此全局作用域处于作用域链的末端。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/36393048&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;最后，推荐一篇知乎上的帖子，上面讨论的很详细。（尤其是那几个图，很直观，我也就不再放图了😂）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(我听见你在说我懒了&amp;hellip;&amp;hellip;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JS闭包</title>
      <link>https://hueralin.github.io/2019/closure/</link>
      <pubDate>Fri, 30 Aug 2019 17:41:06 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/closure/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考资料：阮一峰&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考资料：MDN&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;之前简单学习过闭包，也会无意间使用过闭包，但如果你要问我闭包是什么我也答不上来。今天呢，重新学习闭包，做个总结。&lt;/p&gt;

&lt;h3 id=&#34;什么是闭包&#34;&gt;什么是闭包&lt;/h3&gt;

&lt;p&gt;相信你在学习闭包的时候肯定看过类似的许多文章是这么说的：“闭包就是一个能够访问 &lt;strong&gt;其他函数的变量&lt;/strong&gt; 的&lt;strong&gt;函数&lt;/strong&gt;”，如果你看过《你不知道的javascript》这本书中关于闭包的解释，你会觉得这句话很片面，也很浅陋，而这句话被当今好多博文所提及，给好多学习闭包的小伙伴造成了不少的误解。&lt;/p&gt;

&lt;p&gt;《你不知道的javascript》这本书中对于闭包是这么说的：“当一个函数能够访问定义它时所处环境的局部变量时，那么就形成了一个闭包（具体怎么说的我也记不太清楚了）”，重点是“形成了一个闭包”，而不是大多数人所说的闭包就是那个函数，闭包其实还跟环境有关。在MDN中也有类似的解释，开头第一句话就是“闭包是函数和声明该函数的词法环境的组合”。下面还有一段解释:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;“闭包是由函数以及创建该函数的词法环境组合而成，这个环境包含了这个闭包创建时所能访问的所有局部变量”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于什么是词法作用域请看 [词法作用域]()&lt;/p&gt;

&lt;p&gt;啪！MDN 还是说出了打脸的话，在makeAdder栗子中，它竟然说“add5 和 add10 都是闭包”（糟糕，我要下不来台了），为什么又说这两个函数是闭包呢，虽然后面还是扯上了词法作用域，但这让读者看起来挺迷啊（哼，双标狗！😂）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function parent() {                 // 外部函数
    let name = &#39;huer&#39;               // 内部变量
    return function children() {    // 内部函数
        console.log(name)
    }
}
let other = parent()
other()                             // ‘huer’
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说下我的简单理解，闭包既然被称为包，那我就可以把它想象成一个包结构（包袱），包裹着外部函数的内部变量和内部函数，并返回内部函数。&lt;strong&gt;注意：内部函数是要被返回的！&lt;/strong&gt; 如果内部函数没有被返回，那么当外部函数执行完毕后，外部函数里面的所有变量和函数都会被垃圾回收机制所清理。此时，我们就引出了闭包函数的一个重要特性，&lt;strong&gt;可以使某些变量长时间存在于内存中而不会被销毁&lt;/strong&gt;。正常情况下，执行完一个函数，即return一个值后，该函数及其内部所有变量就会被回收。而当我们在函数内部又定义了一个函数时，根据对词法作用域的理解，该内部函数可以访问外部函数所定义的变量，即内部函数对它所处的词法作用域有一种引用关系，如果我们将内部函数return出去，并返回给一个变量，那么该变量就是对内部函数的一个引用，从而也能访问外部函数所定义的变量。那么这就实现了某些变量能够一直存在于内存中而不会被销毁，并且还是私有的，其他外部的变量无法访问，只有return的内部函数才能访问。&lt;/p&gt;

&lt;p&gt;在好多博文给出的栗子中，内部函数总是使用了外部函数所定义的变量，这就使好多同学误解，返回的内部函数一定要使用外部函数定义的变量，其实这是不对的。打个比方，我们（内部函数）出生在家里（词法作用域），我们对家里的一切事物都可以够得到，摸得着（除掉‘3岁以下儿童勿碰’等乱七八糟的规则），都可以使用，这并不意味着这些东西此时就在我们手里，它们不在我们的手里，我们也对它们有使用权（即，内部函数对所处的词法作用域有引用关系）。这就是闭包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;形成闭包的条件：外部函数（词法作用域） + 返回一个内部函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们上面的代码只是访问了内部变量，其实我们返回的内部函数还能操作内部变量，是不是有点面向对象的感觉？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function parent() {
    let name = &#39;huer&#39;
    function getName() {
        return name
    }
    function setName(val) {
        name = val
    }
    return {
        getName,
        setName
    }
}
let obj = parent()
obj.getName()                   // &#39;huer&#39;
obj.setName(&#39;tuzi&#39;) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看！不止返回函数才能形成闭包，返回对象也可以！（只要对你想留下的变量保持引用就可以）&lt;/p&gt;

&lt;p&gt;MDN 上还给出了一个使用闭包的情景：“通常你使用只有一个方法的对象的地方，都可以使用闭包” 原谅我没有get到点，不过下面给出的例子倒是比较明白：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 点击按钮，修改字体大小
function makeSizer(size) {
  return function() {
    document.body.style.fontSize = size + &#39;px&#39;;
  };
}

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);

document.getElementById(&#39;size-12&#39;).onclick = size12;
document.getElementById(&#39;size-14&#39;).onclick = size14;
document.getElementById(&#39;size-16&#39;).onclick = size16;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相信上面的代码大家应该都很明白，对于事件绑定，我们要传递的是一个函数，但是如果该函数还要传递参数那就比较棘手了，于是我们可以通过闭包的方式，将参数传递给makeSizer，将makeSizer执行完后返回的函数作为事件的回调函数，于是当我们触发事件的时候，回调函数仍能访问当初传递的参数。类似的关于事件处理函数传参的问题，比如 &lt;a href=&#34;https://hueralin.github.io/2019/bind/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;React中的bind绑定&lt;/a&gt;，我也使用了闭包。&lt;/p&gt;

&lt;p&gt;基于闭包，我们可以实现面向对象中的私有变量，外部无法访问，只能通过暴露出去的公共方法来操作这些私有变量。例如上面的setName和getName。&lt;/p&gt;

&lt;p&gt;MDN 上还有一个创建计时器的工厂函数，每个计时器内部的环境都是互相独立的，也就是说这些闭包互不干扰，关于这方面的知识，参见 [JS活动对象]()&lt;/p&gt;

&lt;h3 id=&#34;坑&#34;&gt;坑&lt;/h3&gt;

&lt;p&gt;闭包虽好，但也不能乱用，常见的一个坑就是在循环中使用了闭包：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 假设有五个按钮，点击按钮分别显示1，2，3，4，5
function NB() {
    var arr = [1,2,3,4,5]
    for(var i = 0;i&amp;lt;arr.length;i++){
        var item = arr[i]
        document.getElementById(&#39;五个button的ID&#39;).onclick = function() {
            alert(item)
        }
    }
}
NB()
// 以前在这里翻过车，总以为会按照期望弹出，结果是每个都弹出5  
// 这里确实有闭包，想想上面形成闭包的条件，外部函数NB有了，返回的内部函数有了  
// 这里的内部函数返回的不明显，即传给onclick的匿名函数，这些匿名函数会在点击的时候被调用。  
// 循环了五次，形成了五个闭包（因为每个匿名函数都不一样），但这五个闭包共享同一个词法作用域，  
// 即都引用了同一个arr数组，因为循环先于按钮被点击，所以当点击时，arr[i]已经是最后一个元素了，所以每次都弹出5。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出错的原因大家应该明白了，即五个闭包共享同一个词法作用股，确切的说是调用了同一个item(arr[i])，因为它本意是想弹出不同的item嘛，所以我们要做的就是使item不同：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function NB() {
    var arr = [1,2,3,4,5]
    for(var i = 0;i&amp;lt;arr.length;i++){
        (function(i) {  // 创建了5个不同的匿名函数（即5个不同的函数作用域）
            var item = arr[i]   // 每个作用域中的item都是独一无二的
            document.getElementById(&#39;五个button的ID&#39;).onclick = function() {
                alert(item)
            }
        })(i)   // 通过使用立即执行函数，传入i
    }
}
// 此时，每个闭包所引用的词法作用域都是立即执行函数产生的，都是不同的
NB()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;未完待续&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>