<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 狐耳的雪原</title>
    <link>https://hueralin.github.io/posts/</link>
    <description>Recent content in Posts on 狐耳的雪原</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 02 Sep 2019 17:08:32 +0800</lastBuildDate>
    
	<atom:link href="https://hueralin.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>狐耳的技术栈</title>
      <link>https://hueralin.github.io/2019/stack/</link>
      <pubDate>Mon, 02 Sep 2019 17:08:32 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/stack/</guid>
      <description> JavaScript JS闭包
 JS执行环境/AO/VO
 事件循环
 async/await
  HTML CSS 性能优化手段 webpack </description>
    </item>
    
    <item>
      <title>JS执行环境，作用域链，变量对象/活动对象</title>
      <link>https://hueralin.github.io/2019/jsec/</link>
      <pubDate>Mon, 02 Sep 2019 11:20:42 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/jsec/</guid>
      <description>JS的重点内容之一，虽然不会在面试题中直接那么问，多半给你出一段代码，看输出什么。
我觉得了解了这部分内容，能让我们对整个JS的执行流程有个详细、准确地认识，在面对工作中的一些错误也能快速且正确的排错。
JS执行环境 JS的执行环境又被称为执行上下文（Execution context），简称EC。顾名思义，JS执行环境就是JS执行时才会存在的环境，常见的执行环境有两种：全局执行环境和函数执行环境。当JS代码执行的时候，我们会进入不同的执行环境，这些执行环境会构成一个执行环境栈。
EC的组成：
1. 变量对象（VO）：包含变量的对象，无法被访问
2. [[scope]]：作用域链，由变量对象构成，该属性是指向作用域链头节点的指针
3. this指针：指向环境对象（也是一个普通对象），而不是执行环境EC
EC的创建：
EC是在调用函数的时候创建的，一个EC的生命周期分为两个阶段：创建阶段 和 执行阶段：
1. 创建阶段：此时EC创建变量对象，建立作用域链，确定this的指向，
2. 代码执行阶段：完成变量赋值，其他函数调用等代码的执行
其中变量对象的创建也是个重点，这里涉及到了预编译的问题：
变量对象的创建：
1. 根据函数的参数，建立arguments对象（类数组，将参数值保存在下标中）。
2. 函数声明提升：扫描所有的函数声明，将函数名作为变量对象的属性名，属性值为函数在内存中的地址，如果属性名存在，则会被覆盖。
3. 变量声明提升：扫描所有的变量声明，将变量名作为变量对象的属性名，属性值初始化为undefined，如果属性名存在，则会跳过，不覆盖（防止同名的函数被覆盖为undefined，毕竟函数是一等公民嘛～）。
注意：在代码执行阶段的时候，变量才会被赋值，之前一直都是undefined。
由上可知，作用域其实就是一个变量对象。那么什么是变量对象？
变量对象（VO） 变量对象存储了EC中定义的变量和函数声明，“这个对象是规范上的，或者说是引擎实现上的，不可在JS环境中访问到”。
活动对象（AO） “活动对象其实就是变量对象的激活状态” 这是我在大多数博文中找到的介绍，即当执行流进入一个函数时，EC会被创建，变量对象会被创建，变量对象被激活成为活动对象。
此处有争议：
1. 根据“函数是被一级一级的调用的”，我是不是可以说这一级一级向下执行的函数的变量对象都是活动对象呢？毕竟这些函数都被执行了。所以说，我觉得 “活动对象” 应该是处于作用域链顶端的变量对象，该变量对象处于最近被执行的EC。
2. 另一种说法，不是存在一个执行环境栈嘛，当A函数里执行了B函数，那么B函数入栈，A函数可以想象成处于一种 “休眠” 状态，B函数才算真正被执行。所以B函数里的环境对象、变量对象被创建，变量对象被激活为活动对象。（Emmm，好像也有道理。哈！都是我的猜想😂）
当函数执行完毕，它的执行环境会被销毁，活动对象也会跟着销毁。但这是在一般的情况下，如果是 闭包，那就得另当别论。假设A函数里返回了B函数，B函数引用着A函数执行环境里的活动对象。当A函数执行完毕后，A函数的环境变量被销毁，但是活动对象依然存在于作用域的顶端。当返回的函数被调用时，会创建自己的执行环境和活动对象（此时应该就有两个活动对象），闭包函数的活动对象里面引用着上一个活动对象，当闭包函数执行完后，两个活动对象都将被销毁。
作用域链 作用域分为两种：全局作用域 和 局部作用域。
前面说过，作用域链其实就是变量对象，但并不是一个，而是一串儿😂。我们所说的局部作用域其实就是当前执行环境的变量对象，我们在查找一个变量的时候，如果在当前变量对象里面查不到的话，就会顺着作用域链一级一级的向上查找，直到全局作用域，因此全局作用域处于作用域链的末端。
最后，推荐一篇知乎上的帖子，上面讨论的很详细。（尤其是那几个图，很直观，我也就不再放图了😂）
(我听见你在说我懒了&amp;hellip;&amp;hellip;)</description>
    </item>
    
    <item>
      <title>JS闭包</title>
      <link>https://hueralin.github.io/2019/closure/</link>
      <pubDate>Fri, 30 Aug 2019 17:41:06 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/closure/</guid>
      <description>参考资料：阮一峰
参考资料：MDN
之前简单学习过闭包，也会无意间使用过闭包，但如果你要问我闭包是什么我也答不上来。今天呢，重新学习闭包，做个总结。
什么是闭包 相信你在学习闭包的时候肯定看过类似的许多文章是这么说的：“闭包就是一个能够访问 其他函数的变量 的函数”，如果你看过《你不知道的javascript》这本书中关于闭包的解释，你会觉得这句话很片面，也很浅陋，而这句话被当今好多博文所提及，给好多学习闭包的小伙伴造成了不少的误解。
《你不知道的javascript》这本书中对于闭包是这么说的：“当一个函数能够访问定义它时所处环境的局部变量时，那么就形成了一个闭包（具体怎么说的我也记不太清楚了）”，重点是“形成了一个闭包”，而不是大多数人所说的闭包就是那个函数，闭包其实还跟环境有关。在MDN中也有类似的解释，开头第一句话就是“闭包是函数和声明该函数的词法环境的组合”。下面还有一段解释:
“闭包是由函数以及创建该函数的词法环境组合而成，这个环境包含了这个闭包创建时所能访问的所有局部变量”。  关于什么是词法作用域请看 [词法作用域]()
啪！MDN 还是说出了打脸的话，在makeAdder栗子中，它竟然说“add5 和 add10 都是闭包”（糟糕，我要下不来台了），为什么又说这两个函数是闭包呢，虽然后面还是扯上了词法作用域，但这让读者看起来挺迷啊（哼，双标狗！😂）。
function parent() { // 外部函数 let name = &#39;huer&#39; // 内部变量 return function children() { // 内部函数 console.log(name) } } let other = parent() other() // ‘huer’  说下我的简单理解，闭包既然被称为包，那我就可以把它想象成一个包结构（包袱），包裹着外部函数的内部变量和内部函数，并返回内部函数。注意：内部函数是要被返回的！ 如果内部函数没有被返回，那么当外部函数执行完毕后，外部函数里面的所有变量和函数都会被垃圾回收机制所清理。此时，我们就引出了闭包函数的一个重要特性，可以使某些变量长时间存在于内存中而不会被销毁。正常情况下，执行完一个函数，即return一个值后，该函数及其内部所有变量就会被回收。而当我们在函数内部又定义了一个函数时，根据对词法作用域的理解，该内部函数可以访问外部函数所定义的变量，即内部函数对它所处的词法作用域有一种引用关系，如果我们将内部函数return出去，并返回给一个变量，那么该变量就是对内部函数的一个引用，从而也能访问外部函数所定义的变量。那么这就实现了某些变量能够一直存在于内存中而不会被销毁，并且还是私有的，其他外部的变量无法访问，只有return的内部函数才能访问。
在好多博文给出的栗子中，内部函数总是使用了外部函数所定义的变量，这就使好多同学误解，返回的内部函数一定要使用外部函数定义的变量，其实这是不对的。打个比方，我们（内部函数）出生在家里（词法作用域），我们对家里的一切事物都可以够得到，摸得着（除掉‘3岁以下儿童勿碰’等乱七八糟的规则），都可以使用，这并不意味着这些东西此时就在我们手里，它们不在我们的手里，我们也对它们有使用权（即，内部函数对所处的词法作用域有引用关系）。这就是闭包。
形成闭包的条件：外部函数（词法作用域） + 返回一个内部函数
我们上面的代码只是访问了内部变量，其实我们返回的内部函数还能操作内部变量，是不是有点面向对象的感觉？
function parent() { let name = &#39;huer&#39; function getName() { return name } function setName(val) { name = val } return { getName, setName } } let obj = parent() obj.</description>
    </item>
    
    <item>
      <title>Git Stash</title>
      <link>https://hueralin.github.io/2019/gitstash/</link>
      <pubDate>Mon, 26 Aug 2019 20:09:47 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitstash/</guid>
      <description>Emmmm 最近在实习的项目中经常使用 git stash 这个命令，现在来做一些总结。
你可能会遇到这样一种情况，就是当你在进行开发或修改某个BUG的时候突然来了一个新任务（新任务与当前的开发项目属于同一个项目），时间紧迫，你需要立即切换分支去执行，可是你当前的任务还没有做完，切分支的话会被拒绝，怎么办呢？有种方法是先add再commit，确实可以，但是我感觉这么做的话会添加一个毫无意义的提交记录，虽然以后可以修改，但是太过麻烦。那么，就来试试 git stash 吧。
git stash 官方文档第一版
git stash 官方文档第二版
git stash 应用场景 git stash 的作用是将当前为提交的修改存储起来，让仓库还原到最后一次提交的状态。
使用场景：
1. 工作未完成，需要切换分支，但不想提交（常用）。
2. 开发一个feature分支（未完成），此时想要合并一下主分支，看看做了哪些修改，提前解决冲突。
现在来看看场景二的解决方法：
// 假设我在feature分支上开发，突然得知主分支更新了，于是我想要将主分支合并到当前分支，看看有没有冲突，有的话直接解决。 git checkout master // 报错！会提示当前某些修改未存储提交 // 当然，我是不想提交的，毕竟还没做完...于是， git stash save &amp;quot;先搁这儿，我去瞅瞅主分支，拉下代码～&amp;quot; // save 类似于 commit 的 -m 选项，即注释信息 git stash list // 列出来所有的存储信息，看看有木有～ git checkout master // 切换到主分支 git pull origin master // 将远程主机的master分支拉下来 git checkout feature // 切回feature分支 git merge master // 将master分支合并到feature（可能会有冲突） git stash pop // 将先前feature分支做的修改释放出来（可能会有冲突） // 有冲突合并即可，合并完，feature拥有了master分支最新的修改以及当前的特性开发。  git stash git stash 实际上是一个栈结构，它可以获取工作目录中的中间状态（包括对已追踪文件的修改和暂存的变更，使用 git status 查看），将它保存在一个栈结构中，方便以后使用。（注意！未被追踪的文件不在存储的范围内！）</description>
    </item>
    
    <item>
      <title>Mock 前端假数据</title>
      <link>https://hueralin.github.io/2019/mock/</link>
      <pubDate>Wed, 21 Aug 2019 16:09:41 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/mock/</guid>
      <description>为什么需要前端做假数据？Emmmm，不用我说了吧～
 官方文档看这里MockJs！
数据模版之类的语法去看官方文档，我这里只简单介绍一下我的使用情况。</description>
    </item>
    
    <item>
      <title>伪类 与 伪元素</title>
      <link>https://hueralin.github.io/2019/weilei/</link>
      <pubDate>Wed, 21 Aug 2019 15:17:26 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/weilei/</guid>
      <description>“请说一下伪类和伪元素的区别”，之前的面试中遇到过这个问题，当初表示只见过伪类，回答的基本上都是:hover之流，这道题就挂了&amp;hellip;&amp;hellip;
 如今，在实习中遇到了相关的需求，看来是时候深入学习一下了。其实，区分伪类和伪元素并不难，它俩最大的区别就在于应用场景。
伪类 顾名思义，它相当于一个类，是用来设置样式的；当你需要让一个元素在某种特殊状态下显示特殊的样式时（如：按钮悬浮特效），就该使用伪类。 下面我们来实现一下伪类：
需求：实现消息列表悬浮特效
&amp;lt;!-- 需求很明确，li元素在悬浮情况下应用样式 --&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;React&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Vue&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Angular&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;jQuery&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Webpack&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;NPM&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; li:hover { background: #eee; } &amp;lt;!-- 再简单不过了，当然也可以设置奇偶行样式不一 --&amp;gt;  其他的伪类：
:active :empty :enabled :first :first-child :first-child :first-of-type :focus :hover :visited :nth-child :nth-of-type :link  伪元素 顾名思义，它是一个元素，可以是现有的元素，也可以是新增的元素，这些元素往往有自己的特殊位置（如：段落首字母突出样式）往往被作为附加的标记。 下面我们来实现一下伪元素
需求：表单必填项前面加一个标识（这也是我这次的需求）
&amp;lt;label&amp;gt;页面地址&amp;lt;/label&amp;gt; &amp;lt;input type=&#39;text&#39; placeholder=&amp;quot;请输入页面地址&amp;quot;/&amp;gt; label::before { content: &#39;*&#39;; color: red; }  效果：伪元素并不多：
1. ::before
2. ::after</description>
    </item>
    
    <item>
      <title>React组件中的函数this绑定</title>
      <link>https://hueralin.github.io/2019/bind/</link>
      <pubDate>Tue, 20 Aug 2019 11:04:35 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/bind/</guid>
      <description>实习项目遇到的问题 关于函数this绑定！ 最近在React项目中遇到了关于函数this绑定的问题，因为在普通函数（诸如:function(){xxx}）中，this的绑定是动态的，在被执行时才会确定。若这些普通函数在自身组件内使用一般不会有太大的问题，然而一旦被当作参数（例如事件处理函数）传递到其他组件时，this就会绑定为其他组件的实例，在获取原实例的状态时就会发生错误。
箭头函数的this绑定和普通函数不一样，它是静态绑定的，也就是说箭头函数的this绑定是在定义时绑定的，即定义箭头函数时所处的作用域的this。所以说如果React组件中的函数是用箭头函数的形式定义的话，就不用担心this绑定的问题。
假如你的onClick事件处理函数在被触发时需要传参，如果直接 onClick={this.handleClick(xxx)} 话，onClick得到的就不是函数，而是函数返回的结果，所以应使用 onClick={() =&amp;gt; this.handleClick(xxx)} ，即给onClick一个箭头函数作为事件处理函数，那么this就绑定为了当前组件的实例，调用的普通函数也不用做特殊的处理。
我犯了一个最基础也最致命的问题，在渲染中进行了状态的改变！按理说我不应该会犯这种错误，我犯这种错误的原因就是我将箭头函数和普通函数结合使用（模仿的项目中的老代码）：
handleInput(key) { return (e) =&amp;gt; { let inputValue = {} inputValue[key] = e.target.value this.setState({ data: Object.assign({}, this.state.data, inputValue) }) } } onChange={this.handleInput(xxx)}  看出和之前 onClick={() =&amp;gt; this.handleClick(xxx)} 的不同了么？
这里是由普通函数将箭头函数return了出来，所以函数渲染时立即执行handleInput，并将执行后的箭头函数传给onChange，顺便完成this绑定，Emmmm，秀啊！可惜当初我没搞懂这个用意，将handleInput彻底改成了普通函数，导致在渲染时执行了this.setState()，浏览器不停的改变状态和渲染，瞬间报错0～20000+，不得不强制杀死浏览器进程&amp;hellip;&amp;hellip;
总结React组件中的函数this绑定的几种方法 一、每当作为事件处理函数时，例如：onClick onChange 等，都手动绑定一次
// 这种方法的好处是在绑定this的同时能传递参数 onClick={this.handleClick.bind(this, args)} // 缺点是，每次都得手动调用bind()  二、在构造函数中绑定一次，一劳永逸
// 缺点是不能传递参数 this.handleCLick = this.handleClick.bind(this)  三、React组件的函数直接定义成箭头函数
handleClick = (args) =&amp;gt; {xxxxx} // 缺点也是不能传递参数   上述三个做法有个矛盾，就是“一次绑定”和“传递参数”不能兼顾</description>
    </item>
    
    <item>
      <title>Array</title>
      <link>https://hueralin.github.io/2019/array/</link>
      <pubDate>Mon, 19 Aug 2019 15:46:37 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/array/</guid>
      <description>Array Emmmm, Array的函数不少，至少我觉的是这样。随着ES的发展，Array多了许多奇奇怪怪的函数。
虽说奇怪&amp;hellip;.但用起来超爽的啊！！！！
什么？想要查找数组中的某个元素？ Array.find() 拿走不送！（ES6）
该函数接受两个参数：callback、thisObj
在回调函数中return符合查找条件的元素，若查找成功则直接返回该元素的值，否则返回undefined，并且不会改变原素组，简直不要太爽！
如果想要查找某个元素的索引的话，可以使用 Array.findIndex() 函数，找不到的话返回-1。
增删元素类（改变原数组）  push() 在后面插入
 unshift() 在前面插入
 pop() 在后面弹出 shift() 在前面弹出  元素查找类  find(callback) 通过callback的逻辑，查找满足条件的元素，返回“值”
 findIndex(callback) 通过callback的逻辑，查找满足条件的元素，返回“索引“ includes(item) 查找是否有item，返回布尔值
 indexOf(item) 查找是否有item，返回下标
  数组遍历类 &amp;mdash; forEach() &amp;mdash;
let a = [1,2,3,4,5] a.forEach((item, index, arr) =&amp;gt; { console.log(item) // 1,2,3,4,5 }) /* forEach 遍历的范围在第一次调用 callback 前就会确定,所以后续调用中 添加 和 删除 的item都不会被遍历到 */ a.forEach((item, index, arr) =&amp;gt; { arr.</description>
    </item>
    
    <item>
      <title>后台管理系统</title>
      <link>https://hueralin.github.io/2019/athene/</link>
      <pubDate>Wed, 07 Aug 2019 10:49:37 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/athene/</guid>
      <description>这是实习期一个后台管理的项目 目前正在熟悉该项目，边熟悉，边做一些记录
先来看一下大体的框架：
顶层容器
在container目录下的index.js文件中，有一个IndexContainer组件，该组件中的render函数是这么写的
render () { let { permission } = this.props return ( &amp;lt;div&amp;gt; &amp;lt;Header params={this.props.params} username={permission.username} /&amp;gt; &amp;lt;div className=&#39;main-content&#39;&amp;gt; &amp;lt;SideNav routes={this.props.routes} permissions={permission.permission} /&amp;gt; &amp;lt;div&amp;gt; {this.props.children} &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ) }  可以看出该系统采用了非常常见的布局，即‘顶部导航+左侧导航+右侧内容’
路由配置
因为路由比较多，所有路由配置分为两个路由文件：
外层路由文件
// 这里引入了内层路由文件 import routers from &#39;./routers&#39; module.exports = ( &amp;lt;Router history={browserHistory}&amp;gt; &amp;lt;Route path=&#39;/&#39; /&amp;gt; &amp;lt;Route path=&#39;/xxx&#39; component={xxx} /&amp;gt; &amp;lt;Route path=&#39;/xx/xx&#39; component={xx} /&amp;gt; ...... &amp;lt;Route path=&#39;&#39; component={Container} onEnter={handleEnterSystem}&amp;gt; {/* 嵌套路由，内层路由文件里的Route渲染的组件都是Container容器下的子组件，在this.props.children处渲染*/} { routers } &amp;lt;/Route&amp;gt; &amp;lt;Redirect from=&#39;*&#39; to=&#39;/error/404.</description>
    </item>
    
    <item>
      <title>ES2016/2017新特性</title>
      <link>https://hueralin.github.io/2019/es20162017etc/</link>
      <pubDate>Tue, 06 Aug 2019 11:56:42 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/es20162017etc/</guid>
      <description>ES2016(ES7) Array.prototype.includes(value): 判断一个元素是否在数组中
let a = [1,2,3,4,5,6] a.includes(4) // true a.includes(7) // false // 功能类似于 xxx.indexOf(y) &amp;gt; -1, 但有不同 // includes可以检测Nan (indexO不可以) [NaN].includes(NaN) // true // 不区分 -0 +0 （indexOf也可以） [-0].includes(+0) // true  求幂运算
let a = 3 a ** 2 // 9 // 相当于 Math.pow(a, 2)  ES2017(ES8) String.prototype.padStart / String.prototype.padEnd（字符串填充）
功能：返回指定长度的填充后的字符串 语法：str.padStart(len [, padStr]) // len 指定长度 padStr 填充字符串 let str = &#39;huer&#39; // 1. 指定长度小于原字符串长度，则返回原字符串 str.</description>
    </item>
    
    <item>
      <title>React_router配置</title>
      <link>https://hueralin.github.io/2019/react_router/</link>
      <pubDate>Mon, 05 Aug 2019 14:24:46 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/react_router/</guid>
      <description>最近在学习React-router遇到了一些问题，在此记录一下：
目前成功的配置为：
app.jsx
import React from &#39;react&#39; import ReactDOM from &#39;react-dom&#39; import { HashRouter as Router, Route } from &#39;react-router-dom&#39; import Content from &#39;./components/Content.jsx&#39; import About from &#39;./components/About.jsx&#39; import Posts from &#39;./components/Posts.jsx&#39; import Post from &#39;./components/Post.jsx&#39; ReactDOM.render( &amp;lt;Router&amp;gt; &amp;lt;Content&amp;gt; &amp;lt;Route path=&#39;/about&#39; component={About}&amp;gt;&amp;lt;/Route&amp;gt; &amp;lt;Route path=&#39;/posts&#39; component={Posts}&amp;gt;&amp;lt;/Route&amp;gt; &amp;lt;Route path=&#39;/posts/:id&#39; component={Post}&amp;gt;&amp;lt;/Route&amp;gt; &amp;lt;/Content&amp;gt; &amp;lt;/Router&amp;gt;, document.getElementById(&#39;app&#39;) )  Content.jsx
import React from &#39;react&#39; import { Link } from &#39;react-router-dom&#39; class Content extends React.Component { render () { return &amp;lt;div&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;Link to=&#39;/&#39;&amp;gt;主页&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;Link to=&#39;/posts&#39;&amp;gt;博文&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;Link to=&#39;/about&#39;&amp;gt;关于&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; {this.</description>
    </item>
    
    <item>
      <title>敏捷开发</title>
      <link>https://hueralin.github.io/2019/mjkf/</link>
      <pubDate>Thu, 01 Aug 2019 17:10:22 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/mjkf/</guid>
      <description>敏捷宣言
12条原则
Scrum
XP(极限编程)
1. 结对编程
2. 测试驱动开发：单元测试，重构
3. 持续集成
4. 代码集体所有（统一规范，任何人写的代码，任何人都能维护）
5. 现场客户
精益思维
1. 消除浪费
2. 增强学习
3. 尽量延迟决定
4. 尽快发布
5. 下放权力
6. 嵌入质量
7. 全局优化
FDD-特性驱动开发
看板（白板）
MoSCoW
估算
估算纸牌（数字高代表能力强，数字代表和参照物相比该任务的复杂度，每个人对同一个任务的估算是不同的）
技术债务
迭代开发 增量交付 自组织团队 高价值的优先级排序</description>
    </item>
    
    <item>
      <title>Webpack4 配置文件解析</title>
      <link>https://hueralin.github.io/2019/webpack4/</link>
      <pubDate>Mon, 29 Jul 2019 18:54:31 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/webpack4/</guid>
      <description>let path = require(&#39;path&#39;) // 创建HTML模板的插件 let HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;) // 抽离CSS样式为单独文件的插件（原来都是将CSS样式全部放进了style里面） let MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;) // 优化CSS的插件（压缩CSS文件） let OptimizeCss = require(&#39;optimize-css-assets-webpack-plugin&#39;) // 用了上面优化CSS的插件，就得使用下面这个插件来优化JS（压缩JS文件） let UglifyJsWebpackPlugin = require(&#39;uglifyjs-webpack-plugin&#39;) module.exports = { // 优化CSS和JS // 优化项 optimization: { // 压缩 minimizer: [ new UglifyJsWebpackPlugin({ cache: true, // 缓存 parallel: true, // 并发压缩 sourceMap: true // }), new OptimizeCss() ] }, // 模式：开发和生产模式两种 mode: &#39;development&#39;, entry: &#39;./src/index.js&#39;, output: { // path 必须是绝对路径 // path.</description>
    </item>
    
    <item>
      <title>汉服那么美，为何现在流行不起来</title>
      <link>https://hueralin.github.io/2019/hjjh-02/</link>
      <pubDate>Sun, 28 Jul 2019 12:27:50 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/hjjh-02/</guid>
      <description>出行不便（生活节奏）
 价格昂贵（手工刺绣，配饰）
 身材和气质（汉服对这两点要求有点高）
 普及范围狭窄（汉服知识？恐怕得考古好久）
  服装和文化一样，要与时俱进。要想发扬汉服文化，让汉服流行起来，不能一味的追求历史（此言不当，不知如何表述），应该结合当下的形式，做出一些改进，这算不上“取其精华，去其糟粕”，古代的穿衣礼节，穿衣过程确有其繁琐的地方，放到现代来确实让人难以接受，这也是汉服流行不起来的原因之一。我们不能一味的遵从汉服文化而渐渐变得复古，这也是不可能的。最近在相关贴吧上看到过这样一个帖子，有个小姐姐晒出汉服写真却被一群大叔嘲讽，不懂汉服历史，穿着不伦不类，不认同这是汉服，戏称为“花衣服”。大叔们有这种想法也无可厚非，毕竟现在的穿汉服的人多多少少也搭配着一些现代的服饰，比如手表、小白鞋，还有大叔们嘲讽的丝袜，小姐姐面对嘲讽也是欲哭无泪&amp;hellip;
小姐姐错了么？大叔们错了么？
在我看来，此事无关对错。现在的年轻人穿汉服无非两个原因，其一是服饰着实好看，其二是想为发扬中国传统文化献上一份力量。曾经抖音上的一个短视频对我产生了一丝丝触动，一个女孩儿边哭变向床上扔着一件件汉服，边扔边说“我穿汉服上街怎么了？我喜欢汉服，这有错么，碍着你们了？一个个用异样的眼光看我，甚至还嘲讽我穿着奇装异服”，“在日本韩国，这在他们看来是很正常不过的事情，为什么在国内穿传统服装却被看作异类”（Emmm，原话忘了，大体这个意思吧）这段话引起了我的思考
至于思考了啥？晚上回去再说，学习！😂
to be continue&amp;hellip;</description>
    </item>
    
    <item>
      <title>汉家江湖-起源</title>
      <link>https://hueralin.github.io/2019/hjjh-01/</link>
      <pubDate>Sun, 28 Jul 2019 12:22:08 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/hjjh-01/</guid>
      <description>不知何时起，对汉服有了兴趣～
能做什么？ 1. 维护一个像B站二次元的网站（搞活动） 2. 汉服实体店 3. 联动武侠IP，电影？动漫？ 4. 侠客栈（民宿） 5. IP手办？</description>
    </item>
    
    <item>
      <title>实习项目的Header结构解析</title>
      <link>https://hueralin.github.io/2019/zkheader/</link>
      <pubDate>Sun, 28 Jul 2019 00:07:10 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/zkheader/</guid>
      <description>最近在做公司的项目，更改移动端Header的现有布局。
Header是React组件，点击按钮出现侧边栏导航。
下面简单来介绍一下Header的结构：
Header接受了3个props，分别是“userInfo”、“changeNavState”、“style”。
userInfo是用户信息，changeNavState是用来更改侧边导航状态的函数，style是一个类样式。
以上几个props都交由PropTypes来验证参数的合法性。
该Header组件内仅维护了一个状态，那就是 subNav，即侧边导航栏的显示与否，changeNavState函数改变的就是它。
在render渲染函数中：
const { userInfo, style } = this.props
根据是否有userInfo.avatar属性来初始化headUrl变量（有则赋值为用户头像URL，无则赋值为默认头像URL）
接下来return一个JSX，
首先判断subNav是否为真，真则显示侧边导航。
然后是左右布局，左边是点击显示侧边导航的下拉按钮和点击能返回主页的LOGO，右边是用户头像。
左边的导航按钮添加点击事件（调用changeNavState函数），通过控制subNav状态来显示和隐藏侧边导航。
右边判断userInfo.id属性，有则根据headeUrl显示用户头像，否则显示默认头像。默认头像图标添加点击跳转登录事件。
其中userInfo属性是由connect函数连接的， userInfo来自于Redux的State。</description>
    </item>
    
    <item>
      <title>Mac使用技巧</title>
      <link>https://hueralin.github.io/2019/mactips/</link>
      <pubDate>Sat, 27 Jul 2019 17:21:45 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/mactips/</guid>
      <description>VSCODE使用命令行打开目录
&amp;gt;相关知识：环境变量的设置
环境变量的分类：系统级和用户级
系统级：对所有用户生效的永久性变量（/etc/profile）
用户级：对单一用户生效的永久性变量（～/.bash_profile）
 查看单个环境变量echo $PATH
 查看所有环境变量env
 修改环境变量PATH=&amp;quot;xxxx&amp;quot; 查看所有本地定义的shell变量set
 删除变量unset VNAME
 设置只读变量readonly VNAME  使用export指令添加环境变量：
vim ~/.bash_profile
输入 export JAVA_HOME=/usr/java/jdk
输入 export PATH=$JAVA_HOME/bin:$PATH
添加完成后新的环境变量不会立即生效，调用source ~/.bash_profile 该文件才会生效
使用export命令添加临时环境变量：
命令行下输入 export MALIN=&#39;malin&#39;
使用code命令用VSCODE打开目录：
1. 在VSCODE中 command+shift+P -&amp;gt; 输入shell command -&amp;gt; 点击提示Shell Command: Install ‘code’ command in PATH运行
2. 在终端中使用 code 目录路径 打开目录（vscode）</description>
    </item>
    
    <item>
      <title>HOC---高阶组件</title>
      <link>https://hueralin.github.io/2019/hoc/</link>
      <pubDate>Sat, 27 Jul 2019 12:37:17 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/hoc/</guid>
      <description>推荐文章：助你完全理解React高阶组件（Higher-Order Components）
简单讲，高阶组件就是一个函数，以组件为参数，返回另一个组件。
高阶组件的目的就是为了复用，可能有很多人不理解，“组件不就是用来复用的么，为什么还要出来一个高阶组件呢？”。
举个例子，有这么一个需求：</description>
    </item>
    
    <item>
      <title>Git Reset</title>
      <link>https://hueralin.github.io/2019/gitreset/</link>
      <pubDate>Fri, 26 Jul 2019 17:41:51 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitreset/</guid>
      <description>惊了！本来想撤销上一次commit，但保留工作区的修改，但是手残加了 &amp;ndash;hard 参数，修改全没了！！！
后来，运行了一遍git reflog branchName, 查看了下该分支上的历史记录，找到reset操作之前的历史，执行git reset --hard reset之前的记录点回来了！！！
回来了！！！！ Git取消对某个文件的跟踪
1. git rm --cached readme.md 删除readme.md的跟踪，并保留在本地。 2. git rm --f readme.md 删除readme.md的跟踪，并且删除本地文件。</description>
    </item>
    
    <item>
      <title>Git分支</title>
      <link>https://hueralin.github.io/2019/gitbranch/</link>
      <pubDate>Fri, 26 Jul 2019 16:45:41 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitbranch/</guid>
      <description>分支就是一个指向单个commit的指针
分支基本操作：
1. 分支改名：git branch -m oldName newName
2. 删除分支：git branch -d feature
3. 从master签出feature：git checkout -b feature master
4. 查看本地分支：git branch
5. 查看远程分支：git branch -r
6. 查看所有分支：git branch -a
7. 合并分支：git merge B 要想将B分支合并到A分支，首先要切换回A分支，在执行merge命令</description>
    </item>
    
    <item>
      <title>Zhike</title>
      <link>https://hueralin.github.io/2019/zhike/</link>
      <pubDate>Fri, 26 Jul 2019 15:48:33 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/zhike/</guid>
      <description>线上分支：production
测试分支：master（www.dev.xxxxxx）
迭代分支：release-3.xxx
在一个迭代开始后，各种开发新特性，修复BUG，当这些工作做完时，需要将所有的改动都合并到release分支上，
作为一次迭代，再合并到master分支（dev）进行测试，测试没问题后再合并到production分支上，发布（上线）。</description>
    </item>
    
    <item>
      <title>Git pull 的使用</title>
      <link>https://hueralin.github.io/2019/gitpull/</link>
      <pubDate>Tue, 23 Jul 2019 14:37:19 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitpull/</guid>
      <description>语法：git pull &amp;lt;选项&amp;gt; &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;
 注意：和git push的语法顺序稍有不同
git push 的语法为：git pull &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt;
git pull 意为从远程分支的最新版本拉取下来并于本地分支合并
 git pull origin master:dev 将origin的master分支拉取并合并到本地的dev分支
 git pull origin master 省略了本地分支名，即拉取并合并到本地分支
 git pull origin 若有 某远程分支与当前分支有追踪关系，则远程分支名也可以省略
 git pull 若只有一个远程主机，且只有一个远程分支与当前分支有追踪关系，则可以直接git pull
  git pull相当于git fetch和git merge的简写
比如：git pull origin dev 相当于 git fetch origin dev + git merge origin/dev
未完待续&amp;hellip;</description>
    </item>
    
    <item>
      <title>Fork工作流</title>
      <link>https://hueralin.github.io/2019/fork/</link>
      <pubDate>Tue, 23 Jul 2019 10:34:46 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/fork/</guid>
      <description>Fork工作流 实现协同开发
作为实习新人，在参与公司项目的开发时被要求使用Fork工作流，Fork工作流实际上就是从GitHub上fork一个原仓库，并与原仓库代码保持同步的一种工作方式。
Fork工作流不再是只有一个中央代码库，而是给予每个人一个远程仓库（origin），外加一个唯一的中央仓库（upstream，或称为官方仓库）。点击Fork时就会生成一个自己的远程仓库，每次开发者提交时都会先将自己的贡献提交到origin，然后发起一个Pull Request请求给中央仓库，中央仓库的管理者会决定是否将你的代码提交到中央仓库，其他人都没这个权限。这使得管理者可以接受任何人的提交，而不需要给它们中央仓库的权限。
具体流程
1. 从原仓库fork到自己的origin
2. git clone xxxxxx 将origin克隆到本地
3. git remote add upstream xxxxx 指向上游仓库，即原仓库
4. git checkout -b feature-xx origin/dev 从远程分支检出本地分支进行开发
5. 开发、修改。。。。提交。。。
6. git push origin feature-xx 将本地feature分支push到origin
7. 发起Pull Request请求管理员合并
8. 上述合并可能会导致冲突，因为本地仓库可能比较旧了，需要更新
9. git checkout dev 切回dev分支
10. git pull upstream dev 从原仓库拉取dev分支的最新版本,更新本地的dev分支
11. git checkout -b feature-merge-dev dev 从更新后的本地dev检出合并分支，并切换为该分支
12. git merge feature-xx 合并你的修改，即feature-xx分支上的内容
13. git branch -m feature-merge-dev feature-xx 将合并分支改名为feature-xx 覆盖原分支</description>
    </item>
    
    <item>
      <title>Git push 的使用</title>
      <link>https://hueralin.github.io/2019/gitpush/</link>
      <pubDate>Mon, 22 Jul 2019 14:32:37 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitpush/</guid>
      <description>语法：git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt; ：&amp;lt;远程分支名&amp;gt;
  git push origin master
最常用的一个写法，忽略了远程分支名，将本地master分支推送到origin中与之有追踪关系的对应分支（通常同名），若没有则创建一个对应的远程分支。
 git push origin :master
忽略了本地分支名，意味着要推送一个本地的空分支到指定远程分支，即删除指定的远程分支，相当于git push origin --delete master
 git push origin
如果当前分支和远程分支存在对应关系，则两个分支名都可省略掉，直接推送当前分支到对应的远程分支。
 git push
如果只有一个远程主机，且只有一个与当前分支对应的远程分支，那么就可以全都省略，直接git push。
 git push -u origin master
如果对应多个远程主机，-u 则指定一个默认主机，以后就可以直接使用git push推送当前分支到远程对应分支。
 git push &amp;ndash;all origin
不管是否存在对应的远程分支，将本地的所有分支全部推上去。
 git push &amp;ndash;force origin
一般情况下本地仓库比远程仓库旧的话会要求你先git pull进行更新，而 &amp;ndash;force 表明不要更新，直接推上去。
 git push origin &amp;ndash;tags
不推送分支，只推送标签。
&amp;mdash;
关于追踪关系
追踪即本地分支跟进远程分支的变化，用于push、pull、merge等&amp;hellip;
追踪远程分支
 git clone 一般克隆下来的项目将自动创建master分支，并且自动关联到远程的master分支上</description>
    </item>
    
    <item>
      <title>用webpack搭建简易的React应用</title>
      <link>https://hueralin.github.io/2019/createreactwithwebpack/</link>
      <pubDate>Sun, 21 Jul 2019 00:19:54 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/createreactwithwebpack/</guid>
      <description>Emmm,步骤清单😂
 npm init -y
 npm i webpack webpack-cli webpack-dev-server --save-dev
 npm i react react-dom --save
 npm i babel-core babel-loader@7 babel-preset-es2015 babel-preset-react --save-dev
需要安装的包差不多就这些了，接下来配置webpack.config.js文件
  module.exports = { entry: &amp;quot;./index.jsx&amp;quot;, output: { path: __dirname + &amp;quot;/public&amp;quot;, filename: &amp;quot;bundle.js&amp;quot; }, module: { rules: [ { test: /\.jsx$/, loader: &amp;quot;babel-loader&amp;quot; } ] }, devServer: { contentBase: &amp;quot;./public&amp;quot; } }   在package.json文件中添加脚本
5.1. &amp;quot;build&amp;quot;: &amp;quot;webpack&amp;quot;打包
5.2. &amp;quot;dev&amp;quot;: &amp;quot;webpack-dev-server --open --inline&amp;quot;启动测试服务器</description>
    </item>
    
    <item>
      <title>搭个窝，储点儿粮，准备过冬！</title>
      <link>https://hueralin.github.io/2019/life20190720/</link>
      <pubDate>Sat, 20 Jul 2019 23:28:34 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/life20190720/</guid>
      <description>今天总算把我的小窝搭建起来了，hugo + github pages 还真不错，感谢该hugo主题的作者，UI很好看。 为什么要放在GiHub上而不是自己前后端+服务器啥的一通瞎搞呢？记得有人说过，刚开始做博客的时候大包大揽，前后端都自己做，确实考验技术也很有成就感，或许也是一时兴起，刚接触博客，饶有趣味，可后来操心太多，可能还会修复bug，还不时续费维护，那时才想起来，”我就是要发篇博客嘛，那么麻烦干什么，都不能专心写作了“，于是github静态博客成了首选（毕竟CSDN、博客园、简书啥的不能定制），通过简单的Markdown语法+GitHub基础就可以发布一篇博客了，岂不美哉～ 可以在该博客上发发技术文章，也可以记录学习和生活，简简单单，专心写作。今天也算是里程碑的一天吧，有此博客就像在北京有了一套房（哈哈哈😂，有些夸张～），实习的日子，加油！</description>
    </item>
    
  </channel>
</rss>