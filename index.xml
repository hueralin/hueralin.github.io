<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>狐耳的雪原 on 狐耳的雪原</title>
    <link>https://hueralin.github.io/</link>
    <description>Recent content in 狐耳的雪原 on 狐耳的雪原</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 29 Jul 2019 18:54:31 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Webpack4 配置文件解析</title>
      <link>https://hueralin.github.io/2019/webpack4/</link>
      <pubDate>Mon, 29 Jul 2019 18:54:31 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/webpack4/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let path = require(&#39;path&#39;)
// 创建HTML模板的插件
let HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)
// 抽离CSS样式为单独文件的插件（原来都是将CSS样式全部放进了style里面）
let MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)
// 优化CSS的插件（压缩CSS文件）
let OptimizeCss = require(&#39;optimize-css-assets-webpack-plugin&#39;)
// 用了上面优化CSS的插件，就得使用下面这个插件来优化JS（压缩JS文件）
let UglifyJsWebpackPlugin = require(&#39;uglifyjs-webpack-plugin&#39;)

module.exports = {

    // 优化CSS和JS
    // 优化项
    optimization: {
        // 压缩
        minimizer: [
            new UglifyJsWebpackPlugin({
                cache: true,    // 缓存
                parallel: true, // 并发压缩
                sourceMap: true // 
            }),
            new OptimizeCss()
        ]
    },

    // 模式：开发和生产模式两种
    mode: &#39;development&#39;,
    entry: &#39;./src/index.js&#39;,
    output: {
        // path 必须是绝对路径
        // path.resolve()可以将相对路径解析为绝对路径
        // __dirname 是当前目录
        path: path.resolve(__dirname, &#39;build&#39;),
        // 加上hash，每次都生成一个新的文件(不重复 ，防止出现缓存或覆盖的问题)（8位hash值）
        filename: &#39;bundle.[hash:8].js&#39;

    },
    devServer: {
        port: 3000,
        // 显示进度条
        progress: true,
        //  以build目录为静态服务的根目录(所有被服务的内容都来自这里)
        contentBase: &#39;./build&#39;,
        // 启动时自动打开浏览器
        open: true,
        // 使用gzip压缩所有被服务的文件
        compress: true
    },
    plugins: [
        // 这个插件可以按照模板生成一个index.html文件，并插入打包后的bundle.js文件
        new HtmlWebpackPlugin({
            // 指定模板文件
            template: &#39;./src/index.html&#39;,
            // 打包后的文件名
            filename: &#39;index.html&#39;,
            // 上线时的压缩操作
            minify: {
                // 去掉属性的引号
                removeAttributeQuotes: true,
                // （压缩）变成单行
                collapseWhitespace: true,
            },
            // 在引用文件名尾部加一个hash串
            hash: true
        }),
        new MiniCssExtractPlugin({
            // 抽离出来的CSS文件的名字
            filename: &#39;main.css&#39;
        })
    ],
    module: {   // 模块
        rules: [    // 规则
            {
                // css-loader是来处理 css文件中@import语法的
                // style-loader 是来将css文件插入到html中的style标签里去的
                // 使用单个loader只需要一个字符串表示，
                // 使用多个loader需要用数组
                // loader的顺序，从右向左执行

                // loader还可以用对象表示法（ 即数组元素为对象而不是字符串），该方法下可以传个option
                test: /\.css$/,
                use: [
                    // {
                    //     loader: &#39;style-loader&#39;,
                    //     options: {
                    //         // 将CSS文件插入到模板HTML自定义样式的上方
                    //         insertAt: &#39;top&#39;
                    //     }
                    // }
                    // 使用MiniCssExtractPlugin插件的loader，通过link引用CSS文件
                    MiniCssExtractPlugin.loader
                    , &#39;css-loader&#39;
                    , {
                        loader: &#39;postcss-loader&#39;,
                        options: {
                            plugins: [
                                require(&#39;autoprefixer&#39;)
                            ]
                        }
                    }]     // 自动加前缀，兼容浏览器
            },
            {
                test: /\.less$/,
                use: [
                    MiniCssExtractPlugin.loader
                    , &#39;css-loader&#39;
                    ,  {
                        loader: &#39;postcss-loader&#39;,
                        options: {
                            plugins: [
                                require(&#39;autoprefixer&#39;)
                            ]
                        }
                    } // 加前缀
                    ,  &#39;less-loader&#39;    // 处理less文件   
                ]      
            }
        ]
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>汉服那么美，为何现在流行不起来</title>
      <link>https://hueralin.github.io/2019/hjjh-02/</link>
      <pubDate>Sun, 28 Jul 2019 12:27:50 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/hjjh-02/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;出行不便（生活节奏）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;价格昂贵（手工刺绣，配饰）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;身材和气质（汉服对这两点要求有点高）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;普及范围狭窄（汉服知识？恐怕得考古好久）&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;服装和文化一样，要与时俱进。要想发扬汉服文化，让汉服流行起来，不能一味的追求历史（此言不当，不知如何表述），应该结合当下的形式，做出一些改进，这算不上“取其精华，去其糟粕”，古代的穿衣礼节，穿衣过程确有其繁琐的地方，放到现代来确实让人难以接受，这也是汉服流行不起来的原因之一。我们不能一味的遵从汉服文化而渐渐变得复古，这也是不可能的。最近在相关贴吧上看到过这样一个帖子，有个小姐姐晒出汉服写真却被一群大叔嘲讽，不懂汉服历史，穿着不伦不类，不认同这是汉服，戏称为“花衣服”。大叔们有这种想法也无可厚非，毕竟现在的穿汉服的人多多少少也搭配着一些现代的服饰，比如手表、小白鞋，还有大叔们嘲讽的丝袜，小姐姐面对嘲讽也是欲哭无泪&amp;hellip;&lt;/p&gt;

&lt;p&gt;小姐姐错了么？大叔们错了么？&lt;/p&gt;

&lt;p&gt;在我看来，此事无关对错。现在的年轻人穿汉服无非两个原因，其一是服饰着实好看，其二是想为发扬中国传统文化献上一份力量。曾经抖音上的一个短视频对我产生了一丝丝触动，一个女孩儿边哭变向床上扔着一件件汉服，边扔边说“我穿汉服上街怎么了？我喜欢汉服，这有错么，碍着你们了？一个个用异样的眼光看我，甚至还嘲讽我穿着奇装异服”，“在日本韩国，这在他们看来是很正常不过的事情，为什么在国内穿传统服装却被看作异类”（Emmm，原话忘了，大体这个意思吧）这段话引起了我的思考&lt;/p&gt;

&lt;p&gt;至于思考了啥？晚上回去再说，学习！😂&lt;/p&gt;

&lt;p&gt;to be continue&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>汉家江湖-起源</title>
      <link>https://hueralin.github.io/2019/hjjh-01/</link>
      <pubDate>Sun, 28 Jul 2019 12:22:08 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/hjjh-01/</guid>
      <description>&lt;p&gt;不知何时起，对汉服有了兴趣～&lt;/p&gt;

&lt;p&gt;能做什么？
1. 维护一个像B站二次元的网站（搞活动）
2. 汉服实体店
3. 联动武侠IP，电影？动漫？
4. 侠客栈（民宿）
5. IP手办？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>实习项目的Header结构解析</title>
      <link>https://hueralin.github.io/2019/zkheader/</link>
      <pubDate>Sun, 28 Jul 2019 00:07:10 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/zkheader/</guid>
      <description>&lt;p&gt;最近在做公司的项目，更改移动端Header的现有布局。&lt;br /&gt;
Header是React组件，点击按钮出现侧边栏导航。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面简单来介绍一下Header的结构：&lt;/strong&gt;&lt;br /&gt;
Header接受了3个props，分别是“userInfo”、“changeNavState”、“style”。&lt;br /&gt;
userInfo是用户信息，changeNavState是用来更改侧边导航状态的函数，style是一个类样式。&lt;/p&gt;

&lt;p&gt;以上几个props都交由PropTypes来验证参数的合法性。&lt;br /&gt;
该Header组件内仅维护了一个状态，那就是 subNav，即侧边导航栏的显示与否，changeNavState函数改变的就是它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在render渲染函数中：&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;const { userInfo, style } = this.props&lt;/code&gt;&lt;br /&gt;
根据是否有userInfo.avatar属性来初始化headUrl变量（有则赋值为用户头像URL，无则赋值为默认头像URL）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接下来return一个JSX，&lt;/strong&gt;&lt;br /&gt;
首先判断subNav是否为真，真则显示侧边导航。&lt;br /&gt;
然后是左右布局，左边是点击显示侧边导航的下拉按钮和点击能返回主页的LOGO，右边是用户头像。&lt;br /&gt;
左边的导航按钮添加点击事件（调用changeNavState函数），通过控制subNav状态来显示和隐藏侧边导航。&lt;br /&gt;
右边判断userInfo.id属性，有则根据headeUrl显示用户头像，否则显示默认头像。默认头像图标添加点击跳转登录事件。&lt;/p&gt;

&lt;p&gt;其中userInfo属性是由connect函数连接的， userInfo来自于Redux的State。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mac使用技巧</title>
      <link>https://hueralin.github.io/2019/mactips/</link>
      <pubDate>Sat, 27 Jul 2019 17:21:45 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/mactips/</guid>
      <description>&lt;p&gt;&lt;strong&gt;VSCODE使用命令行打开目录&lt;/strong&gt;&lt;br /&gt;
&amp;gt;相关知识：环境变量的设置&lt;/p&gt;

&lt;p&gt;环境变量的分类：系统级和用户级&lt;br /&gt;
系统级：对所有用户生效的永久性变量（/etc/profile）&lt;br /&gt;
用户级：对单一用户生效的永久性变量（～/.bash_profile）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;查看单个环境变量&lt;code&gt;echo $PATH&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;查看所有环境变量&lt;code&gt;env&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;修改环境变量&lt;code&gt;PATH=&amp;quot;xxxx&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看所有本地定义的shell变量&lt;code&gt;set&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;删除变量&lt;code&gt;unset VNAME&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;设置只读变量&lt;code&gt;readonly VNAME&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用export指令添加环境变量：&lt;br /&gt;
&lt;code&gt;vim ~/.bash_profile&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;输入 export JAVA_HOME=/usr/java/jdk&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;输入 export PATH=$JAVA_HOME/bin:$PATH&lt;/code&gt;&lt;br /&gt;
添加完成后新的环境变量不会立即生效，调用source ~/.bash_profile 该文件才会生效&lt;/p&gt;

&lt;p&gt;使用export命令添加临时环境变量：&lt;br /&gt;
&lt;code&gt;命令行下输入 export MALIN=&#39;malin&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用code命令用VSCODE打开目录：&lt;br /&gt;
1. 在VSCODE中 command+shift+P -&amp;gt; 输入shell command -&amp;gt; 点击提示Shell Command: Install ‘code’ command in PATH运行&lt;br /&gt;
2. 在终端中使用 code 目录路径 打开目录（vscode）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HOC---高阶组件</title>
      <link>https://hueralin.github.io/2019/hoc/</link>
      <pubDate>Sat, 27 Jul 2019 12:37:17 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/hoc/</guid>
      <description>&lt;p&gt;推荐文章：&lt;a href=&#34;https://github.com/brickspert/blog/issues/2&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;助你完全理解React高阶组件（Higher-Order Components）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;简单讲，高阶组件就是一个函数，以组件为参数，返回另一个组件。&lt;/p&gt;

&lt;p&gt;高阶组件的目的就是为了复用，可能有很多人不理解，“组件不就是用来复用的么，为什么还要出来一个高阶组件呢？”。&lt;/p&gt;

&lt;p&gt;举个例子，有这么一个需求：&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Git Reset</title>
      <link>https://hueralin.github.io/2019/gitreset/</link>
      <pubDate>Fri, 26 Jul 2019 17:41:51 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitreset/</guid>
      <description>

&lt;p&gt;惊了！本来想撤销上一次commit，但保留工作区的修改，但是手残加了 &amp;ndash;hard 参数，修改全没了！！！&lt;br /&gt;
后来，运行了一遍&lt;code&gt;git reflog branchName&lt;/code&gt;, 查看了下该分支上的历史记录，找到reset操作之前的历史，执行&lt;code&gt;git reset --hard reset之前的记录点&lt;/code&gt;回来了！！！&lt;/p&gt;

&lt;h1 id=&#34;回来了&#34;&gt;回来了！！！！&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Git取消对某个文件的跟踪&lt;/strong&gt;&lt;br /&gt;
1. &lt;code&gt;git rm --cached readme.md&lt;/code&gt;    删除readme.md的跟踪，并保留在本地。
2. &lt;code&gt;git rm --f readme.md&lt;/code&gt;    删除readme.md的跟踪，并且删除本地文件。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Git分支</title>
      <link>https://hueralin.github.io/2019/gitbranch/</link>
      <pubDate>Fri, 26 Jul 2019 16:45:41 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitbranch/</guid>
      <description>&lt;p&gt;&lt;strong&gt;分支就是一个指向单个commit的指针&lt;/strong&gt;&lt;br /&gt;
&lt;img src=&#34;https://hueralin.github.io/img/posts/fork-commit.jpg&#34; alt=&#34;分支指向单个commit&#34; title=&#34;&#39;fork-commit&#39;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;分支基本操作：&lt;br /&gt;
1. 分支改名：&lt;code&gt;git branch -m oldName newName&lt;/code&gt;&lt;br /&gt;
2. 删除分支：&lt;code&gt;git branch -d feature&lt;/code&gt;&lt;br /&gt;
3. 从master签出feature：&lt;code&gt;git checkout -b feature master&lt;/code&gt;&lt;br /&gt;
4. 查看本地分支：&lt;code&gt;git branch&lt;/code&gt;&lt;br /&gt;
5. 查看远程分支：&lt;code&gt;git branch -r&lt;/code&gt;&lt;br /&gt;
6. 查看所有分支：&lt;code&gt;git branch -a&lt;/code&gt;&lt;br /&gt;
7. 合并分支：&lt;code&gt;git merge B&lt;/code&gt; 要想将B分支合并到A分支，首先要切换回A分支，在执行merge命令&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Zhike</title>
      <link>https://hueralin.github.io/2019/zhike/</link>
      <pubDate>Fri, 26 Jul 2019 15:48:33 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/zhike/</guid>
      <description>&lt;p&gt;线上分支：production&lt;br /&gt;
测试分支：master（www.dev.xxxxxx）&lt;br /&gt;
迭代分支：release-3.xxx&lt;/p&gt;

&lt;p&gt;在一个迭代开始后，各种开发新特性，修复BUG，当这些工作做完时，需要将所有的改动都合并到release分支上，&lt;br /&gt;
作为一次迭代，再合并到master分支（dev）进行测试，测试没问题后再合并到production分支上，发布（上线）。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Git pull 的使用</title>
      <link>https://hueralin.github.io/2019/gitpull/</link>
      <pubDate>Tue, 23 Jul 2019 14:37:19 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitpull/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;语法：git pull &amp;lt;选项&amp;gt; &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意：和git push的语法顺序稍有不同&lt;br /&gt;
git push 的语法为：&lt;code&gt;git pull &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt;&lt;/code&gt;&lt;br /&gt;
git pull 意为从远程分支的最新版本拉取下来并于本地分支合并&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;git pull origin master:dev&lt;/code&gt; 将origin的master分支拉取并合并到本地的dev分支&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git pull origin master&lt;/code&gt;  省略了本地分支名，即拉取并合并到本地分支&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git pull origin&lt;/code&gt;  若有 某远程分支与当前分支有追踪关系，则远程分支名也可以省略&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git pull&lt;/code&gt; 若只有一个远程主机，且只有一个远程分支与当前分支有追踪关系，则可以直接git pull&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;git pull相当于git fetch和git merge的简写&lt;br /&gt;
比如：&lt;code&gt;git pull origin dev&lt;/code&gt; 相当于 &lt;code&gt;git fetch origin dev&lt;/code&gt; + &lt;code&gt;git merge origin/dev&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;未完待续&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fork工作流</title>
      <link>https://hueralin.github.io/2019/fork/</link>
      <pubDate>Tue, 23 Jul 2019 10:34:46 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/fork/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Fork工作流  实现协同开发&lt;/strong&gt;&lt;br /&gt;
作为实习新人，在参与公司项目的开发时被要求使用Fork工作流，Fork工作流实际上就是从GitHub上fork一个原仓库，并与原仓库代码保持同步的一种工作方式。&lt;br /&gt;
Fork工作流不再是只有一个中央代码库，而是给予每个人一个远程仓库（origin），外加一个唯一的中央仓库（upstream，或称为官方仓库）。点击Fork时就会生成一个自己的远程仓库，每次开发者提交时都会先将自己的贡献提交到origin，然后发起一个Pull Request请求给中央仓库，中央仓库的管理者会决定是否将你的代码提交到中央仓库，其他人都没这个权限。这使得管理者可以接受任何人的提交，而不需要给它们中央仓库的权限。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;具体流程&lt;/strong&gt;&lt;br /&gt;
1. 从原仓库fork到自己的origin&lt;br /&gt;
2. &lt;code&gt;git clone xxxxxx&lt;/code&gt; 将origin克隆到本地&lt;br /&gt;
3. &lt;code&gt;git remote add upstream xxxxx&lt;/code&gt;  指向上游仓库，即原仓库&lt;br /&gt;
4. &lt;code&gt;git checkout -b feature-xx origin/dev&lt;/code&gt; 从远程分支检出本地分支进行开发&lt;br /&gt;
5. 开发、修改。。。。提交。。。&lt;br /&gt;
6. &lt;code&gt;git push origin feature-xx&lt;/code&gt; 将本地feature分支push到origin&lt;br /&gt;
7. 发起Pull Request请求管理员合并&lt;br /&gt;
8. 上述合并可能会导致冲突，因为本地仓库可能比较旧了，需要更新&lt;br /&gt;
9. &lt;code&gt;git checkout dev&lt;/code&gt; 切回dev分支&lt;br /&gt;
10. &lt;code&gt;git pull upstream dev&lt;/code&gt; 从原仓库拉取dev分支的最新版本,更新本地的dev分支&lt;br /&gt;
11. &lt;code&gt;git checkout -b feature-merge-dev dev&lt;/code&gt; 从更新后的本地dev检出合并分支，并切换为该分支&lt;br /&gt;
12. &lt;code&gt;git merge feature-xx&lt;/code&gt; 合并你的修改，即feature-xx分支上的内容&lt;br /&gt;
13. &lt;code&gt;git branch -m feature-merge-dev feature-xx&lt;/code&gt; 将合并分支改名为feature-xx 覆盖原分支&lt;br /&gt;
14. &lt;code&gt;git push origin feature-xx&lt;/code&gt; push后再Pull Request就不会发生冲突了&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Git push 的使用</title>
      <link>https://hueralin.github.io/2019/gitpush/</link>
      <pubDate>Mon, 22 Jul 2019 14:32:37 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitpush/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;语法：git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt; ：&amp;lt;远程分支名&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;git push origin master&lt;/strong&gt;&lt;br /&gt;
最常用的一个写法，忽略了远程分支名，将本地master分支推送到origin中与之有追踪关系的对应分支（通常同名），若没有则创建一个对应的远程分支。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git push origin :master&lt;/strong&gt;&lt;br /&gt;
忽略了本地分支名，意味着要推送一个本地的空分支到指定远程分支，即删除指定的远程分支，相当于&lt;code&gt;git push origin --delete master&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git push origin&lt;/strong&gt;&lt;br /&gt;
如果当前分支和远程分支存在对应关系，则两个分支名都可省略掉，直接推送当前分支到对应的远程分支。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git push&lt;/strong&gt;&lt;br /&gt;
如果只有一个远程主机，且只有一个与当前分支对应的远程分支，那么就可以全都省略，直接git push。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git push -u origin master&lt;/strong&gt;&lt;br /&gt;
如果对应多个远程主机，-u 则指定一个默认主机，以后就可以直接使用&lt;code&gt;git push&lt;/code&gt;推送当前分支到远程对应分支。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git push &amp;ndash;all origin&lt;/strong&gt;&lt;br /&gt;
不管是否存在对应的远程分支，将本地的所有分支全部推上去。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git push &amp;ndash;force origin&lt;/strong&gt;&lt;br /&gt;
一般情况下本地仓库比远程仓库旧的话会要求你先&lt;code&gt;git pull&lt;/code&gt;进行更新，而 &amp;ndash;force 表明不要更新，直接推上去。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;git push origin &amp;ndash;tags&lt;/strong&gt;&lt;br /&gt;
不推送分支，只推送标签。&lt;br /&gt;
&amp;mdash;&lt;br /&gt;
&lt;strong&gt;关于追踪关系&lt;/strong&gt;&lt;br /&gt;
追踪即本地分支跟进远程分支的变化，用于push、pull、merge等&amp;hellip;&lt;br /&gt;
&lt;em&gt;追踪远程分支&lt;/em&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clone&lt;/code&gt; 一般克隆下来的项目将自动创建master分支，并且自动关联到远程的master分支上&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch -u 远程主机/远程分支名 本地分支名&lt;/code&gt; 设置本地分支跟踪远程分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout -b 本地分支名 远程主机/远程分支名&lt;/code&gt; 从远程分支中签出本地分支&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch -vv&lt;/code&gt; 查看本地分支和远程分支的跟踪关系&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>用webpack搭建简易的React应用</title>
      <link>https://hueralin.github.io/2019/createreactwithwebpack/</link>
      <pubDate>Sun, 21 Jul 2019 00:19:54 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/createreactwithwebpack/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Emmm,步骤清单😂&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;npm init -y&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm i webpack webpack-cli webpack-dev-server --save-dev&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm i react react-dom --save&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm i babel-core babel-loader@7 babel-preset-es2015 babel-preset-react --save-dev&lt;/code&gt;&lt;br /&gt;
需要安装的包差不多就这些了，接下来配置webpack.config.js文件&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
    entry: &amp;quot;./index.jsx&amp;quot;,
    output: {
        path: __dirname + &amp;quot;/public&amp;quot;,
        filename: &amp;quot;bundle.js&amp;quot;
    },
    module: {
        rules: [
            {
                test: /\.jsx$/,
                loader: &amp;quot;babel-loader&amp;quot;
            }
        ]
    },
    devServer: {
        contentBase: &amp;quot;./public&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;在package.json文件中添加脚本&lt;br /&gt;
5.1. &lt;code&gt;&amp;quot;build&amp;quot;: &amp;quot;webpack&amp;quot;&lt;/code&gt;打包&lt;br /&gt;
5.2. &lt;code&gt;&amp;quot;dev&amp;quot;: &amp;quot;webpack-dev-server --open --inline&amp;quot;&lt;/code&gt;启动测试服务器&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在package.json文件里配置&lt;code&gt;&amp;quot;babel&amp;quot;: {&amp;quot;presets&amp;quot;: [&amp;quot;es2015&amp;quot;, &amp;quot;react&amp;quot;]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在public目录下创建index.html，引用同目录下的bundle.js文件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;运行下试试？？？ Emmm，这个代码块有点丑啊😂&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>搭个窝，储点儿粮，准备过冬！</title>
      <link>https://hueralin.github.io/2019/life20190720/</link>
      <pubDate>Sat, 20 Jul 2019 23:28:34 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/life20190720/</guid>
      <description>&lt;p&gt;今天总算把我的小窝搭建起来了，hugo + github pages 还真不错，感谢该hugo主题的作者，UI很好看。
为什么要放在GiHub上而不是自己前后端+服务器啥的一通瞎搞呢？记得有人说过，刚开始做博客的时候大包大揽，前后端都自己做，确实考验技术也很有成就感，或许也是一时兴起，刚接触博客，饶有趣味，可后来操心太多，可能还会修复bug，还不时续费维护，那时才想起来，”我就是要发篇博客嘛，那么麻烦干什么，都不能专心写作了“，于是github静态博客成了首选（毕竟CSDN、博客园、简书啥的不能定制），通过简单的Markdown语法+GitHub基础就可以发布一篇博客了，岂不美哉～ 可以在该博客上发发技术文章，也可以记录学习和生活，简简单单，专心写作。今天也算是里程碑的一天吧，有此博客就像在北京有了一套房（哈哈哈😂，有些夸张～），实习的日子，加油！&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>