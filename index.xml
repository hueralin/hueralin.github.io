<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>狐耳的雪原 on 狐耳的雪原</title>
    <link>https://hueralin.github.io/</link>
    <description>Recent content in 狐耳的雪原 on 狐耳的雪原</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 04 Jan 2020 20:18:21 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LeetCode.547 朋友圈</title>
      <link>https://hueralin.github.io/2020/friends/</link>
      <pubDate>Sat, 04 Jan 2020 20:18:21 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2020/friends/</guid>
      <description>

&lt;p&gt;班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。&lt;/p&gt;

&lt;p&gt;给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;输入:
[[1,1,0],
 [1,1,0],
 [0,0,1]]&lt;/p&gt;

&lt;p&gt;输出: 2&lt;/p&gt;

&lt;p&gt;说明：已知学生0和学生1互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回2。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;输入:
[[1,1,0],
 [1,1,1],
 [0,1,1]]&lt;/p&gt;

&lt;p&gt;输出: 1&lt;/p&gt;

&lt;p&gt;说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;N 在[1,200]的范围内。
对于所有学生，有M[i][i] = 1。
如果有M[i][j] = 1，则有M[j][i] = 1。&lt;/p&gt;

&lt;h3 id=&#34;并查集解法&#34;&gt;并查集解法&lt;/h3&gt;

&lt;h4 id=&#34;思路&#34;&gt;思路：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;遍历下三角，因为是对称矩阵。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;若i，j是朋友，则看看他俩是不是一个圈子，若不是则合并。&lt;/li&gt;
&lt;li&gt;初始化Set数组各元素值均为自身，即Set[i]=i; 经过一番合并后，遍历Set，Set[i]=i的个数即为朋友圈数。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;执行用时 :32 ms, 在所有 C 提交中击败了92.68%的用户  
内存消耗 :8.3 MB, 在所有 C 提交中击败了100.00%的用户  

int Find(int set[], int x) {
    for(;set[x]!=x;x=set[x]);
    return x;
}

执行用时 :28 ms, 在所有 C 提交中击败了99.29%的用户
内存消耗 :8.2 MB, 在所有 C 提交中击败了100.00%的用户

// 路径压缩
int Find2(int set[], int x) {
    if(set[x] == x)
        return x;
    else return set[x] = Find(set, set[x]);
}

// 按秩归并
void Union(int* set, int* size, int r1, int r2) {
    if(size[r1] &amp;gt; size[r2]) {
        set[r2] = r1;
        size[r1] += size[r2];
    } else {
        set[r1] = r2;
        size[r2] += size[r1];
    }
}

int findCircleNum(int** M, int MSize, int* MColSize){
    int set[MSize], size[MSize], i, j, count=0, root1, root2;
    // 初始化并查集
    for(i=0;i&amp;lt;MSize;i++) {
        set[i]=i;
        size[i] = 1;
    }
    for(i=1;i&amp;lt;MSize;i++) {
        for(j=0;j&amp;lt;MSize &amp;amp;&amp;amp; j&amp;lt;i;j++) {
            // 只遍历下三角
            if(M[i][j] == 1) {
                // 看看他俩分别是哪个圈子的
                root1 = Find2(set, i);
                root2 = Find2(set, j);
                // 圈子不同，合并！
                if(root1 != root2) {
                    Union(&amp;amp;set, &amp;amp;size, root1, root2);
                }
            }
        }
    }
    for(i=0;i&amp;lt;MSize;i++) {
        if(set[i] == i) count++;
    }
    return count;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>并查集</title>
      <link>https://hueralin.github.io/2020/bingchaji/</link>
      <pubDate>Sat, 04 Jan 2020 14:56:19 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2020/bingchaji/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;并查集是一个用树结构表示的集合，来处理一些不相交集的合并及查询问题。
其实并查集就像朋友圈，我们之前都是一个个的个体，后来因为某些共同兴趣而走到了一起，建立了一个小圈子。随着志同道合的人越来越多，这个圈子也越来越大，我们也完全可以通过两个人将两个圈子融合到一起。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;并查集的主要操作有两个：查询某个元素属于哪个集合，合并两个集合。&lt;/p&gt;

&lt;h3 id=&#34;并查集的表示&#34;&gt;并查集的表示&lt;/h3&gt;

&lt;p&gt;并查集是一个树结构，根结点用来代表集合，集合中的其他元素都指向根结点。即我们每个朋友圈都有个代表人物，我们只要报出各自的代表人物的名字，就可以知道我们是不是同一个圈子的人。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define MAXSIZE 10
typedef int SetName;
typedef int Set[MAXSIZE];   // Set数组里面有好多集合
// Set[i] 表示 i 的所属圈子的大佬
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;初始化朋友圈&#34;&gt;初始化朋友圈&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void Init() {
    int i;
    for(i=0;i&amp;lt;MAXSIZE;i++)
        Set[i] = i; // 一开始，每个人的圈子只有自己
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;你哪个圈子的-lo娘&#34;&gt;你哪个圈子的？lo娘?！&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void Find(Set s[], int x) {
    // 直到s[x]=x时循环结束
    for(;s[x]!=x;x=s[x]);
    return x;   // 返回圈内大佬
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;老妹儿啊-咱俩挺投机滴-拉我进圈儿呗&#34;&gt;老妹儿啊~咱俩挺投机滴，拉我进圈儿呗~&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void Union(Set s[], int a, int b) {
    int dalao1 = Find(s, a);
    int dalao2 = Find(s, b);
    // 若他们的大佬是同一个人，那他俩就属于同一个圈子
    if(dalao1 == dalao2) return;
    // 否则，将a的圈子并入b的圈子
    s[dalao1] = dalao2; // dalao1 认 dalao2 为大佬
    // 也可以反过来
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;dalao1：“我TM不服！为什么我要认他做大哥！”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;那好，你们谁手下多谁当老大好吧&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 于是我们增加了一个数组size，用来存储各个圈子的大小。
typedef int Size[MAXSIZE];
// 初始化时 Size[i] = 1;
void Union(Set s[], int a, int b) {
    int dalao1 = Find(s, a);
    int dalao2 = Find(s, b);
    if(dalao1 == dalao2) return;
    if(Size[dalao1] &amp;gt; Size[dalao2]) {
        Size[dalao1] += Size[dalao2];
        Set[dalao2] = dalao1;
    } else {
        Size[dalao2] += Size[dalao1];
        Set[dalao1] = dalao2;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Q：&lt;/strong&gt;  上面为什么要用大小来决定哪个集合合并到哪个集合呢？&lt;br /&gt;
&lt;strong&gt;A：&lt;/strong&gt;  因为集合是个树结构，树是有高度的，而且这个高度和Find的效率息息相关。若一直是高树合并到矮树，那么这个树会越来越高，极端情况就是这个集合是一个链表，Find的时间复杂度会达到O(n)。而我们将矮树合并到高树，整个集合树的高度并不会增加，不会给Find带来影响。&lt;/p&gt;

&lt;h3 id=&#34;按秩归并&#34;&gt;按秩归并&lt;/h3&gt;

&lt;p&gt;按秩归并就是上面那个思想，按秩归并有两种方法。&lt;/p&gt;

&lt;p&gt;1、按规模（见朋友圈合并）&lt;br /&gt;
2、按树高&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// size数组变成height数组，存储各元素所在集合的高度
void Union(Set s[], int a,int b) {
    int dalao1 = Find(s, a);
    int dalao2 = Find(s, b);
    if(dalao1 == dalao2) return;
    if(height[dalao1] &amp;gt; height[dalao2]) {
        Set[dalao2] = dalao1;
    } else {
        if(height[dalao1] == height[dalao2]) height[dalao2]++;
        Set[dalao1] = dalao2;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;路径压缩&#34;&gt;路径压缩&lt;/h3&gt;

&lt;p&gt;若我们每次都查询Set集合的最后一个元素的圈内大佬，查了n次，那最坏情况下时间复杂度为O(n^2)。&lt;br /&gt;
所以我们需要压缩一下，是集合树尽量扁平化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void Find(Set s[], int x) {
    if(s[x] == x) {
        return x;
    } else {
        return s[x] = Find(s, s[x]);
    }
}
// 这样，当我们一层层查到了x的圈内大佬是谁，  
// 就将这一查找路径上的所有人的上级直接指向圈内大佬（即都是大佬的直属小弟了），  
// 那么下一次查找时就不用一层层的找了，节省了时间。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/bcj2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;小结：并查集有两种不同的表示形式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 基本形式（结构体数组）
typedef struct Node {
    ElemType data;
    int parent;
}Set[MAXSIZE];

// 精简形式（普通数组）
typedef int Set[MAXSIZE];
// 集合中n个元素可以用下标0~n-1表示(即第一个元素为0，该元素所属圈子的大佬的下标为Set[0])。

/*
   还有一种方式是 Set[根下标] 不再为根下标本身，而是负的树高或负的集合大小。
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，这两种形式的Find和Union的实现方式也不一样。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/bcj.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>对Redux的理解</title>
      <link>https://hueralin.github.io/2019/redux-sourcecode/</link>
      <pubDate>Tue, 15 Oct 2019 15:53:24 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/redux-sourcecode/</guid>
      <description>

&lt;p&gt;最近根据网课实现了一遍Redux，现在来说下自己的理解，&lt;a href=&#34;https://github.com/hueralin/myRedux&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;myRedux&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;react产生的原因&#34;&gt;React产生的原因&lt;/h2&gt;

&lt;p&gt;或者说，我为什么使用Redux。在我编写Redux代码的过程中遇到的最棘手的问题就是共享状态，不仅仅是组件传值，组件传值是发生在父子组件等具有嵌套关系的情况下，而在兄弟组件甚至什么关系都扯不上的组件之间，只能称为共享状态。在Redux未出现前，父子组件传值靠的是props，在层级非常深的情况下，这种方法就显得非常麻烦。另外一种父子组件传值的方法就是Context，Context 提供了一种在组件之间传递状态的方式，而不必显式地通过组件树的逐层传递props。虽然它也可以用于组件传值，但这并不是它的本职工作。Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，即共享数据。而组件传值发生在父子组件，祖先和孙子组件之间，也就是说这种情况下的作用范围比较小（局部的），还可能有交叉的情况，this.context的指向就已经很模糊了，若有好多地方都这么用的话，也是一场灾难。也就是说Context方法使数据变得混乱、分散。（据说最新的Context API非常好用&amp;hellip;&amp;hellip;😂）&lt;/p&gt;

&lt;h2 id=&#34;redux&#34;&gt;Redux&lt;/h2&gt;

&lt;p&gt;Redux是一个不依赖于任何前端框架的JS状态管理库，Redux的思想是将应用的所有状态放在一起，集中管理，也就是放在全局。任何组件都不能直接修改状态，必须通过store对象的dispatch方法去发送一个action指令，通知reducer按照指令修改store中的状态。网课上实现的方式用闭包实现的单例模式，将state封装在store内部，向外暴露了三个API，分别是getState、dispatch、subscribe。订阅状态用subscribe、获取状态用getState、修改状态用dispatch。&lt;/p&gt;

&lt;h3 id=&#34;createstore&#34;&gt;createStore&lt;/h3&gt;

&lt;p&gt;store是一个状态管理仓库，通过createStore方法创建。该方法创建了个闭包，返回一个store对象，里面包含上述三个方法来实现对状态的管理。单纯的使用Redux，就是在入口文件创建一个store，作为全局的状态仓库。
其他组件需要访问状态的话就将其导入进组件，使用API访问。&lt;/p&gt;

&lt;h3 id=&#34;action&#34;&gt;action&lt;/h3&gt;

&lt;p&gt;action即指令，一个含有type属性的对象。type指明的是这个命令的内容或目的，表明这个命令是干嘛的。为什么这么设计呢？我认为是为了保证状态的安全性，因为指令是用户（程序员）发出的，万一这个指令不合法（可能是误操作），可能会对state造成破坏，同时type的设置也让指令更加语义化。&lt;/p&gt;

&lt;h3 id=&#34;reducer&#34;&gt;reducer&lt;/h3&gt;

&lt;p&gt;reducer是一个纯函数，它接收旧状态和action，返回新状态。reducer是唯一一个有权修改状态的人，dispatch发送完指令后会调用它，让reducer来执行指令，reducer会做一次检查，即使用switch来匹配相应的action，执行对应的操作，若没有则返回旧对象（防止不合法的指令）。最后，当状态修改完毕后，通知所有的订阅者更新视图。&lt;/p&gt;

&lt;h3 id=&#34;dispatch&#34;&gt;dispatch&lt;/h3&gt;

&lt;p&gt;dispatch是一个发送指令的操作，即指令分发器。任何状态的修改必须调用该函数，尽管该函数不能直接修改状态。&lt;/p&gt;

&lt;h3 id=&#34;subscribe&#34;&gt;subscribe&lt;/h3&gt;

&lt;p&gt;subscribe是订阅函数，订阅状态的变化。它的参数是一个回调函数，当状态变化时就会调用它。在网课中的实现，这个回调函数是一个固定的写法。当状态变化时我们做什么？当然是重新渲染页面！于是这个回调函数就是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;subscribe(() =&amp;gt; {
    this.setState({ number: store.getState().number })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用setState触发重新渲染，完成了一次store到state的映射。&lt;/p&gt;

&lt;h3 id=&#34;combinereducers&#34;&gt;combineReducers&lt;/h3&gt;

&lt;p&gt;combineReducers是一个合并reducer的函数。reducer接收旧状态和action，返回新状态。reducer函数接收的state有一个默认值，我们可以认为reducer是状态的起点，或者说状态是在这里初始化的。也就是说状态和reducer是相关的，该reducer里面的指令都是对这个状态进行的操作。而我们一般有很多的业务逻辑，会涉及到很多的状态，如果我们都放在一起，那么代码会非常混乱，文件也比较大。因此我们按照业务逻辑划分reducer，让它操作不同的状态。这样分而治之，我们可以给createStore传入不同的reducer来创建不同的store，的确使代码变得简洁大方，业务逻辑清晰。但是我们Redux的初衷是将状态集中起来管理，而我们上述操作违背了这一原则。我们好不容易分开了，为什么要合并回去呢？其实我们最终要的是合并后的单一的store，我们拆分出来只是为了逻辑清晰。combineReducers函数接受一个对象，键为reducer名，值为reducer函数，combineReducers函数返回一个合并后的reducer，这个reducer最终合并出了一个单一的store。具体的操作方法为，初始化一个合并后的state，遍历传入的对象，执行对应的reducer返回各个业务逻辑的state，并以reducer名为键存入合并后的对象中，最后combineReducers返回这个合并后的对象。&lt;/p&gt;

&lt;h2 id=&#34;react-redux&#34;&gt;react-redux&lt;/h2&gt;

&lt;p&gt;react-redux是redux的react版，我们开发React应用一般使用这个，react-redux只是在原有的redux上进行扩展。&lt;/p&gt;

&lt;p&gt;当我们在组件中使用Redux时，会发现有许多操作是重复的。例如：store到state的映射，组件挂载前设置订阅函数，组件销毁时取消订阅，react-redux将这些操作通过一个connect函数封装了起来。&lt;/p&gt;

&lt;p&gt;而且我们之前使用Redux的时候，是将创建的store在各个需要的地方导入，虽然和我们每个组件都要导入React一样，但我们仍需要将其集中在一个地方（如果可以的话，我也不愿意每次都导入React）。react-redux使用一个Provider组件将store放在最顶层，并向下传递。&lt;/p&gt;

&lt;h3 id=&#34;connect&#34;&gt;connect&lt;/h3&gt;

&lt;p&gt;connect函数是一个高阶函数，参数为mapStateToProps函数和mapDispatchToProps函数，返回值也是一个函数。这个返回的函数以一个组件为参数，返回包装后的组件。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { store } from &#39;./store&#39;
let connect = (mapStateToProps, mapDispatchToProps) =&amp;gt; {
    return (Component) =&amp;gt; {
        // 创建一个容器组件
        class Container extends React.Component {
            constructor(props) {
                super(props)
                this.state = {}
            }
            componentWillMount() {
                this.unsubscribe = store.subscribe(() =&amp;gt; {
                    this.setState( mapStateToProps(store.getState()) )
                })
                // 上面只是订阅了一下，并没有拿到store中的数据，所以一开始this.state没有拿到store中的值
                // 所以需要手动更新下状态
                this.setState( mapStateToProps(store.getState()) )
            }
            componentWillUnmount() {
                // 取消订阅
                this.unsubscribe()
            }
            render() {
                // 将映射后的对象作为UI组件的props传入
                return &amp;lt;Component {...this.state} {...mapDispatchToProps(store.dispatch)} /&amp;gt;
            }
        }
        return Container
    }
}
// 使用方法（比如在Counter组件中）
export default connect(mapStateToProps, mapDispatchToProps)(Counter)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据上面的代码可以看到，connect将原组件封装了一层，封装的操作即为上面提到的那三个重复的操作。mapStateToProps 和 mapDispatchToProps是将state和dispatch作为原组件的参数传进原组件，也就不用每次都在组件中导入store了。&lt;/p&gt;

&lt;h3 id=&#34;provider组件&#34;&gt;Provider组件&lt;/h3&gt;

&lt;p&gt;这个组件就是将store放在了应用程序的最顶层，给最顶层的组件包装一层。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;
import PropTypes from &#39;prop-types&#39;

class Provider extends React.Component {
    getChildContext() {
        return { store: this.props.store }
    }
    render() {
        // 渲染子组件
        return ( this.props.children )
    }
}
Provider.childContextTypes = {
    store: PropTypes.object
}

export default Provider
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，Provider利用Context API将store放在了context中，它下面的所有组件都可以使用this.context获取到。当然并不是让下面的组件自己调用context API，因为每个需要从store获取数据的组件都被connect封装了，所以应该在connect函数中调用context API，获取store。&lt;/p&gt;

&lt;p&gt;既然也是在connect中获取store，那为什么不直接在connect中获取合并后的store呢？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTPS</title>
      <link>https://hueralin.github.io/2019/https/</link>
      <pubDate>Sat, 12 Oct 2019 14:11:39 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/https/</guid>
      <description>

&lt;h2 id=&#34;http协议的弊端&#34;&gt;HTTP协议的弊端&lt;/h2&gt;

&lt;h3 id=&#34;报文明文通信&#34;&gt;报文明文通信&lt;/h3&gt;

&lt;p&gt;由于HTTP协议本身没有加密手段，所以无法对通信的内容进行加密。因此，一般情况下的HTTP通信都是明文通信的，索引很容易被截获窃听。为了保证通信的安全，必须采取某种外部加密措施。&lt;/p&gt;

&lt;p&gt;加密的方式一般有两种，对&lt;strong&gt;通信的加密&lt;/strong&gt;和&lt;strong&gt;对内容的加密&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对通信的加密&lt;/strong&gt;就是 HTTP + SSL/TLS 这种，在真正通信之前先建立一个加密的通信线路。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对内容的加密&lt;/strong&gt;就是先对要发送的内容进行加密，把加密后的内容放进报文里发送，前提是要求客户端和服务器同 时具备加密和解密机制。&lt;/p&gt;

&lt;h3 id=&#34;不进行身份验证&#34;&gt;不进行身份验证&lt;/h3&gt;

&lt;p&gt;HTTP是不进行身份验证的。在TCP三次握手过程中也仅仅是验证双方的收发能力是否完好，并不对通信的双方进行身份验证。也就是说服务器对发来的请求照单全收并且会给对方一个响应。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;无法确定请求发送的目的服务器是真正的服务器。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;无法确定收到响应的客户端是真正的客户端。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;无法确定客户端用户是否有访问权限，因为服务器上的有些信息需要有权限的用户才能访问。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务器照单全收，包括垃圾请求（DoS）。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;无法验证报文的完整性&#34;&gt;无法验证报文的完整性&lt;/h3&gt;

&lt;p&gt;因为HTTP报文是明文发送的，所以中途有可能被篡改，但是HTTP协议没有数据验证功能，对方接受到的数据可能是被篡改过的。例如中间人攻击，当我们在网站上下载一个文件时，文件在传输过程中被篡改，客户端无法确认下载的是否为正确的文件，可能是带有病毒的文件。&lt;/p&gt;

&lt;p&gt;为了有效地防止上面的弊端，我们有必要使用HTTPS。既然单独使用HTTP协议无法确保安全，我们就必修将HTTP协议和其他协议结合起来，共同完成目标。&lt;/p&gt;

&lt;h2 id=&#34;https&#34;&gt;HTTPS&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;HTTPS = HTTP + 加密 + 身份认证 + 数据完整性验证&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTTPS 即 HTTP Secure，是身披SSL外壳的HTTP。传统的通信方式是HTTP直接和TCP通信，而HTTPS在中间加了一层SSL，演变成先和 SSL通 信，再由 SSL和 TCP 通信。有了SSL加持，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护 这些功能。&lt;/p&gt;

&lt;h3 id=&#34;公钥加密技术&#34;&gt;公钥加密技术&lt;/h3&gt;

&lt;p&gt;现在常用的加密技术里有两种：对称加密　和　非对称加密。&lt;/p&gt;

&lt;p&gt;对称加密就是双方都持有约定好的加密解密算法，但是一旦双方约定好的加密解密算法被第三方知道了，加密也就没有了意义。所以如何将约定好的加密解密算法传给对方是个问题，而且还得保存好自己手中的密钥。&lt;/p&gt;

&lt;p&gt;非对称加密采用了双密钥的方法，一对公私钥。公钥加密私钥解密，或者私钥加密公钥解密。公钥可以公开，四月自己保存好。这样，传递只传公钥，不怕被别人知道，毕竟只能私钥解开。所以公钥加密，私钥解密比较安全。&lt;/p&gt;

&lt;h3 id=&#34;混合加密&#34;&gt;混合加密&lt;/h3&gt;

&lt;p&gt;HTTPS采取的是对称加密和非对称加密相结合的方法，因为非对称加密的开销比较大。HTTPS使用非对称加密传递对称加密所需要的密钥，保证密钥的安全，然后再使用对称加密方法进行通信。&lt;/p&gt;

&lt;h3 id=&#34;证明公钥正确性-可信度-的证书&#34;&gt;证明公钥正确性（可信度）的证书&lt;/h3&gt;

&lt;p&gt;即使使用了“混合加密”也是有问题的，因为我们没法确认公钥的安全性，万一拿到的公钥是假的呢？如果连SSL这一层都无法安全通过，那接下来的通信一定是不可靠的。&lt;/p&gt;

&lt;p&gt;为了解决上面的问题，我们使用了一种叫做证书的东西，由数字证书颁发机构（CA）发布的一种电子凭证。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;申请流程：&lt;/strong&gt;&lt;br /&gt;
1. 申请人向CA提出公钥证书的申请&lt;br /&gt;
2. CA对使用自己的私钥对申请人的一些基本信息以及申请人的公钥进行签名（相当于加盖发证书机 构的公章）&lt;br /&gt;
3. 将公钥放到公钥证书中，发给申请人&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;客户端收到服务器发来的公钥证书后的验证流程：&lt;/strong&gt;&lt;br /&gt;
客户端使用CA的公钥（一般内置在浏览器中），对证书上的数字签名进行验证，验证通过说明是权威机构（说明机构可信）颁发的证书，该服务器的公钥可信，身份可信。&lt;/p&gt;

&lt;h3 id=&#34;https通信流程&#34;&gt;HTTPS通信流程&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/https.png&#34; alt=&#34;《图解HTTP》&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;客户端通过发送 Client Hello 报文开始 SSL通信。报文中包含客户端支持的 SSL的指定版本、加密组件列表（所使用的加密算法及密钥长度等）。（你看，我支持这些加密算法，你支持哪个？选一下吧！）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务器可进行 SSL通信时，会以 Server Hello 报文作为应答。报文中包含 SSL版本以及加密组件。加密组件内容是从接收到的客户端加密组件内筛选出来的。（我支持这个，咱就用这个吧）。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务器发送 Certificate 报文，报文中包含公开密钥证书。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的&lt;strong&gt;“SSL握手协商”&lt;/strong&gt;部分结束。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;SSL第一次握手结束。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;客户端以 Client Key Exchange 报文作为回应。报文内容为用服务器公钥加密的一串随机数字。（我用你的公钥加密了一串数字，看看你能不能打开）。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用上面那串随机数字作为密钥加密。（你一定要打开哦&amp;hellip;&amp;hellip;不然咱俩就没法通信了呢&amp;hellip;&amp;hellip;嘿嘿嘿~~~）。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务器同样发送 Change Cipher Spec 报文。（我解出来了，你看是不是这串随机数字）。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务器同样发送 Finished 报文。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;服务器和客户端的 Finished 报文交换完毕之后，SSL连接 就算建立完成。当然，通信会受到 SSL的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。MAC是通过某种算法对报文内容做的散列，对方拿到后用同样的方法对保温内容做散列，看两个散列值是否一样，一样的话说明没有被篡改。&lt;/p&gt;

&lt;h3 id=&#34;https-比-http慢&#34;&gt;HTTPS 比 HTTP慢&lt;/h3&gt;

&lt;p&gt;慢！确实慢！能不慢吗，搞了那么多加密解密，情报传递，心累！《图解HTTP》上说比HTTP能慢到2-100倍！妈耶~&lt;/p&gt;

&lt;p&gt;所以，HTTPS也不能滥用。如果是非敏感信息的话，可以考虑使用HTTP，但如果是账号密码等敏感信息，据不得不使用HTTPS了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用Node.js讲解Cookie</title>
      <link>https://hueralin.github.io/2019/cookie/</link>
      <pubDate>Sat, 12 Oct 2019 09:50:42 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/cookie/</guid>
      <description>

&lt;h2 id=&#34;cookie&#34;&gt;Cookie&lt;/h2&gt;

&lt;p&gt;靠死记硬背是学不了东西的&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;搭建简易的服务器环境&#34;&gt;搭建简易的服务器环境&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let express = require(&#39;express&#39;)
let app = express()
app.get(&#39;/&#39;, (req, res) =&amp;gt; {
    // 在响应中添加cookie
    res.cookie(&#39;background&#39;, &#39;skyblue&#39;)
    res.cookie(&#39;color&#39;, &#39;green&#39;)
    res.send(&#39;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&#39;)
})
app.listen(3000)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;发起请求并分析字段&#34;&gt;发起请求并分析字段&lt;/h3&gt;

&lt;p&gt;我们请求下试试看：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/cookie1.png&#34; alt=&#34;访问localhost:3000&#34; /&gt;&lt;/p&gt;

&lt;p&gt;一开始，我们假设当前域名下是没有cookie的，第一次请求的时候也不会带上cookie。第一次响应时，服务器设置了两个cookie，如上图的set-cookie字段。当我们再次请求时，浏览器会自动带上cookie，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/cookie2.png&#34; alt=&#34;刷新页面&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：我们设置cookie前，响应报文没有set-cookie字段，请求报文也不会有cookie字段。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为我们设置了两个cookie，见上图，cookie字段里不同的cookie之间是通过；和 空格 分割的。&lt;/p&gt;

&lt;p&gt;以上就是cookie的大体工作流程。下面我们来介绍下cookie。&lt;/p&gt;

&lt;h3 id=&#34;cookie-1&#34;&gt;Cookie&lt;/h3&gt;

&lt;p&gt;我们知道HTTP协议是无状态的协议，即TCP连接断开后，当浏览器再次请求访问时，服务器根本不认识这个客户端。但是我们在某些情况下却又希望服务器能记住客户端的状态，这时cookie出现了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的 Cookie。-————《图解HTTP》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;cookie的属性&#34;&gt;Cookie的属性&lt;/h4&gt;

&lt;p&gt;Cookie的属性有六种：&lt;br /&gt;
1. NAME=VALUE
2. expires=日期
3. path=路径
4. domain=域名
5. secure
6. httpOnly&lt;/p&gt;

&lt;h4 id=&#34;expires&#34;&gt;expires&lt;/h4&gt;

&lt;p&gt;指定浏览器可发送 Cookie 的有效期，若省略的话，则有效期为该会话结束，即关闭浏览器。&lt;/p&gt;

&lt;p&gt;在HTTP/1.1中有个max-age属性，该属性值设置的是相对时间，以秒为单位，优先级比expires高。&lt;/p&gt;

&lt;h4 id=&#34;path&#34;&gt;path&lt;/h4&gt;

&lt;p&gt;限制指定 Cookie 的发送范围的文件目录&lt;/p&gt;

&lt;h4 id=&#34;domain&#34;&gt;domain&lt;/h4&gt;

&lt;p&gt;指定cookie发送的域名，即发送请求时如果当前URL的域名是该domain或者是该域名的子域，就可以携带该cookie。子域可以访问父域的cookie，即从子域发起请求时，cookie字段会带上父域的cookie字段，反之不行。&lt;/p&gt;

&lt;h4 id=&#34;secure&#34;&gt;secure&lt;/h4&gt;

&lt;p&gt;用于限制Web页面仅在HTTPS安全连接时，才可以发送 Cookie。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;app.get(&#39;/&#39;, (req, res) =&amp;gt; {
    // 在响应中添加cookie
    res.cookie(&#39;background&#39;, &#39;skyblue&#39;, {
        secure: true
    })
    res.send(&#39;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&#39;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/cookie.png&#34; alt=&#34;带secure的cookie&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可见，服务端设置了secure后，浏览器发现自己的协议并不是HTTPS，所以再次刷新时没有携带cookie。&lt;/p&gt;

&lt;h4 id=&#34;httponly&#34;&gt;httpOnly&lt;/h4&gt;

&lt;p&gt;Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本 无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。&lt;/p&gt;

&lt;h3 id=&#34;cookie的生存周期&#34;&gt;Cookie的生存周期&lt;/h3&gt;

&lt;p&gt;前面说到expires属性可以设置cookie的过期时间，但它毕竟是个可选项，也可以不设置。那么若不设置过期时间，cookie会保存多久呢？如果我们在服务器端不设置expires等过期时间，那么此时的cookie被称为“session cookie”，即其生命周期为会话期，当浏览器窗口关闭时就会消失，session cookie保存在内存中。比如下面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/cookie4.png&#34; alt=&#34;没设置过期时间,则为session cookie&#34; /&gt;&lt;/p&gt;

&lt;p&gt;而设置了过期时间的cookie则放在硬盘中，存储在硬盘上的cookie可以在不同的浏览器进程间共享。&lt;/p&gt;

&lt;h3 id=&#34;cookie的缺陷&#34;&gt;Cookie的缺陷&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题，除非用HTTPS。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Cookie的大小限制在4KB左右，对于复杂的存储需求来说是不够用的。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;识别不精确，如果在同一台机器上使用多个浏览器，每个浏览器在不同的存储位置保存 Cookie，因此，Cookie 并不能定位到一个具体的人，而是用户,计算机和浏览器的组合。&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果用户在获取了一个 Cookie 之后,点击了浏览器的&amp;rdquo;回退&amp;rdquo;按键,则浏览器的状态和获取Cookie 的状态就出现了不一致（因为父域不能访问子域的cookie，包括path）.例如, 如果网站基于 Cookie 技术实现了购物车的应用,当用户添加了物品后点击了&amp;rdquo;回退&amp;rdquo;按键, 购物车的物品状态可能并没有发生变化.（当然，购物车不会这么实现。）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;cookie安全性&#34;&gt;Cookie安全性&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;偷cookie，利用别人的合法的cookie，入侵账户&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;修改cookie，Emmmm&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;https://juejin.im/entry/5766c29d6be3ff006a31b84e&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Cookie与Session的区别&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CSS Grid 布局</title>
      <link>https://hueralin.github.io/2019/grid/</link>
      <pubDate>Fri, 11 Oct 2019 10:49:22 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/grid/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/grid.png&#34; alt=&#34;Grid兼容性&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;推荐教程：阮一峰&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;妈耶~好长~&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;术语&#34;&gt;术语&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;容器&lt;/strong&gt;和&lt;strong&gt;项目&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;容器就是外面的壳儿~，项目就是它的孩儿（第一层子元素），孙子不算哦~~~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网格线&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;m行n列，就有m+1个水平网格线和n+1个垂直网格线&lt;/p&gt;

&lt;h2 id=&#34;css属性&#34;&gt;CSS属性&lt;/h2&gt;

&lt;p&gt;CSS属性有两种：容器属性 和 项目属性&lt;/p&gt;

&lt;h2 id=&#34;容器属性&#34;&gt;容器属性&lt;/h2&gt;

&lt;h3 id=&#34;display&#34;&gt;display&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;grid：指定一个容器采用网格布局，当然这个容器时块级元素。&lt;/li&gt;
&lt;li&gt;inline-grid：将块级元素变为行内的元素，采取网格布局。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;“注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。”&lt;/p&gt;

&lt;h3 id=&#34;grid-template-rows-columns&#34;&gt;grid-template-rows/columns&lt;/h3&gt;

&lt;p&gt;划分行高和列宽&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/* 3行3列 */
.container {
  display: grid;
  grid-template-columns: 100px 100px 100px;
  grid-template-rows: 100px 100px 100px;
}
/* 也可以使用百分比 */
/*
    如果行列很多的话，这样会比较麻烦，可以使用repeat()
    repeat(n, item) 重复item n次
*/
.container {
  display: grid;
  grid-template-columns: repeat(3, 33.33%);
  grid-template-rows: repeat(3, 33.33%);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;repeat关键字&#34;&gt;repeat关键字&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/* 当然，item也可以是某种模式，比如： */
grid-template-columns: repeat(2, 100px 20px 80px);
/* 这样的话会出现6列，按上面的次序重复排列，但是如果超出容器的宽度呢，
实际上可以给容器设置宽度，但是对内部的项目无效，即使容器的宽度被设为10，
项目也会按照6列排列 */
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;auto-fill关键字&#34;&gt;auto-fill关键字&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/* n 也不止是次数，也可以是 auto-fill 关键字 ，该关键字表明会自动排列，
即容器只要有空间就会一直排下去，直到换行。*/
grid-template-columns: repeat(auto-fill, 200px)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;fr-关键字&#34;&gt;fr 关键字&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/* fr关键字表示比例关系，如下，第二列宽度是第一列的2倍 */
.container {
  display: grid;
  grid-template-columns: 1fr 2fr;
}
/* 当然也可以和长度单位结合使用，如下，第二列和第三列会自动按比例分配剩下的空间。*/
.container {
  display: grid;
  grid-template-columns: 150px 1fr 2fr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;minmax&#34;&gt;minmax()&lt;/h4&gt;

&lt;p&gt;minmax(最小值，最大值)函数产生一个长度范围。值可为像素，可为fr，可为百分比。&lt;/p&gt;

&lt;h4 id=&#34;auto关键字&#34;&gt;auto关键字&lt;/h4&gt;

&lt;p&gt;表示由浏览器自己决定长度，基本上等于单元格的最大宽度，除非单元格设置了min-width，且大于单元格的最大宽度。&lt;/p&gt;

&lt;h4 id=&#34;网格线的名称&#34;&gt;网格线的名称&lt;/h4&gt;

&lt;p&gt;grid-template-columns 和 grid-template-rows还可以设置每条网格线的名称：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.container {
  display: grid;
  grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];
  grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;网格布局允许同一根线有多个名字，比如[fifth-line row-5]。&lt;/p&gt;

&lt;h3 id=&#34;grid-row-column-gap-行-列间距&#34;&gt;grid-row/column-gap 行/列间距&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.container {
  grid-row-gap: 20px;
  grid-column-gap: 20px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;grid-gap-上面两个属性的结合&#34;&gt;grid-gap 上面两个属性的结合&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.container {
  grid-gap: 20px 20px;  /* row/column */
}
/* 如果grid-gap省略了第二个值，浏览器认为第二个值等于第一个值 */
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;grid-template-areas&#34;&gt;grid-template-areas&lt;/h3&gt;

&lt;p&gt;指定区域，一个区域由单个或多个单元格组成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.container {
  display: grid;
  grid-template-columns: 100px 100px 100px;
  grid-template-rows: 100px 100px 100px;
  grid-template-areas: &#39;a b c&#39;
                       &#39;d e f&#39;
                       &#39;g h i&#39;;
}
/* 上面代码划分了9个单元格，对应了 a - i 9个区域 */
/* 当然也可以合并多个单元格，例如： */
grid-template-areas: &#39;a a a&#39;
                     &#39;b b b&#39;
                     &#39;c c c&#39;;
/* 上面代码将九个单元格划分成了a、b、c三个区域。 */
grid-template-areas: &amp;quot;header header header&amp;quot;
                     &amp;quot;main main sidebar&amp;quot;
                     &amp;quot;footer footer footer&amp;quot;;
/* 不需要的区域可以使用 . 来代替 */
grid-template-areas: &#39;a . c&#39;
                     &#39;d . f&#39;
                     &#39;g . i&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;grid-auto-flow&#34;&gt;grid-auto-flow&lt;/h3&gt;

&lt;p&gt;容器项目的排列顺序，默认值是 row，即先行后列，也可以设置为column，即先列后行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;grid-auto-flow: column/row;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个属性还有第二个值，即dense，决定某些项目指定位置以后，剩下的项目怎么自动放置，例如：&lt;br /&gt;
![]()&lt;/p&gt;

&lt;h3 id=&#34;justify-items-align-items&#34;&gt;justify-items &amp;amp;&amp;amp; align-items&lt;/h3&gt;

&lt;p&gt;一个控制单元格内容的水平位置，一个控制单元格内容的垂直位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.container {
  justify-items: start | end | center | stretch;
  align-items: start | end | center | stretch;
}
/* stretch：拉伸，占满单元格的整个宽度（默认值） */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;place-items 属性是上面两个的复合形式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;place-items: &amp;lt;align-items&amp;gt; &amp;lt;justify-items&amp;gt;; /* 如果省略第二个值，则浏览器认为与第一个值相等 */

### justify-content &amp;amp;&amp;amp; align-content

一个控制整个内容区域在容器内的水平位置，一个控制整个内容区域在容器内的垂直位置。

```css
.container {
  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;
  align-content: start | end | center | stretch | space-around | space-between | space-evenly;
}
/* stretch：拉伸，占满单元格的整个宽度（默认值） */
/* space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;place-content 属性是上面两个的复合形式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;place-content: &amp;lt;align-content&amp;gt; &amp;lt;justify-content&amp;gt;; /* 如果省略第二个值，则浏览器认为与第一个值相等 */
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;grid-auto-columns-grid-auto-rows&#34;&gt;grid-auto-columns &amp;amp;&amp;amp; grid-auto-rows&lt;/h3&gt;

&lt;p&gt;当项目出现在所设置的行或列之外时，比如3X3，结果项目比较多，出现在了第四行，但没有给它设置行高，所以浏览器会自动设置多余的单元格，以便放置项目。这两个属性就是来设置多余的网格的行高和列宽的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.container {
  display: grid;
  grid-template-columns: 100px 100px 100px;
  grid-template-rows: 100px 100px 100px;
  grid-auto-rows: 50px; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;项目属性&#34;&gt;项目属性&lt;/h2&gt;

&lt;h3 id=&#34;grid-column-start-grid-column-end-grid-row-start-grid-row-end&#34;&gt;（grid-column-start &amp;amp;&amp;amp; grid-column-end）&amp;amp;&amp;amp;（grid-row-start &amp;amp;&amp;amp; grid-row-end）&lt;/h3&gt;

&lt;p&gt;指定项目的位置，就是指定项目的四个边，即四个网格线。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.item-1 {
  grid-column-start: 2;
  grid-column-end: 4;
}
/* 这个项目在水平方向上以第二个网格线开始，在第四个网格线结束，即占据了两个单元格。 */
/* 它们的值除了数字，还可以是之前设置的网格线名 */
.item-1 {
  grid-column-start: span 2;
}
/* 也可以这么用，使用span关键字，代表跨越，即项目的左右（上下）网格线之间跨越几个单元格 */
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;grid-column-grid-row&#34;&gt;grid-column &amp;amp;&amp;amp; grid-row&lt;/h3&gt;

&lt;p&gt;是上面属性的合并写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.item-1 {
  grid-column: 1 / 3;
  grid-row: 1 / 3;
}
/* 等同于 */
.item-1 {
  grid-column: 1 / span 2;
  grid-row: 1 / span 2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;grid-area&#34;&gt;grid-area&lt;/h3&gt;

&lt;p&gt;指定项目的放置区域：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.item-1 {
  grid-area: e; /* 放置在e区域 */
}
/* 也可以 */
.item {
  /* grid-area: &amp;lt;row-start&amp;gt; / &amp;lt;column-start&amp;gt; / &amp;lt;row-end&amp;gt; / &amp;lt;column-end&amp;gt;; */
  grid-area: 1/1/3/3;   /* 占满4个单元格 */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;justify-self-align-self-place-self&#34;&gt;justify-self &amp;amp;&amp;amp; align-self &amp;amp;&amp;amp; place-self&lt;/h3&gt;

&lt;p&gt;设置项目在单元格内的位置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.item {
  justify-self: start | end | center | stretch;
  align-self: start | end | center | stretch;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>圣杯布局</title>
      <link>https://hueralin.github.io/2019/shengbeibuju/</link>
      <pubDate>Fri, 11 Oct 2019 10:01:26 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/shengbeibuju/</guid>
      <description>

&lt;p&gt;圣杯布局：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;顶部和底部占满屏幕宽度&lt;/li&gt;
&lt;li&gt;中间的部分是一个三栏布局&lt;/li&gt;
&lt;li&gt;三栏布局两侧固定宽度，中间部分自适应&lt;/li&gt;
&lt;li&gt;中间部分的高度是三栏中最高的区域的高度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总体来说，还是一个三栏布局，这也是重点部分。&lt;/p&gt;

&lt;h4 id=&#34;浮动实现&#34;&gt;浮动实现&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;style&amp;gt;
    .top,.bottom {
        height: 100px;
        margin: 5px 0;
        background-color: orange;
    }
    .middle {
        margin:5px 0;
    }
    .left,.right {
        width: 200px;
        height: 400px;
        background-color: skyblue;
    }
    .left {
        float: left;
    }
    .right {
        float: right;
    }
    .content {
        overflow: hidden;   /* 形成BFC，防止文本环绕 */
        padding: 0 5px;
        background-color: #eee;
    }
&amp;lt;/style&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;top&amp;quot;&amp;gt;顶部&amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;middle&amp;quot;&amp;gt;
            &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;左侧&amp;lt;/div&amp;gt;
            &amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;右侧&amp;lt;/div&amp;gt;
            &amp;lt;div class=&amp;quot;content&amp;quot;&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;bottom&amp;quot;&amp;gt;底部&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/shengbei1.png&#34; alt=&#34;浮动实现的圣杯布局&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;flex实现&#34;&gt;flex实现&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;style&amp;gt;
    .top,.bottom {
        height: 100px;
        margin: 5px 0;
        background-color: orange;
    }
    .middle {
        display: flex;
        margin:5px 0;
    }
    .left {
        width: 200px;
        height: 300px;
        background-color: red;
    }
    .content {
        flex: 1;    /* 实现中间自适应 */
        margin: 0 5px;
        background-color: yellow;
    }
    .right {
        width: 300px;
        background-color: blue;
    }
&amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;top&amp;quot;&amp;gt;顶部&amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;middle&amp;quot;&amp;gt;
            &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;左侧&amp;lt;/div&amp;gt;
            &amp;lt;div class=&amp;quot;content&amp;quot;&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;哈哈哈哈哈哈&amp;lt;/p&amp;gt;
                ........
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;右侧&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;bottom&amp;quot;&amp;gt;底部&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/shengbei2.png&#34; alt=&#34;flex实现的圣杯布局&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;grid实现&#34;&gt;Grid实现&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;style&amp;gt;
    .container {
        display: grid;
        grid-template-rows: 100px auto 100px;
    }
    header {
        background-color: orange;
    }
    main {
        display: grid;
        grid-template-columns: 200px auto 300px;
        grid-template-rows: 100px 100px 100px;
    }
    main .left {
        grid-row: 1/2;
        background-color: red;
    }
    main .content {
        grid-row: 1/4;
        background-color: yellow;
    }
    main .right {
        grid-row: 1/3;
        background-color: blue;
    }
    footer {
        background-color: #000;
    }
&amp;lt;/style&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
        &amp;lt;header&amp;gt;顶部&amp;lt;/header&amp;gt;
        &amp;lt;main&amp;gt;
            &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;左边&amp;lt;/div&amp;gt;
            &amp;lt;div class=&amp;quot;content&amp;quot;&amp;gt;中间&amp;lt;/div&amp;gt;
            &amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;右边&amp;lt;/div&amp;gt;
        &amp;lt;/main&amp;gt;
        &amp;lt;footer&amp;gt;底部&amp;lt;/footer&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/grid2.png&#34; alt=&#34;圣杯布局的Grid实现&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTP缓存策略</title>
      <link>https://hueralin.github.io/2019/httpcache/</link>
      <pubDate>Wed, 09 Oct 2019 20:00:01 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/httpcache/</guid>
      <description>

&lt;p&gt;我再也不废话了&amp;hellip;&amp;hellip;切入正题!&lt;/p&gt;

&lt;p&gt;HTTP缓存策略有两种:强缓存和协商缓存.&lt;/p&gt;

&lt;p&gt;先大体说一下浏览器缓存的过程:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;浏览器向服务器发起请求前首先向浏览器缓存查询是否有该请求的结果及缓存标识.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;有,则从缓存中读取(强缓存成功),否则再去询问服务器(协商缓存 or 直接请求).&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;强缓存策略&#34;&gt;强缓存策略&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;强缓存的三种情况:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;请求前先去询问浏览器缓存,若有缓存且未失效,则直接从浏览器缓存读取结果,此被称之为&amp;rdquo;强缓存成功&amp;rdquo;.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;强缓存失败&amp;rdquo;, 若有缓存,但已失效,则执行&lt;strong&gt;&amp;ldquo;协商缓存&amp;rdquo;策略.&lt;/strong&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;强缓存失败&amp;rdquo;, 若无缓存, 则向服务器正式发起请求.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;强缓存策略涉及到的HTTP头部: &lt;strong&gt;Cache-Control / expires&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;expires 是 HTTP/1.0 的产物,它的值是一个绝对值,即缓存失效的时间点.浏览器会拿客户端的时间和缓存中的此标识做对比,来判断缓存是否过期.所以它的缺陷比较明显,因为客户端和服务器的时间并不总是同步的,也就是说可能出现误差.(可能影响并不多大,别喷我&amp;hellip;&amp;hellip;)&lt;/p&gt;

&lt;p&gt;Cache-Control 是 HTTP/1.1 的产物,它的值就丰富多了:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;public&lt;/strong&gt;   所有内容都将被缓存(客户端和代理服务器都可以)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;private&lt;/strong&gt;  默认值,只有客户端才能缓存，表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;no-cache&lt;/strong&gt; 只有客户端缓存，强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证器的请求到服务器，即必须经过协商缓存&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;no-store&lt;/strong&gt; 所有内容都不缓存&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;max-age=xxx&lt;/strong&gt;  缓存将于xxx秒后失效&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们一般使用第五种方式&lt;/p&gt;

&lt;p&gt;可以看到cache-control使用的是相对时间,弥补了expires的时间误差缺陷. 在实际应用过程中这两种方式都会有,但是cache-control的优先级要高一些.&lt;/p&gt;

&lt;h3 id=&#34;协商缓存策略&#34;&gt;协商缓存策略&lt;/h3&gt;

&lt;p&gt;协商缓存发生在有缓存但到期的情况下. 实际上, 服务器设置的过期时间是用来表明此时的缓存可能会过期, 但我不能保证, 届时你得向我确认一下, 所以, 缓存并不一定失效了. 和商品的保质期一个道理.&lt;/p&gt;

&lt;p&gt;此时, 我们需要向服务器发起请求, 询问这个缓存能不能用, 如果服务器表示能用, 返回304, 那我们就去缓存中读取, 否则我们再向服务器请求新的数据.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/304.png&#34; alt=&#34;304 Not Modified&#34; /&gt;&lt;br /&gt;
看这个图，请求的时候将缓存中的浏览器标识（if-modified-since）带了上去，响应的时候返回了304以及Last-modified，返回的Last-modified可能会更新。&lt;/p&gt;

&lt;p&gt;协商缓存策略涉及到的HTTP头部: &lt;strong&gt;Last-Modified / If-Modified-Since 以及 Etag / If-None-Match&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Last-Modified / If-Modified-Since&lt;/strong&gt; 是 HTTP/1.1 的产物, last-modified 标识的是资源的最后修改时间, 协商缓存开始时会发请求, 将last-modified的值赋给 请求头 if-modified-since, 向服务器发起询问 &amp;ldquo;这个资源在这个时间后修改了么?&amp;rdquo; 如果没有修改, 则返回304, 浏览器就会从缓存中读取数据, 否则会请求新的数据, 并更新缓存。这个时间是以秒为单位的，所以不太准确。如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Etag / If-None-Match&lt;/strong&gt; 也是 HTTP/1.1 的产物, 过程和上面一样, 只不过Etag是由服务器根据资源内容生成的唯一标识, 具有唯一性. 用资源的最后修改时间作为标识的话不太准确, 因为可能会在1秒内多次修改文件的情况.&lt;/p&gt;

&lt;p&gt;Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高.&lt;/p&gt;

&lt;p&gt;协商缓存在请求数量上和没有缓存是一样的，但是协商缓存命中的话只返回一个状态码，并没有数据，所以体积上要小不少。&lt;/p&gt;

&lt;h3 id=&#34;缓存的位置&#34;&gt;缓存的位置&lt;/h3&gt;

&lt;p&gt;浏览器缓存的位置一般有两个: 硬盘缓存(disk cache) 和 内存缓存(memory cache), 我们打开F12, 可在network选项卡中网络请求的size列查看.&lt;br /&gt;
内存缓存会将编译解析后的文件存放在当前标签页进程的内存中, 读取速度较快。在从内存缓存中获取缓存内容时，浏览器会忽视例如 max-age=0, no-cache 等头部配置（no-store除外）。&lt;/p&gt;

&lt;p&gt;硬盘缓存则是将资源放入硬盘中, 需要进行对硬盘文件做I/O操作, 速度较慢。而正因为硬盘缓存是将资源存放在硬盘中的，是持久存储的，所以允许同一个资源在跨会话甚至跨站点（一般不太可能）的情况下使用。硬盘缓存会严格按照HTTP响应头的缓存标识来缓存资源，不会像内存缓存那样忽视某些缓存标识。&lt;/p&gt;

&lt;p&gt;存在内存中的缓存文件, 会在刷新页面后被直接读取, 如果关闭了该标签页, 再次打开页面会重新请求。而在硬盘中的缓存文件不会这样。&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;强缓存的优先级高于协商缓存, 强缓存失效才会进行协商缓存. 强缓存失效不代表缓存过期, 只是不确定其是否真的过期, 所以需要协商缓存过程来确认一下.&lt;/p&gt;

&lt;p&gt;桥豆麻袋! 不够细, 还有些没深入&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/44789005&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;一文读懂前端缓存&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/29750583&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;HTTP 缓存机制一二三&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://juejin.im/entry/5ad86c16f265da505a77dca4&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;彻底理解浏览器的缓存机制&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>清除浮动</title>
      <link>https://hueralin.github.io/2019/float/</link>
      <pubDate>Wed, 09 Oct 2019 15:16:09 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/float/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;清除浮动是个老生常谈的问题了，面对这个问题我们往往能说出一两个解决方法，但你是否知道其背后的原理呢？《CSS世界》这本书给出了很好的解答，现推荐下张鑫旭近10年前的博客。&lt;br /&gt;
&lt;a href=&#34;https://www.zhangxinxu.com/wordpress/2010/01/css-float%e6%b5%ae%e5%8a%a8%e7%9a%84%e6%b7%b1%e5%85%a5%e7%a0%94%e7%a9%b6%e3%80%81%e8%af%a6%e8%a7%a3%e5%8f%8a%e6%8b%93%e5%b1%95%e4%b8%80/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;CSS float浮动的深入研究、详解及拓展(一)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.zhangxinxu.com/wordpress/2010/01/css-float%e6%b5%ae%e5%8a%a8%e7%9a%84%e6%b7%b1%e5%85%a5%e7%a0%94%e7%a9%b6%e3%80%81%e8%af%a6%e8%a7%a3%e5%8f%8a%e6%8b%93%e5%b1%95%e4%ba%8c/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;CSS float浮动的深入研究、详解及拓展(二)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#39;#4&#39;&gt;别废话!切入正题!&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;a-href-1-name-1-清除浮动的原因-a&#34;&gt;&lt;a href=&#39;#1&#39; name=&#39;1&#39;&gt;清除浮动的原因&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;浮动布局时不小心高度塌陷了呗~&lt;/p&gt;

&lt;h3 id=&#34;a-href-2-name-2-浮动的真正目的-a&#34;&gt;&lt;a href=&#39;#2&#39; name=&#39;2&#39;&gt;浮动的真正目的&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;浮动的出现仅仅是为了让&lt;strong&gt;文字围绕图片&lt;/strong&gt;而已，就像WORD中的“文字环绕”一样。&lt;/p&gt;

&lt;h3 id=&#34;a-href-3-name-3-浮动的原理-a&#34;&gt;&lt;a href=&#39;#3&#39; name=&#39;3&#39;&gt;浮动的原理&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;在张鑫旭的两篇文章中将浮动的本质定义为“包裹与破坏”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#39;#31&#39; name=&#39;31&#39;&gt;1. 浮动的包裹性&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;浮动就是个带有方位的display: inline-block; inline-block就是让一个块级盒子变成一个内联盒子，不让其独占一行，而是将其内容紧紧地包裹起来。而在块级盒子上应用了浮动，你会发现其确实变成了一个内联盒子。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#39;#32&#39; name=&#39;32&#39;&gt;2. 浮动的破坏性&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;结合“浮动的本职工作是实现文字环绕图片”来说明其&lt;strong&gt;“破坏性”&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;文字之所以会环绕含有float属性的图片时因为&lt;strong&gt;浮动破坏了正常的line boxes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#39;#33&#39; name=&#39;33&#39;&gt;line box模型&lt;/a&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;float的本职工作是实现&amp;lt;em&amp;gt;文字环绕图片&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;!-- 
    上面代码包含四个box
    1. inline box：‘float的本职工作是实现’是匿名的inline box，‘&amp;lt;em&amp;gt;文字环绕图片&amp;lt;/em&amp;gt;’是inline box。
    2. line box：一个个的inline box排成一行就是一个line box，多行则有多个line box。
    3. content area：在我理解就是内容区域包含上面所有的一种box。
    4. &amp;lt;p&amp;gt;标签所在的containing box，此box包含了其他的boxes。
    以上3，4解释不够严谨或有错误，可不做参考，日后修正。
--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认无浮动的图文混排是这个样子的（借用下图片）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://image.zhangxinxu.com/image/blog/201001/2010-01-20_230801.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图片本身就是个inline box，和两侧的inline box共同组成了line box，line box的高度由最高的inline box决定，第二行文本属于另一个line box，且一张图片只能与一个line box对其。&lt;/p&gt;

&lt;p&gt;给图片加了浮动之后：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://image.zhangxinxu.com/image/blog/201001/2010-01-20_234149.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;图片不再和其他的inline box在一块了，可见浮动使图片丧失了inline box特性。而&lt;strong&gt;丧失了inline box特性的后果就是高度塌陷&lt;/strong&gt;。为什么呢？&lt;/p&gt;

&lt;p&gt;在CSS中，所有的高度都是有两个CSS模型产生的。box模型，line box模型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;box模型&lt;/strong&gt;：height + padding + margin&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;line box模型&lt;/strong&gt;：line-height&lt;/p&gt;

&lt;p&gt;HEIGHT（line box） = HEIGHT（inline box）* n&lt;/p&gt;

&lt;p&gt;HEIGHT（containing box） = HEIGHT（line box）* n  即div或p标签的高度。&lt;/p&gt;

&lt;p&gt;而一旦没了inline box特性，这个高度势必大打折扣。要么完全塌陷，要么由其他inline box的高度顶替。&lt;/p&gt;

&lt;p&gt;个人认为，line boxes掌管的是box内容的高度。而一个元素真正的高度由box代表的外层高度和line box代表的内层高度组成。&lt;/p&gt;

&lt;p&gt;我们要实现文字环绕就必须使图片和多行文本对齐，而如果不能打破inline box特性，就只能和一行文本对齐。所以浮动一定要打破inline box特性。&lt;/p&gt;

&lt;p&gt;浮动的元素并没有脱离文档流，所以其他文本（inline box）并不会与之发生重合。并且，丧失inline box特性仅仅让其&lt;strong&gt;不在容器中占据高度&lt;/strong&gt;，其自身高度还是有的，而且在容器中还占据着宽度，这就实现了文本绕它而行，给围了起来。&lt;/p&gt;

&lt;p&gt;接下来说包裹性，实际上浮动只是将元素变成了类似inline-box的样式，只保留了其包裹性，而inline box的特性被抛弃了。&lt;/p&gt;

&lt;p&gt;下面我们来看一下张鑫旭大神给个例子：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;单个无浮动的li&lt;br /&gt;
&lt;img src=&#34;http://image.zhangxinxu.com/image/blog/201001/2010-01-21_202917.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单个左浮动的li&lt;br /&gt;
&lt;img src=&#34;https://image.zhangxinxu.com/image/blog/201001/2010-01-21_205119.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
呈现了包裹性。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多个左浮动的li&lt;br /&gt;
&lt;img src=&#34;https://image.zhangxinxu.com/image/blog/201001/2010-01-21_214516.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
呈现了包裹性，于是排列成一行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个左浮动一个无浮动&lt;br /&gt;
&lt;img src=&#34;https://image.zhangxinxu.com/image/blog/201001/2010-01-21_230302.png&#34; alt=&#34;&#34; /&gt;&lt;br /&gt;
第一个li因为浮动导致其“上浮”，为什么会“上浮”？因为它失去了inline box的特性，没了高度，第二个li顶了上来，呈现了第一个li上浮的假象。即便“上浮”，但并没有覆盖掉下面的li内容，因为浮动并没有使其内容脱离文档流，第一个li中的图片仍占据着空间，导致第二个li的图片紧贴在第一张图片的后面（第二个li没有浮动，其宽度是100%）。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原理部分就讲那么多，其实原文牵扯了不少内容，我总结引用的也不是很好。下面来终于到了重点内容！&lt;/p&gt;

&lt;h3 id=&#34;a-href-4-name-4-如何清除浮动-解决高度塌陷-a&#34;&gt;&lt;a href=&#39;#4&#39; name=&#39;4&#39;&gt;如何清除浮动，解决高度塌陷&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;高度为什么会塌陷？&lt;/p&gt;

&lt;p&gt;浮动使元素变成了inline-box，然后破坏其inline box特性，导致line box没了高度，进而使contain box（div、p等的内容高度）没了高度，于是塌陷。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.最简洁的方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 将下面代码放到父元素中作为最后一个子标签 --&amp;gt;
&amp;lt;div class=&#39;clear&#39;&amp;gt;.clear { clear: both; }&amp;lt;/div&amp;gt;
&amp;lt;!-- 我觉得挺好的，不过别人都说增加了无意义的标签，Emmm --&amp;gt;
&amp;lt;!-- 张鑫旭大大的原话 --&amp;gt;
&amp;lt;!-- 我从来不用，因为我看到的是个巨大的浪费，浪费了一个标签，
而且只能使用一次，我个人是无法容忍的，所以这个方法不推荐。
而且有时候一不留神中间多了个空格会产生一段空白高度的。 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.overflow + zoom方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.parent{
    overflow:hidden; 
    zoom:1; /* 值可为 normal, 倍数, 百分比 */
}
/* zoom是设置或检索对象的缩放比例的,除了火狐其他浏览器都兼容. */
/* 不过overflow:hidden容易裁剪 */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.after + zoom方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.parent{zoom:1;}
.parent:after{display:block; content:&#39;clear&#39;; clear:both; line-height:0; visibility:hidden;}
/* 张鑫旭大大鼎力推荐,after里可以只写display,content,clear. */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.破罐破摔法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;手动给父元素加高度&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;zoom这个属性是&lt;strong&gt;ie&lt;/strong&gt;专有属性，除了设置或者检索对象的缩放比例之外，它还有可以触发ie的haslayout属性，清除浮动，清除margin重叠等作用。 不过值得注意的一点就是火狐浏览器不支持zoom属性，但是在webkit内核浏览器中zoom这个属性也是可以被支持的。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Git Reflog</title>
      <link>https://hueralin.github.io/2019/gitreflog/</link>
      <pubDate>Mon, 07 Oct 2019 22:13:09 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitreflog/</guid>
      <description>

&lt;h1 id=&#34;是不是-git-reset-hard-之后傻眼了-嗯&#34;&gt;是不是 git reset &amp;ndash;hard 之后傻眼了~~~嗯？&lt;/h1&gt;

&lt;p&gt;来咯来咯~ git reflog 真的来咯~~&lt;/p&gt;

&lt;h3 id=&#34;git-reflog&#34;&gt;git reflog&lt;/h3&gt;

&lt;p&gt;git reflog 工具会记录你每次对HEAD的更改，即当你提交、切换分支或者reset后，HEAD都会更改，reflog都会记录下来你的操作。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// git log --oneline
b2d387d (HEAD -&amp;gt; master) add index.css
9515998 initial reset
29adb97 (origin/master, origin/HEAD) add branch_learn
1563c0f add log.md
53b7acc add What&#39;s commit/log.md
f318db2 git add --all

// 现在我们不小心回退到 1563c0f 这个提交
// git reset --hard 1563c0f
// git log --oneline
1563c0f (HEAD -&amp;gt; master) add log.md
53b7acc add What&#39;s commit/log.md
f318db2 git add --all
// 此时，暂存区和工作目录都回退到了指定的提交，那些未保存的修改都没了......

// 因为Git记录下来了我们每次对HEAD进行的更改，所以我们可以使用git reflog命令查看所有的HEAD改动记录。
// git reflog
1563c0f (HEAD -&amp;gt; master) HEAD@{0}: reset: moving to 1563c0f
b2d387d HEAD@{1}: commit: add index.css
9515998 HEAD@{2}: commit: initial reset
// 可以看到，第一条就是我们的reset命令。
// 第二条是最近的一次提交记录，即我们刚刚回退的记录，前面有它的散列值。
// 我们再次执行 git reset --hard，为什么要加上hard呢？因为我们要复原，暂存索引和工作目录都要。
// git reset --hard b2d387d
// git log --oneline
b2d387d (HEAD -&amp;gt; master) add index.css
9515998 initial reset
29adb97 (origin/master, origin/HEAD) add branch_learn
1563c0f add log.md
53b7acc add What&#39;s commit/log.md
f318db2 git add --all
// 看！又回来了！
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实，我只是为了简单介绍这个命令而举的这个例子，并不具有代表性，在实际过程中遇到的问题比这个复杂得多，所以还要随机应变，和其他命令配合。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LearnGitWithBitbucketCloud(3-4-4)-Git Reset</title>
      <link>https://hueralin.github.io/2019/gitreset-translation/</link>
      <pubDate>Mon, 07 Oct 2019 11:30:54 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitreset-translation/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;[假面包屑导航]&lt;/strong&gt; &lt;a href=&#34;https://www.atlassian.com/git/tutorials&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Git tutorials&lt;/a&gt; / &lt;a href=&#34;https://www.atlassian.com/git/tutorials/setting-up-a-repository&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Getting Started&lt;/a&gt; / &lt;a href=&#34;https://www.atlassian.com/git/tutorials/undoing-changes&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;UndoingChanges&lt;/a&gt; / git-reset&lt;/p&gt;

&lt;p&gt;“这是一篇译文”，本人水平有限，若有错误请&lt;a href=&#34;https://www.atlassian.com/git/tutorials/undoing-changes/git-reset&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考原文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The git reset command is a complex and versatile tool for undoing changes. It has three primary forms of invocation. These forms correspond to command line arguments &amp;ndash;soft, &amp;ndash;mixed, &amp;ndash;hard. The three arguments each correspond to Git&amp;rsquo;s three internal state management mechanism&amp;rsquo;s, The Commit Tree (HEAD), The Staging Index, and The Working Directory.&lt;/p&gt;

&lt;p&gt;git reset 命令是用于撤销更改的复杂而又通用的工具。它有三种主要的调用形式，这三种形式分别对应着命令行参数 &amp;ndash;soft, &amp;ndash;mixed, &amp;ndash;hard。这三种参数分别对应着Git的三种内部状态管理机制，The Commit Tree (HEAD), The Staging Index, and The Working Directory。&lt;/p&gt;

&lt;h1 id=&#34;git-reset-three-trees-of-git&#34;&gt;Git Reset &amp;amp; Three Trees of Git&lt;/h1&gt;

&lt;p&gt;To properly understand git reset usage, we must first understand Git&amp;rsquo;s internal state management systems. Sometimes these mechanisms are called Git&amp;rsquo;s &amp;ldquo;three trees&amp;rdquo;. Trees may be a misnomer, as they are not strictly traditional tree data-structures. They are, however, node and pointer-based data structures that Git uses to track a timeline of edits. The best way to demonstrate these mechanisms is to create a changeset in a repository and follow it through the three trees.&lt;/p&gt;

&lt;p&gt;为了更适当的理解 git reset 的用法，我们必须首先了解Git的内部状态管理系统。有时这些机制被称为&lt;strong&gt;Git的三棵树&lt;/strong&gt;，尽管它们不是严格意义上的传统的“树”数据结构。而是Git用来跟踪编辑时间轴的基于结点和指针的数据结构。演示这种机制的最好方法是在仓库中创建一个“改动集合”，然后通过着三棵树来跟踪它。&lt;/p&gt;

&lt;p&gt;To get started we will create a new repository with the commands below:&lt;br /&gt;
首先，我们使用以下的命令行创建一个仓库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ mkdir git_reset_test
$ cd git_reset_test/
$ git init .
Initialized empty Git repository in /git_reset_test/.git/
$ touch reset_lifecycle_file
$ git add reset_lifecycle_file
$ git commit -m&amp;quot;initial commit&amp;quot;
[master (root-commit) d386d86] initial commit
1 file changed, 0 insertions(+), 0 deletions(-)
create mode 100644 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above example code creates a new git repository with a single empty file, reset_lifecycle_file. At this point, the example repository has a single commit (d386d86) from adding reset_lifecycle_file.&lt;/p&gt;

&lt;p&gt;上面的示例代码创建了一个仓库，里面只有一个空文件 reset_lifecycle_file。此时，这个仓库里面只有一个刚刚初始化的提交。&lt;/p&gt;

&lt;h1 id=&#34;the-working-directory&#34;&gt;The working directory&lt;/h1&gt;

&lt;p&gt;The first tree we will examine is &amp;ldquo;The Working Directory&amp;rdquo;. This tree is in sync with the local filesystem and is representative of the immediate changes made to content in files and directories.&lt;/p&gt;

&lt;p&gt;我们将要了解的第一棵树叫做“工作目录”。这棵树和本地文件系统是同步的，并且文件或目录中内容的更改它都能立即显示出来。（说白了就是你本地的工作目录）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ echo &#39;hello git reset&#39; &amp;gt; reset_lifecycle_file  
$ git status  
On branch master  
Changes not staged for commit:  
(use &amp;quot;git add ...&amp;quot; to update what will be committed)  
(use &amp;quot;git checkout -- ...&amp;quot; to discard changes in working directory)  
modified: reset_lifecycle_file // (假装是红色的)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our demo repository, we modify and add some content to the reset_lifecycle_file. Invoking git status shows that Git is aware of the changes to the file. These changes are currently a part of the first tree, &amp;ldquo;The Working Directory&amp;rdquo;. Git status can be used to show changes to the Working Directory. They will be displayed in the red with a &amp;lsquo;modified&amp;rsquo; prefix.&lt;/p&gt;

&lt;p&gt;在我们的示例仓库中，我们修改了 reset_lifecycle_file 文件的内容。调用 git status 命令，可以看到Git已经追踪到了文件的修改。这些修改是当前“工作目录”的一部分。&lt;code&gt;git status&lt;/code&gt; 用来显示工作目录的修改。这些改动将会以红色的‘modified’前缀显示。&lt;/p&gt;

&lt;h1 id=&#34;staging-index&#34;&gt;Staging index&lt;/h1&gt;

&lt;p&gt;Next up is the &amp;lsquo;Staging Index&amp;rsquo; tree. This tree is tracking Working Directory changes, that have been promoted with git add, to be stored in the next commit. This tree is a complex internal caching mechanism. Git generally tries to hide the implementation details of the Staging Index from the user.&lt;/p&gt;

&lt;p&gt;接下来是“暂存索引”树。这棵树是用来追踪工作目录的修改的，且已经调用过 &lt;code&gt;git add&lt;/code&gt;。这棵树是一个复杂的内部缓存机制。Git一般情况下会对用户隐藏暂存索引的实现细节。&lt;/p&gt;

&lt;p&gt;To accurately view the state of the Staging Index we must utilize a lesser known Git command git ls-files. The git ls-files command is essentially a debug utility for inspecting the state of the Staging Index tree.&lt;/p&gt;

&lt;p&gt;为了准确的观察“暂存索引”的状态，我们必须使用一个不常见的Git命令 &lt;code&gt;git ls-files&lt;/code&gt; 。这个命令实际上是一个为了检查“暂存索引”树的状态的调试命令。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;git ls-files -s  
100644 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0 reset_lifecycle_file  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have executed git ls-files with the -s or &amp;ndash;stage option. Without the -s option the git ls-files output is simply a list of file names and paths that are currently part of the index. The -s option displays additional metadata for the files in the Staging Index. This metadata is the staged contents&amp;rsquo; mode bits, object name, and stage number. Here we are interested in the object name, the second value (d7d77c1b04b5edd5acfc85de0b592449e5303770). This is a standard Git object SHA-1 hash. It is a hash of the content of the files. The Commit History stores its own object SHA&amp;rsquo;s for identifying pointers to commits and refs and the Staging Index has its own object SHA&amp;rsquo;s for tracking versions of files in the index.&lt;/p&gt;

&lt;p&gt;接下来，我们执行 git ls-files -s / &amp;ndash;stage。如果没有 -s 选项，那么 git ls-files 只会输出一个简单的包含文件名和路径的文件列表。-s 选项展示了暂存索引树中文件的额外的元数据。这些元数据包括暂存内容的位模式，对象名以及暂存号。这里我们主要看对象名，即列表项的第二个值。这是一个标准的Git对象SHA-1散列。它是文章内容的hash值。提交历史（git log）保存了它自身的对象SHA，用于标识提交和引用的指针，并且暂存索引也有它自己的用来跟踪索引中文件版本的对象SHA。&lt;/p&gt;

&lt;p&gt;Next, we will promote the modified reset_lifecycle_file into the Staging Index.&lt;/p&gt;

&lt;p&gt;接下来，我们将修改后的 reset_lifecycle_file 文件加入到暂存索引中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git add reset_lifecycle_file   
$ git status   
On branch master Changes to be committed:   
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)   
modified: reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have invoked git add reset_lifecycle_file which adds the file to the Staging Index. Invoking git status now shows reset_lifecycle_file in green under &amp;ldquo;Changes to be committed&amp;rdquo;. It is important to note that git status is not a true representation of the Staging Index. The git status command output displays changes between the Commit History and the Staging Index. Let us examine the Staging Index content at this point.&lt;/p&gt;

&lt;p&gt;这里我们调用了 git add reset_lifecycle_file 命令，将文件加入了暂存索引中。在调用 git status 命令，可以看到输出显示 reset_lifecycle_file 文件以绿色标识在“Changes to be committed”下面。注意，git status 并不是暂存索引的真正体现。git status 命令输出显示是 提交历史 和 暂存索引 之间的改动。现在让我们检查一下暂存索引的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git ls-files -s  
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that the object SHA for reset_lifecycle_file has been updated from e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 to d7d77c1b04b5edd5acfc85de0b592449e5303770.&lt;/p&gt;

&lt;p&gt;我们可以看到 reset_lifecycle_file 文件的对象SHA发生了变化。&lt;/p&gt;

&lt;h1 id=&#34;commit-history&#34;&gt;Commit history&lt;/h1&gt;

&lt;p&gt;The final tree is the Commit History. The git commit command adds changes to a permanent snapshot that lives in the Commit History. This snapshot also includes the state of the Staging Index at the time of commit.&lt;/p&gt;

&lt;p&gt;最后一棵树是“提交历史”。git commit 命令将文件的改动添加进一个永久的快照中，这个快照保存在“提交历史”树中。这个快照还包含了提交时暂存索引的状态。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git commit -am&amp;quot;update content of reset_lifecycle_file&amp;quot;
[master dc67808] update content of reset_lifecycle_file
1 file changed, 1 insertion(+)
$ git status
On branch master
nothing to commit, working tree clean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have created a new commit with a message of &amp;ldquo;update content of resetlifecyclefile&amp;rdquo;. The changeset has been added to the Commit History. Invoking git status at this point shows that there are no pending changes to any of the trees. Executing git log will display the Commit History. Now that we have followed this changeset through the three trees we can begin to utilize git reset.&lt;/p&gt;

&lt;p&gt;我们创建了一个提交，将之前所做的修改作为一个集合添加进提交历史。调用 git status 命令，可以看到没有需要添加进任何树中的等待中的修改。执行 git log 命令会显示提交历史。既然我们已经通过三棵树跟踪了这个变更集，我们就可以开始使用git reset了。&lt;/p&gt;

&lt;h1 id=&#34;how-it-works&#34;&gt;How it works&lt;/h1&gt;

&lt;p&gt;At a surface level, git reset is similar in behavior to git checkout. Where git checkout solely operates on the HEAD ref pointer, git reset will move the HEAD ref pointer and the current branch ref pointer. To better demonstrate this behavior consider the following example:&lt;/p&gt;

&lt;p&gt;表面上，git reset 在行为上和 git checkout 相似。git checkout 仅仅操作在HEAD的引用指针上，而 git reset 会移动到HEAD的引用指针以及当前分支的引用指针上。为了更好地演示这种行为，我们考虑下下面的例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wac-cdn.atlassian.com/dam/jcr:b02e7b60-742a-449d-921d-53c32410576d/git-sequence-transparent.png?cdnVersion=612&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;git checkout b&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wac-cdn.atlassian.com/dam/jcr:73e231c7-ddee-4f32-94d6-a3e31e835690/git-checkout-transparent.png?cdnVersion=612&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With git checkout, the master ref is still pointing to d. The HEAD ref has been moved, and now points at commit b. The repo is now in a &amp;lsquo;detached HEAD&amp;rsquo; state.&lt;/p&gt;

&lt;p&gt;调用了 git checkout ，master分支的引用仍然指向d。HEAD引用移动了，现在指向了 commit b。仓库现在处于HEAD指向的状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;git reset b&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wac-cdn.atlassian.com/dam/jcr:29e29d3d-dddd-480b-afd9-77169a7b0230/git-reset-transparent.png?cdnVersion=612&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Comparatively, git reset, moves both the HEAD and branch refs to the specified commit.&lt;/p&gt;

&lt;p&gt;相对而言，git reset 将HEAD引用和分支引用都移动到了特定的提交上。&lt;/p&gt;

&lt;p&gt;In addition to updating the commit ref pointers, git reset will modify the state of the three trees. The ref pointer modification always happens and is an update to the third tree, the Commit tree. The command line arguments &amp;ndash;soft, &amp;ndash;mixed, and &amp;ndash;hard direct how to modify the Staging Index, and Working Directory trees.&lt;/p&gt;

&lt;p&gt;除了更新提交引用指针，git reset 还会修改三棵树的状态。引用指针的改变经常会发生，并且是对第三棵树&amp;mdash;“提交树”的更新。命令行参数 &amp;ndash;soft，&amp;ndash;mixed 以及 &amp;ndash;hard 如何修改这三棵树呢。&lt;/p&gt;

&lt;h1 id=&#34;main-options&#34;&gt;Main Options&lt;/h1&gt;

&lt;p&gt;The default invocation of git reset has implicit arguments of &amp;ndash;mixed and HEAD. This means executing git reset is equivalent to executing git reset &amp;ndash;mixed HEAD. In this form HEAD is the specified commit. Instead of HEAD any Git SHA-1 commit hash can be used.&lt;/p&gt;

&lt;p&gt;调用 git reset 默认会有两个隐式的参数 &amp;ndash;mixed 和 HEAD。也就是说执行 git reset 等同于执行 git reset &amp;ndash;mixed HEAD。在这种形式中，HEAD就是一个指定的提交。可以使用任何提交对象的散列值来代替HEAD。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://wac-cdn.atlassian.com/dam/jcr:7fb4b5f7-a2cd-4cb7-9a32-456202499922/03%20(8).svg?cdnVersion=612&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;hard&#34;&gt;&amp;ndash;hard&lt;/h1&gt;

&lt;p&gt;This is the most direct, DANGEROUS, and frequently used option. When passed &amp;ndash;hard The Commit History ref pointers are updated to the specified commit. Then, the Staging Index and Working Directory are reset to match that of the specified commit. Any previously pending changes to the Staging Index and the Working Directory gets reset to match the state of the Commit Tree. This means any pending work that was hanging out in the Staging Index and Working Directory will be lost.&lt;/p&gt;

&lt;p&gt;这是一个最直接，&lt;strong&gt;最危险&lt;/strong&gt;，且使用最频繁的一个选项。当使用 &amp;ndash;hard 后，提交历史的引用指针会更新到指定的提交。然后，暂存索引和工作目录也会重置到指定提交的状态。任何先前暂存索引和工作目录中的等待中的修改都会被重置到提交记录树种的指定的状态。也就是说任何暂存索引和工作目录中挂起的工作都会丢失。&lt;/p&gt;

&lt;p&gt;To demonstrate this, let&amp;rsquo;s continue with the three tree example repo we established earlier. First let&amp;rsquo;s make some modifications to the repo. Execute the following commands in the example repo:&lt;/p&gt;

&lt;p&gt;为了演示，我们继续使用之前的仓库。首先我们做些修改，然后执行下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ echo &#39;new file content&#39; &amp;gt; new_file
$ git add new_file
$ echo &#39;changed content&#39; &amp;gt;&amp;gt; reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These commands have created a new file named new_file and added it to the repo. Additionally, the content of reset_lifecycle_file will be modified. With these changes in place let us now examine the state of the repo using git status.&lt;/p&gt;

&lt;p&gt;创建一个新文件，并添加进仓库。然后对 reset_lifecycle_file 文件做一些修改，再执行 git status：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git status
On branch master
Changes to be committed:
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)
new file: new_file
Changes not staged for commit:
(use &amp;quot;git add ...&amp;quot; to update what will be committed)
(use &amp;quot;git checkout -- ...&amp;quot; to discard changes in working directory)
modified: reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that there are now pending changes to the repo. The Staging Index tree has a pending change for the addition of new_file and the Working Directory has a pending change for the modifications to reset_lifecycle_file.&lt;/p&gt;

&lt;p&gt;现在我们能看到仓库中有一些等待中的修改。暂存索引树中等待中的修改是新文件的增加，工作目录书树的等待中的修改是 reset_lifecycle_file 文件的改动。&lt;/p&gt;

&lt;p&gt;Before moving forward let us also examine the state of the Staging Index:&lt;/p&gt;

&lt;p&gt;在使用 git reset 移动之前，我们先来看一下暂存索引：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git ls-files -s
100644 8e66654a5477b1bf4765946147c49509a431f963 0 new_file
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that new_file has been added to the index. We have made updates to reset_lifecycle_file but the Staging Index SHA (d7d77c1b04b5edd5acfc85de0b592449e5303770) remains the same. This is expected behavior because have not used git add to promote these changes to the Staging Index. These changes exist in the Working Directory.&lt;/p&gt;

&lt;p&gt;我们可以看到新文件被添加进了暂存索引。我们对 reset_lifecycle_file 文件做了修改，但是它的暂存索引中的SHA并没有改变。这是意料之中的事，因为我们并没有使用 git add 命令将修改添加进暂存索引。这些修改仍然存在于工作目录中。&lt;/p&gt;

&lt;p&gt;Let us now execute a git reset &amp;ndash;hard and examine the new state of the repository.&lt;/p&gt;

&lt;p&gt;让我们执行下 git reset &amp;ndash;hard 然后看看仓库中当前的状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git reset --hard
HEAD is now at dc67808 update content of reset_lifecycle_file
$ git status
On branch master
nothing to commit, working tree clean
$ git ls-files -s
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have executed a &amp;ldquo;hard reset&amp;rdquo; using the &amp;ndash;hard option. Git displays output indicating that HEAD is pointing to the latest commit dc67808. Next, we check the state of the repo with git status. Git indicates there are no pending changes. We also examine the state of the Staging Index and see that it has been reset to a point before new_file was added. Our modifications to reset_lifecycle_file and the addition of new_file have been destroyed. This data loss cannot be undone, this is critical to take note of.&lt;/p&gt;

&lt;p&gt;现在HEAD指向了最近的一次提交 dc67808。执行 git status，发现Git说此时没有等待中的修改。执行  git ls-files -s ，查看暂存索引树，发现回到了添加新文件之前的状态。我们对新文件的添加和对旧文件的修改都被销毁了。这些数据丢失了，也不能重做，注意这一点很重要。&lt;/p&gt;

&lt;h1 id=&#34;mixed&#34;&gt;&amp;ndash;mixed&lt;/h1&gt;

&lt;p&gt;This is the default operating mode. The ref pointers are updated. The Staging Index is reset to the state of the specified commit. Any changes that have been undone from the Staging Index are moved to the Working Directory. Let us continue.&lt;/p&gt;

&lt;p&gt;&amp;ndash;mixed 是默认选项。引用指针会被更新。暂存索引被重置到指定的提交。从暂存索引中撤消的任何更改都将移动到工作目录。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ echo &#39;new file content&#39; &amp;gt; new_file
$ git add new_file
$ echo &#39;append content&#39; &amp;gt;&amp;gt; reset_lifecycle_file
$ git add reset_lifecycle_file
$ git status
On branch master
Changes to be committed:
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)
new file: new_file
modified: reset_lifecycle_file
$ git ls-files -s
100644 8e66654a5477b1bf4765946147c49509a431f963 0 new_file
100644 7ab362db063f9e9426901092c00a3394b4bec53d 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above we have made some modifications to the repository. Again, we have added a new_file and modified the contents of reset_lifecycle_file. These changes are then applied to the Staging Index with git add. With the repo in this state, we will now execute the reset.&lt;/p&gt;

&lt;p&gt;新文件的增加和旧文件的修改都被执行了 git add ，添加进了暂存索引。然后，我们执行reset：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git reset --mixed
$ git status
On branch master
Changes not staged for commit:
(use &amp;quot;git add ...&amp;quot; to update what will be committed)
(use &amp;quot;git checkout -- ...&amp;quot; to discard changes in working directory)
modified: reset_lifecycle_file
Untracked files:
(use &amp;quot;git add ...&amp;quot; to include in what will be committed)
new_file
no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)
$ git ls-files -s
100644 d7d77c1b04b5edd5acfc85de0b592449e5303770 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have executed a &amp;ldquo;mixed reset&amp;rdquo;. To reiterate, &amp;ndash;mixed is the default mode and the same effect as executing git reset. Examining the output from git status and git ls-files, shows that the Staging Index has been reset to a state where reset_lifecycle_file is the only file in the index. The object SHA for reset_lifecycle_file has been reset to the previous version.&lt;/p&gt;

&lt;p&gt;我们可以看到，&amp;ndash;mixed 和 &amp;ndash;hard 对使用 git ls-files 命令的结果一样，暂存索引中只有reset_lifecycle_file。暂存索引回退到之前的状态。&lt;/p&gt;

&lt;p&gt;The important things to take note of here is that git status shows us that there are modifications to reset_lifecycle_file and there is an untracked file: new_file. This is the explicit &amp;ndash;mixed behavior. The Staging Index has been reset and the pending changes have been moved into the Working Directory. Compare this to the &amp;ndash;hard reset case where the Staging Index was reset and the Working Directory was reset as well, losing these updates.&lt;/p&gt;

&lt;p&gt;需要注意的是，git status 显示，reset_lifecycle_file 被修改了， new_file 未被跟踪。暂存索引被重置，等待中的修改都被放进了工作目录。而 &amp;ndash;hard ，暂存索引和工作目录都被重置了，所做的修改都丢失了。&lt;/p&gt;

&lt;h1 id=&#34;soft&#34;&gt;&amp;ndash;soft&lt;/h1&gt;

&lt;p&gt;When the &amp;ndash;soft argument is passed, the ref pointers are updated and the reset stops there. The Staging Index and the Working Directory are left untouched. This behavior can be hard to clearly demonstrate. Let&amp;rsquo;s continue with our demo repo and prepare it for a soft reset.&lt;/p&gt;

&lt;p&gt;使用 &amp;ndash;soft，引用指针被更新，重置就停止在那里。暂存索引和工作目录保持不变。这个行为不好演示，我们继续使用这个仓库，为 soft reset 做好准备。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git add reset_lifecycle_file   
$ git ls-files -s   
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file   
$ git status   
On branch master   
Changes to be committed:   
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)   
modified: reset_lifecycle_file   
Untracked files:   
(use &amp;quot;git add ...&amp;quot; to include in what will be committed)   
new_file  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have again used git add to promote the modified reset_lifecycle_file into the Staging Index. We confirm that the index has been updated with the git ls-files output. The output from git status now displays the &amp;ldquo;Changes to be committed&amp;rdquo; in green. The new_file from our previous examples is floating around in the Working Directory as an untracked file. Lets quickly execute rm new_file to delete the file as we will not need it for the upcoming examples.&lt;/p&gt;

&lt;p&gt;这里，我们修改了旧文件，并添加进了暂存索引。执行 git status 可以看到旧文件处于待提交状态，新文件处于待暂存状态。让我们快速执行rm new_file来删除文件，因为在接下来的示例中不需要它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git reset --soft
$ git status
On branch master
Changes to be committed:
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)
modified: reset_lifecycle_file
$ git ls-files -s
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have executed a &amp;lsquo;soft reset&amp;rsquo;. Examining the repo state with git status and git ls-files shows that nothing has changed. This is expected behavior. A soft reset will only reset the Commit History. By default, git reset is invoked with HEAD as the target commit. Since our Commit History was already sitting on HEAD and we implicitly reset to HEAD nothing really happened.&lt;/p&gt;

&lt;p&gt;执行完 git reset &amp;ndash;soft 以及 git status 后，显示xxx。soft reset 只会重置提交历史。因为我们的提交历史已经被设置为HEAD了，我们隐式地将其重置为HEAD，所以实际上什么也没有发生。&lt;/p&gt;

&lt;p&gt;To better understand and utilize &amp;ndash;soft we need a target commit that is not HEAD. We have reset_lifecycle_file waiting in the Staging Index. Let&amp;rsquo;s create a new commit.&lt;/p&gt;

&lt;p&gt;为了更好的理解 &amp;ndash;soft 用法，我们需要一个非HEAD的提交记录。暂存索引中 reset_lifecycle_file 文件还在等着被提交，那我们就提交它吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git commit -m&amp;quot;prepend content to reset_lifecycle_file&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, our repo should have three commits. We will be going back in time to the first commit. To do this we will need the first commit&amp;rsquo;s ID. This can be found by viewing output from git log.&lt;/p&gt;

&lt;p&gt;此时，仓库应该有3个提交记录。为了回退到第一个提交记录，我们需要它的提交ID，执行 git log 即可查看。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git log
commit 62e793f6941c7e0d4ad9a1345a175fe8f45cb9df
Author: bitbucket 
Date: Fri Dec 1 15:03:07 2017 -0800
prepend content to reset_lifecycle_file
commit dc67808a6da9f0dec51ed16d3d8823f28e1a72a
Author: bitbucket 
Date: Fri Dec 1 10:21:57 2017 -0800
update content of reset_lifecycle_file
commit 780411da3b47117270c0e3a8d5dcfd11d28d04a4
Author: bitbucket 
Date: Thu Nov 30 16:50:39 2017 -0800
initial commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Keep in mind that Commit History ID&amp;rsquo;s will be unique to each system. This means the commit ID&amp;rsquo;s in this example will be different from what you see on your personal machine. The commit ID we are interested in for this example is 780411da3b47117270c0e3a8d5dcfd11d28d04a4. This is the ID that corresponds to the &amp;ldquo;initial commit&amp;rdquo;. Once we have located this ID we will use it as the target for our soft reset.&lt;/p&gt;

&lt;p&gt;注意，每个系统的提交历史的ID都是独一无二的。我们需要的是第一个提交历史的ID 780411da3b47117270c0e3a8d5dcfd11d28d04a4 ，将用它准备调用 git reset &amp;ndash;soft。&lt;/p&gt;

&lt;p&gt;Before we travel back in time lets first check the current state of the repo.&lt;/p&gt;

&lt;p&gt;回退之前我们先看一下仓库当前的状态。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git status &amp;amp;&amp;amp; git ls-files -s
On branch master
nothing to commit, working tree clean
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始回退&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$git reset --soft 780411da3b47117270c0e3a8d5dcfd11d28d04a4
$ git status &amp;amp;&amp;amp; git ls-files -s
On branch master
Changes to be committed:
(use &amp;quot;git reset HEAD ...&amp;quot; to unstage)
modified: reset_lifecycle_file
100644 67cc52710639e5da6b515416fd779d0741e3762e 0 reset_lifecycle_file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above executes a &amp;ldquo;soft reset&amp;rdquo; and also invokes the git status and git ls-files combo command, which outputs the state of the repository. We can examine the repo state output and note some interesting observations. First, git status indicates there are modifications to reset_lifecycle_file and highlights them indicating they are changes staged for the next commit. Second, the git ls-files input indicates that the Staging Index has not changed and retains the SHA 67cc52710639e5da6b515416fd779d0741e3762e we had earlier.&lt;/p&gt;

&lt;p&gt;首先，根据状态输出，我们能够看到对 reset_lifecycle_file 文件的修改仍然存在，仍然在等着被提交。其次，根据暂存索引输出，我们发现 reset_lifecycle_file 的SHA也没有变化。&lt;/p&gt;

&lt;p&gt;To further clarify what has happened in this reset let us examine the git log:&lt;/p&gt;

&lt;p&gt;为了更进一步地解释执行 &amp;ndash;soft 发生了什么，我们执行 git log 查看一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ git log
commit 780411da3b47117270c0e3a8d5dcfd11d28d04a4
Author: bitbucket 
Date: Thu Nov 30 16:50:39 2017 -0800
initial commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The log output now shows that there is a single commit in the Commit History. This helps to clearly illustrate what &amp;ndash;soft has done. As with all git reset invocations, the first action reset takes is to reset the commit tree. Our previous examples with &amp;ndash;hard and &amp;ndash;mixed have both been against the HEAD and have not moved the Commit Tree back in time. During a soft reset, this is all that happens.&lt;/p&gt;

&lt;p&gt;日志输出显示了这确实是第一次提交历史。与所有 git reset 调用一样，重置的第一个操作是重置提交树。我们前面的例子 &amp;ndash;hard 和 &amp;ndash;mixed 都是针对HEAD的，没有及时地将提交树向后移动。但是在 &amp;ndash;soft 中，这些都做过了。&lt;/p&gt;

&lt;p&gt;This may then be confusing as to why git status indicates there are modified files. &amp;ndash;soft does not touch the Staging Index, so the updates to our Staging Index followed us back in time through the commit history. This can be confirmed by the output of git ls-files -s showing that the SHA for reset_lifecycle_file is unchanged. As a reminder, git status does not show the state of &amp;lsquo;the three trees&amp;rsquo;, it essentially shows a diff between them. In this case, it is displaying that the Staging Index is ahead of the changes in the Commit History as if we have already staged them.&lt;/p&gt;

&lt;p&gt;为什么 git status 表明存在修改过的文件？这可能会让人感到困惑。因为 &amp;ndash;soft 没有触及暂存索引，因此对暂存索引的更新在提交历史中一直跟随我们。这可以通过git ls-files -s的输出得到确认，其中 reset_lifecycle_file 的SHA没有改变。提醒一下，git status 并不显示“三棵树”的状态，它实际上显示了它们之间的差异。在本例中，它将显示暂存索引先于提交历史记录中的更改，就好像我们已经暂存了它们一样。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>call, apply, bind</title>
      <link>https://hueralin.github.io/2019/callapplybind/</link>
      <pubDate>Sun, 06 Oct 2019 13:27:32 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/callapplybind/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;call apply bind 这三个函数的作用都是将一个函数的this指向另一个对象，使得该对象可以调用这个它自身没有的函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;func-call-thisobj-arg1-arg2&#34;&gt;Func.call(thisObj, [arg1,arg2,&amp;hellip;.])&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;thisObj&lt;/strong&gt; 作为Func内部的this，它的取值有四种情况：&lt;br /&gt;
1. null/undefined/不传 Func的this &amp;mdash;-&amp;gt; window&lt;br /&gt;
2. 函数名 Func的this &amp;mdash;-&amp;gt; 该函数的引用&lt;br /&gt;
3. 数值/字符串/布尔值 Func的this &amp;mdash;-&amp;gt; Number/String/Boolean&lt;br /&gt;
4. 对象 Func的this &amp;mdash;-&amp;gt; 对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Func(){
    console.log(this)
}
function Test(){console.log(&#39;Test&#39;)}
var obj = { name: &#39;huer&#39; }
Func.call() // window
Func.call(null) // window
Func.call(undefined) // window
Func.call(Test) // Test(){console.log(&#39;Test&#39;)}
Func.call(666) // Number {666}
Func.call(&#39;666&#39;) // String {&amp;quot;666&amp;quot;}
Func.call(true) // Boolean {true}
Func.call(obj)  // {name: &amp;quot;huer&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三个函数除了由上面的功能外，还有一个功能。还能给对象添加新属性，例如在继承中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person(name, age) {
    this.name = name;
    this.age = age; 
}
let dog = {}
Person.call(dog, &#39;wangcai&#39;, 5);
console.log(dog);   // {name: &amp;quot;wangcai&amp;quot;, age: 5}
// dog调用了Person构造函数，于是Person函数中的this指向dog，然后给dog添加了两个属性。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;func-apply-thisobj-args&#34;&gt;Func.apply(thisObj, [args[]])&lt;/h3&gt;

&lt;p&gt;功能和call一样，只不过第二个参数是一个参数数组（或伪数组，如arguments），而不是参数列表。&lt;/p&gt;

&lt;h3 id=&#34;func-bind-thisobj-arg1-arg2&#34;&gt;Func.bind(thisObj, [arg1, arg2&amp;hellip;])&lt;/h3&gt;

&lt;p&gt;功能和上面两个一样，只不过该函数并不会立即执行Func，而是返回一个绑定后的函数。它常用于事件绑定中，因为事件绑定要求传入函数引用而不是函数的执行结果，bind的其他参数和call一样，是一个参数列表。&lt;/p&gt;

&lt;p&gt;bind函数返回一个原函数的拷贝，并拥有指定的this值和初始参数。&lt;/p&gt;

&lt;p&gt;bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;bind函数用法1：创建一个绑定函数。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var x = 9;
var module = {
  x: 81,
  getX: function() { return this.x; }
};

module.getX(); // 81

var retrieveX = module.getX;
retrieveX();   
// 返回9 - 因为函数是在全局作用域中调用的

// 创建一个新函数，把 &#39;this&#39; 绑定到 module 对象
var boundGetX = retrieveX.bind(module);
boundGetX(); // 81
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;bind函数用法2：创建一个偏函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 偏函数，即拥有预设参数的函数
// 只要将这些参数（如果有的话）作为bind()的参数写在this后面。
// 当绑定函数被调用时，这些参数会被插入到目标函数的参数列表的开始位置，传递给绑定函数的参数会跟在它们后面。

function sum(a, b) {
    return a + b;
}
function toArr() {
    return Array.prototype.slice.call(arguments);
}

let FuncA = sum.bind(null, 666);    // 将666作为第一个参数的预设
console.log(FuncA(10)); // 676
console.log(FuncA(10, 20)); // 676, 第二个参数实际上被作为第三个参数而忽略掉

let FuncB = toArr.bind(null, 6, 7, 8);  // 将6，7，8作为预设参数
console.log(FuncB());   // [6, 7, 8]
console.log(FuncB(9, 10));   // [6, 7, 8, 9, 10]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bind函数用法3-配合settimeout&#34;&gt;bind函数用法3: 配合setTimeout&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// setTimeout实际上是window.setTimeout
// 下面计时器的执行过程是，3秒后，将匿名函数放进事件队列，事件循环到它时执行
// 这个执行和 function A(){xxx} A()一样，即在全局环境下执行匿名函数，里面的this指向window
setTimeout(function() {
    console.log(&#39;this is: &#39;, this)
}, 3000)

// 比如有个绘制函数
let canvas = {
    render: function() {
        this.update();
        this.draw();
    }
    update: function(){xxx}
    draw: function(){xxx}
}

window.setInterval(canvas.render, 1000 / 60)
// 这样的话，render函数里的this很容易指向window，导致报错！

// 所以我们可以显式地将this绑定到canvas
window.setInterval(canvas.render.bind(canvas), 1000);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>setState</title>
      <link>https://hueralin.github.io/2019/state-async/</link>
      <pubDate>Fri, 04 Oct 2019 23:57:30 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/state-async/</guid>
      <description>

&lt;h3 id=&#34;state机制&#34;&gt;State机制&lt;/h3&gt;

&lt;p&gt;setState函数是React管理组件状态的一种方法，修改组件的状态时必须使用该方法，而不能直接在this.state上赋值。但是，如果我们在调用完setState之后直接去访问State时，拿到的是修改前的值。也就是说，setState并不保证“同步执行”。&lt;/p&gt;

&lt;p&gt;如果在一次操作中多次调用setState，那么React会将这几次操作暂存起来，然后统一集中合并，根据合并后的结果去计算新的虚拟DOM，最后执行渲染。　　&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 初始 count = 0
this.setState({ count: this.state.count + 1 })
console.log(this.state.count)       // 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么如果和解决上面的问题呢？&amp;mdash;&amp;ndash;回调函数&lt;/p&gt;

&lt;p&gt;setState函数的参数有两个，第一个参数是对象，第二个参数是回调函数。回调函数在State合并更新完后才会被调用，所以可以拿到更新后的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;this.setState({
    count: this.state.count + 1
}, () =&amp;gt; {
    console.log(this.state.count)   // count = 1
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面来看另一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;this.setState({ count: this.state.count + 1 })
this.setState({ count: this.state.count + 1 })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该会怎么执行呢？结果是2么？不对！结果是1。&lt;br /&gt;
上面提到过，多次调用setState会被合并为一次操作。上面的代码类似于下面这段：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.assign(state, {count: state.count+1}, {count: state.count+1})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;都是操作的count，合并时只执行最后一个。&lt;/p&gt;

&lt;p&gt;那么如何做到增加两次呢？其实setState函数的第一个参数也可以为函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;this.setState((preState, props) =&amp;gt; {count: preState.count + 1})
this.setState((preState, props) =&amp;gt; {count: preState.count + 1})
console.log(this.state.count)   // 仍然是10，但页面渲染的是2

// preState为之前的State，props为State更新执行瞬间的props
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，每次调用都是在上一次state的基础上修改。&lt;/p&gt;

&lt;p&gt;上面代码相当于:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[{increment: 1}, {increment: 1}, {increment: 1}].reduce((preState, props) =&amp;gt; {
    count: preState.count + props.increment
})
// 累加器
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实，React的内部会维护一个State的更新队列，会将当前所有的State修改操作都推入队列中，然后集中合并处理，再调用回调函数，最后计算新的虚拟DOM，执行渲染。&lt;/p&gt;

&lt;h3 id=&#34;setstate真的是异步的么-非也&#34;&gt;setState真的是异步的么？非也！&lt;/h3&gt;

&lt;p&gt;React为了实现跨平台，保证兼容性，内部封装了自己的事件机制，来代替原生事件。React内部会维护一个isBatchingUpdate的标识，来决定是同步修改还是异步修改。在这些合成事件和生命周期函数里执行setState的时候，React将isBatchingUpdate设置为true，即批处理修改，也就是说异步修改。而在原生事和setTimeout函数里面使用setState的时候则是同步修改。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sisterAn/blog/issues/26&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>技术分享之Redux思想</title>
      <link>https://hueralin.github.io/2019/share/</link>
      <pubDate>Wed, 18 Sep 2019 13:40:10 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/share/</guid>
      <description>

&lt;h1 id=&#34;redux&#34;&gt;Redux&lt;/h1&gt;

&lt;h3 id=&#34;普通的状态管理&#34;&gt;普通的状态管理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 状态
let state = {
    // 计数
    count: 0
}···
// 修改状态
state.count = 1
// 获取状态
console.log(state.count)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：状态改变，依赖状态的地方得不到通知&lt;/p&gt;

&lt;h3 id=&#34;带有发布订阅的状态管理&#34;&gt;带有发布订阅的状态管理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 状态
let state = {
    // 计数
    count: 0
}
// 集中管理订阅
let listeners = []
// 订阅函数
function subscribe(callback) {
    listeners.push(callback)
}
// 修改状态的函数
function changState(newVal) {
    state.count = newVal
    for(let i=0;i&amp;lt;listeners.length;i++){
        listeners[i]()
    }
}
// main
subscribe(() =&amp;gt; {
    console.log(&#39;count&#39;, state.count)
})
changState(1)  // 1
changState(2)  // 2
changState(3)  // 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：只对count（即单个状态）有效，应将公共操作封装起来。&lt;/p&gt;

&lt;h3 id=&#34;封装后的版本&#34;&gt;封装后的版本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//  创建store的函数
function createStore(initState) {
    let state = initState || {}
    let listeners = []
    // 订阅函数
    function subscribe(callback) {
        listeners.push(callback)
    }
    // 修改状态的函数
    function changeState(newState) {
        state = newState
        for(let i=0;i&amp;lt;listeners.length;i++){
            listeners[i]()
        }
    }
    //  获取状态
    function getState() {
        return state
    }
    // 返回一个store对象
    return {
        subscribe,
        changeState,
        getState
    }
}
// main
let initState = {
    count: 0,
    user: {
        name: &#39;huer&#39;,
        age: 20,
        sex: &#39;male&#39;
    }
}
let store = createStore(initState)
store.subscribe(() =&amp;gt; {
    let count = store.getState().count
    console.log(`count: ${count}`)
})
store.subscribe(() =&amp;gt; {
    let user = store.getState().user
    console.log(`name: ${user.name}`)
})
store.changeState(Object.assign({}, store.getState(), {count: 1}))
store.changeState(Object.assign({}, store.getState(), {user: &#39;malin&#39;}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：state可以被随便改，没有约束。&lt;/p&gt;

&lt;h3 id=&#34;带计划的状态管理&#34;&gt;带计划的状态管理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//  以计数器为例
/*
    {
        type: &#39;ADD&#39;,
        count: 2
    }
*/
// 计划函数 plan
function plan(state = {}, action) {
    switch(action.type) {
        case &#39;ADD&#39;: return Object.assign({}, state, {count: state.count + 1});break;
        case &#39;SUB&#39;: return Object.assign({}, state, {count: state.count - 1});break;
        default: return state;
    }
}
//  改进封装后的changeState函数
function changeState(action) {
    // 按计划修改状态
    state = plan(state, action)
    for(let i=0;i&amp;lt;listeners.length;i++){
        listeners[i]()
    }
}
// main
// 自增
store.changeState({
  type: &#39;ADD&#39;
})
// 自减
store.changeState({
  type: &#39;SUB&#39;
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过Action，使得状态变化的结果可预测。&lt;/p&gt;

&lt;p&gt;changeState &amp;ndash;&amp;gt; dispatch&lt;br /&gt;
plan &amp;mdash;&amp;gt; Reducer&lt;/p&gt;

&lt;p&gt;Store的角色是整个应用的数据存储中心，集中大部分页面需要的状态数据。&lt;/p&gt;

&lt;p&gt;Redux工作流程：用户通过界面组件 触发Action，携带Store中的旧State与Action 流向Reducer, Reducer返回新的state，并更新界面。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hueralin/Rimage&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Rimage&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zmage.caldis.me/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Zmage&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCP流量控制、拥塞控制</title>
      <link>https://hueralin.github.io/2019/tcpys/</link>
      <pubDate>Mon, 09 Sep 2019 12:51:57 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/tcpys/</guid>
      <description>

&lt;p&gt;计算机网络推荐书籍：计算机网络（谢希仁）&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/37379780&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;TCP流量控制、拥塞控制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在前端面试中关于计算机网络的知识多半是HTTP协议、TCP/IP协议，拥塞控制之类的。昨天看了几篇关于拥塞控制的文章，现来做一些总结。&lt;/p&gt;

&lt;h2 id=&#34;tcp流量控制&#34;&gt;TCP流量控制&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;一、 流量控制的原因&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;双方在通信时会涉及到通信速率的问题，即发送速率和处理速率，这两个速率往往是不一样的。如果发送方的发送速率太快，接收方来不及处理，就会将报文放进缓存，若发送方仍不控制发送速率，那么缓存终会爆满，导致丢包，浪费网络资源，所以应该对发送方的发送速率进行控制，使发送方和接收方达到一种动态平衡。&lt;/p&gt;

&lt;p&gt;流量控制，即控制发送方的发送速率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、滑动窗口&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;滑动窗口协议：TCP协议中的一种应用，用于网络数据传输中的流量控制。&lt;/p&gt;

&lt;p&gt;该协议允许发送方在停止并等待确认报文前发送多个数据，不必每发完一段数据就定下来等待确认，提高网络的吞吐量，所以TCP定义了一个&lt;strong&gt;滑动窗口协议&lt;/strong&gt;，滑动窗口包括&lt;strong&gt;发送窗口&lt;/strong&gt;和&lt;strong&gt;接受窗口&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关概念&lt;/strong&gt;&lt;br /&gt;
1. 窗口：一段可以被发送者连续发送的字节序列范围。&lt;br /&gt;
2. 滑动：“窗口”的大小会随着发送过程变化，这种变化是在字节序列上按顺序滑动的。&lt;/p&gt;

&lt;p&gt;因为TCP协议是全双工协议，所以双方都有一个&lt;strong&gt;发送缓冲区&lt;/strong&gt;和&lt;strong&gt;接收缓冲区&lt;/strong&gt;。&lt;br /&gt;
发送缓冲区接收来自应用层的数据（一长条字节流？），而发送窗口框住了其中的一部分（前面说了，窗口其实是一段范围）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;发送缓存区&lt;/strong&gt;相关的四个概念：&lt;br /&gt;
1. 已发送并受到确认&lt;br /&gt;
2. 已发送但未收到确认&lt;br /&gt;
3. 允许发送但未发送&lt;br /&gt;
4. 不允许发送&lt;/p&gt;

&lt;p&gt;其中，允许发送的数据都在发送窗口内。每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送。&lt;/p&gt;

&lt;p&gt;下面，我借由计算机网络（谢希仁）中的图片来讲解一下过程(后来发现copy率达到99.9%)：&lt;br /&gt;
A B 双方在建立TCP连接的时候，B就已经向A给出了自己的窗口值，发送方A会根据这个值来构造自己的发送窗口。&lt;br /&gt;
&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp01.png&#34; alt=&#34;根据B给出的窗口值，A构造自己的发送窗口&#34; /&gt;&lt;br /&gt;
发送窗口表示：在没有收到B的确认情况下，A可以连续把发送窗口中的数据都发送出去。凡是发送过的数据在未收到确认前都应留在发送窗口内，以便超时重传。&lt;/p&gt;

&lt;p&gt;发送窗口的位置由前沿和后沿的位置来确定：&lt;br /&gt;
1. 前沿：不动或前移。不动，可能是因为没有收到确认，或收到了确认但接受窗口缩小了。&lt;br /&gt;
2. 后沿：不动或前移。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp02.png&#34; alt=&#34;A发送了11个字节的数据&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A发送了11个字节的数据，但未收到新的确认，所以前沿后沿都不变，即发送窗口的位置不变。&lt;br /&gt;
看B的接收窗口，32 33 未按序到达，因为接收方发送的确认号ack是由按序到达数据的最高序号决定的，所以B返回的确认号仍然是31。导致了A的发送窗口不变。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;描述一个发送窗口的状态&lt;/strong&gt;需要三个指针：p1、p2、p3。&lt;br /&gt;
1. 小于p1：已发送且已收到确认的部分&lt;br /&gt;
2. 大于p3：不允许发送的部分&lt;br /&gt;
3. p3 - p1：发送窗口&lt;br /&gt;
4. p2 - p1：已发送但未收到确认的部分&lt;br /&gt;
5. p3 - p2：允许发送但未发送的部分，又叫“可用窗口”、“有效窗口”&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp03.png&#34; alt=&#34;A收到了新的确认号，发送窗口向前滑动&#34; /&gt;&lt;/p&gt;

&lt;p&gt;B 收到了31，然后返回确认号34，表明31 32 33 都收到了，且已交付主机。A收到确认号后，发送窗口前移，后沿前移3位指向34。指针p2不动，可用窗口变大，可发送42-53的数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp04.png&#34; alt=&#34;可用窗口内的数据已全部发送，但未收到确认&#34; /&gt;&lt;br /&gt;
42-53的数据都被发送了出去，p2指针与p3指针重合，但是没有收到确认，使得可用窗口为0，A不能再发送数据，必须等到B的确认。但是B发送的确认可能在网络中延时了，没有及时到达，A就会一直等，B也会一直等待A发送数据，造成死锁。所以A有一个超时计时器机制，一段时间后没有收到B的确认，会自动重传这部分数据并重置超时计时器，直到收到B的确认为止。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、如何控制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;流量控制主要依靠滑动窗口来实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;流量控制即接收方B向发送方A传递消息，使其不要发送太快～，是一种端到端的控制。利用B返回的报文中的接收窗口的大小来控制A的发送窗口大小。rwnd: 接收窗口&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp05.png&#34; alt=&#34;利用可变窗口进行拥塞控制&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图我们也可以看到，发送窗口是连续的一段一段的发送数据，比如上面连续发送了3段数据后才返回了一个ack。&lt;/p&gt;

&lt;p&gt;B的缓存区也会有满的情况，当缓存区满了后会发送rwnd=0通知A停止发送数据。等一段时间后B的缓存区有了空会发送非0的rwnd给A，但是如果这个报文中途丢失了，A一直收不到，双方一直在互相等待，造成死锁。所以TCP引入了持续计时器，即当A收到了0接收窗口通知时，启动该计时器，时间到了就会发送一个1字节的探测报文，接收方会回应自己的接收窗口大小，若仍为0，则重设计时器，继续等待。&lt;/p&gt;

&lt;h2 id=&#34;tcp拥塞控制&#34;&gt;TCP拥塞控制&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://hueralin.github.io/img/posts/tcp06.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关概念：&lt;/strong&gt;&lt;br /&gt;
1. 慢开始门限：控制使用慢开始算法还是拥塞避免算法&lt;br /&gt;
2. 拥塞窗口&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关算法&lt;/strong&gt;&lt;br /&gt;
1. 慢开始  2. 拥塞避免  3. 快重传  4. 快恢复&lt;/p&gt;

&lt;p&gt;发送方维持一个叫做“拥塞窗口”的状态变量，其大小取决于网络的拥塞程度，且会动态变化。发送方的发送窗口等于拥塞窗口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;发送方控制拥塞窗口的原则&lt;/strong&gt;：当网络没有发生拥塞时，我可以让窗口再增大一些，发出更多的分组。若出现了拥塞，就让拥塞窗口减小一些，缓解拥塞。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网络中出现拥塞的依据&lt;/strong&gt;：分组丢失/超时。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>