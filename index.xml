<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>狐耳的雪原 on 狐耳的雪原</title>
    <link>https://hueralin.github.io/</link>
    <description>Recent content in 狐耳的雪原 on 狐耳的雪原</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 26 Aug 2019 20:09:47 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Git Stash</title>
      <link>https://hueralin.github.io/2019/gitstash/</link>
      <pubDate>Mon, 26 Aug 2019 20:09:47 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/gitstash/</guid>
      <description>

&lt;h3 id=&#34;emmmm&#34;&gt;Emmmm&lt;/h3&gt;

&lt;p&gt;最近在实习的项目中经常使用 git stash 这个命令，现在来做一些总结。&lt;/p&gt;

&lt;p&gt;你可能会遇到这样一种情况，就是当你在进行开发或修改某个BUG的时候突然来了一个新任务（新任务与当前的开发项目属于同一个项目），时间紧迫，你需要立即切换分支去执行，可是你当前的任务还没有做完，切分支的话会被拒绝，怎么办呢？有种方法是先add再commit，确实可以，但是我感觉这么做的话会添加一个毫无意义的提交记录，虽然以后可以修改，但是太过麻烦。那么，就来试试 git stash 吧。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%EF%BC%88Stashing%EF%BC%89&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;git stash 官方文档第一版&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%E4%B8%8E%E6%B8%85%E7%90%86&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;git stash 官方文档第二版&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;git-stash-应用场景&#34;&gt;git stash 应用场景&lt;/h3&gt;

&lt;p&gt;git stash 的作用是将当前为提交的修改存储起来，让仓库还原到最后一次提交的状态。&lt;br /&gt;
使用场景：&lt;br /&gt;
1. 工作未完成，需要切换分支，但不想提交（常用）。&lt;br /&gt;
2. 开发一个feature分支（未完成），此时想要合并一下主分支，看看做了哪些修改，提前解决冲突。&lt;/p&gt;

&lt;p&gt;现在来看看场景二的解决方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 假设我在feature分支上开发，突然得知主分支更新了，于是我想要将主分支合并到当前分支，看看有没有冲突，有的话直接解决。
git checkout master  // 报错！会提示当前某些修改未存储提交  
// 当然，我是不想提交的，毕竟还没做完...于是，
git stash save &amp;quot;先搁这儿，我去瞅瞅主分支，拉下代码～&amp;quot;   // save 类似于 commit 的 -m 选项，即注释信息  
git stash list // 列出来所有的存储信息，看看有木有～  
git checkout master  // 切换到主分支
git pull origin master // 将远程主机的master分支拉下来  
git checkout feature    // 切回feature分支  
git merge master    // 将master分支合并到feature（可能会有冲突）  
git stash pop   // 将先前feature分支做的修改释放出来（可能会有冲突）  
// 有冲突合并即可，合并完，feature拥有了master分支最新的修改以及当前的特性开发。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;git-stash&#34;&gt;git stash&lt;/h3&gt;

&lt;p&gt;git stash 实际上是一个栈结构，它可以获取工作目录中的中间状态（包括对已追踪文件的修改和暂存的变更，使用 git status 查看），将它保存在一个栈结构中，方便以后使用。（注意！未被追踪的文件不在存储的范围内！）&lt;/p&gt;

&lt;p&gt;git stash 命令：&lt;br /&gt;
1. git stash（git stash push的简写）将当前工作目录的中间状态保存在栈中。&lt;br /&gt;
2. git stash list 列出所有的存储。&lt;br /&gt;
3. git stash apply stash@{0} apply后面是名字，表示要应用的存储（省略名字则应用最近的存储到仓库中），apply只是应用，并不会将存储弹出栈。&lt;br /&gt;
4. git stash pop 将最近的存储应用到仓库中（但会将存储弹出栈），也可以指定存储的名字，将指定的存储应用到仓库后弹出栈。&lt;br /&gt;
5. git stash clear 清空存储栈。&lt;br /&gt;
6. git stash drop 删除最近的存储，也可以指定名字（但不会被应用到仓库）。&lt;br /&gt;
7. git stash branch name 根据最近的stash创建一个分支，然后删除最近的stash，也可以指定存储名。（如场景二，如果最后应用stash的时候发生了冲突，可以使用这个命令，牵引出一个未合并的分支做副本）。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;讲解一下 git stash push 和 git stash save&lt;/strong&gt;&lt;br /&gt;
这两个命令都可以存储当前工作区中被追踪文件的修改，但是也有些区别。&lt;br /&gt;
语法：&lt;br /&gt;
1. git stash push -m &amp;lsquo;xxxxx&amp;rsquo; src/xxx&lt;br /&gt;
2. git stash save &amp;lsquo;xxxxx&amp;rsquo;&lt;br /&gt;
其中，git stash push能指定路径，存储指定的文件，而指定路径对git stash save来说无效，它会存储工作区中所有的被追踪文件的修改。&lt;/p&gt;

&lt;h3 id=&#34;使用-git-stash-出现的问题&#34;&gt;使用 git stash 出现的问题&lt;/h3&gt;

&lt;p&gt;Q：“我新建了一个文件，用stash存储了一下，切分支后发现该文件被带进了另一个分支”&lt;br /&gt;
A：前面说过，新建的文件，如果没有add进暂存区，那么是不受stash管理的，git也不会追踪。所以对于新建的文件，应该在使用stash前先add一下。&lt;/p&gt;

&lt;p&gt;Q：“不是说我BUG还没改完切到其他分支会报错吗，要我必须提交修改。可是我没提交修改，切master分支成功了。但是！BUG修复的代码被带到master了！”&lt;br /&gt;
A：Emmmm&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>前端面试题（一）</title>
      <link>https://hueralin.github.io/2019/xiti/</link>
      <pubDate>Thu, 22 Aug 2019 16:06:11 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/xiti/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;请填充代码，使mySort()能使传入的参数按照从小到大的顺序显示出来。
function mySort() {
    var tags = new Array();//使用数组作为参数存储容器
    请补充你的代码
    return tags;//返回已经排序的数组
}
 
var result = mySort(50,11,16,32,24,99,57,100);/传入参数个数不确定
console.info(result);//显示结果
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>技术分享会</title>
      <link>https://hueralin.github.io/2019/atheneandzhike/</link>
      <pubDate>Wed, 21 Aug 2019 18:08:27 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/atheneandzhike/</guid>
      <description>

&lt;ol&gt;
&lt;li&gt;智课网&lt;/li&gt;
&lt;li&gt;Athene&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;（题库、订单、smart等服务）&lt;br /&gt;
1. &amp;mdash;&amp;gt; API &amp;mdash;&amp;gt; 智课网  &amp;lt;&amp;ndash;读取&amp;ndash;&amp;gt; DB&lt;br /&gt;
2. &amp;mdash;&amp;gt; 管理 &amp;mdash;&amp;gt; Athene  &amp;lt;&amp;ndash;配置、写入&amp;ndash;&amp;gt; DB&lt;br /&gt;
3. DB（Athene &amp;amp; beikao）&lt;/p&gt;

&lt;h3 id=&#34;智课网&#34;&gt;智课网&lt;/h3&gt;

&lt;p&gt;智课展示资讯、商品、练习等，对其他服务提供接口&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;资讯&lt;/strong&gt;&lt;br /&gt;
archetype&lt;br /&gt;
1. id(当前类目ID), reid（上一级类目ID）, topid（顶层类目ID）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;广告&lt;/strong&gt;&lt;br /&gt;
advertisement&lt;br /&gt;
1. position_id（一级类目）&lt;br /&gt;
2. type_id (二级类目)&lt;br /&gt;
3. PC or WP&lt;br /&gt;
4. archive_id&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;订单&lt;/strong&gt;&lt;br /&gt;
1. type：1（付款成功）2（发起退款）3（取消订单）4（等待付款）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;退款&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;athene&#34;&gt;Athene&lt;/h3&gt;

&lt;p&gt;负责智课网所有项目的配置，不对外部服务提供任何接口&lt;br /&gt;
项目1 [athene-frontend(React+antd)]&lt;br /&gt;
项目2 [admin-backend(express+node)]&lt;br /&gt;
数据库 [DB(athene &amp;amp; beikao)]&lt;/p&gt;

&lt;p&gt;刷新页面，看getSession请求，里面包含用户的权限&lt;/p&gt;

&lt;p&gt;start - 获取权限 - 展示菜单 - 浏览页面 - 编辑、提交数据 - 检验登录、权限 - 数据入库or拒绝&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mock 前端假数据</title>
      <link>https://hueralin.github.io/2019/mock/</link>
      <pubDate>Wed, 21 Aug 2019 16:09:41 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/mock/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;为什么需要前端做假数据？Emmmm，不用我说了吧～&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;官方文档看这里&lt;a href=&#34;http://mockjs.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;MockJs&lt;/a&gt;！&lt;/p&gt;

&lt;p&gt;数据模版之类的语法去看官方文档，我这里只简单介绍一下我的使用情况。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>伪类 与 伪元素</title>
      <link>https://hueralin.github.io/2019/weilei/</link>
      <pubDate>Wed, 21 Aug 2019 15:17:26 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/weilei/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;“请说一下伪类和伪元素的区别”，之前的面试中遇到过这个问题，当初表示只见过伪类，回答的基本上都是:hover之流，这道题就挂了&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如今，在实习中遇到了相关的需求，看来是时候深入学习一下了。其实，区分伪类和伪元素并不难，它俩最大的区别就在于应用场景。&lt;/p&gt;

&lt;h3 id=&#34;伪类&#34;&gt;伪类&lt;/h3&gt;

&lt;h4 id=&#34;顾名思义-它相当于一个类-是用来设置样式的-当你需要让一个元素在某种特殊状态下显示特殊的样式时-如-按钮悬浮特效-就该使用伪类&#34;&gt;顾名思义，它相当于一个类，是用来设置样式的；当你需要让一个元素在某种特殊状态下显示特殊的样式时（如：按钮悬浮特效），就该使用伪类。&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;下面我们来实现一下伪类：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需求：实现消息列表悬浮特效&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- 需求很明确，li元素在悬浮情况下应用样式 --&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;React&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Vue&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Angular&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;jQuery&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;Webpack&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;NPM&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
li:hover {
    background: #eee;
}
&amp;lt;!-- 再简单不过了，当然也可以设置奇偶行样式不一 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他的伪类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;:active :empty  :enabled    :first  :first-child    :first-child  
:first-of-type  :focus  :hover  :visited    :nth-child  :nth-of-type    :link
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;伪元素&#34;&gt;伪元素&lt;/h3&gt;

&lt;h4 id=&#34;顾名思义-它是一个元素-可以是现有的元素-也可以是新增的元素-这些元素往往有自己的特殊位置-如-段落首字母突出样式-往往被作为附加的标记&#34;&gt;顾名思义，它是一个元素，可以是现有的元素，也可以是新增的元素，这些元素往往有自己的特殊位置（如：段落首字母突出样式）往往被作为附加的标记。&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;下面我们来实现一下伪元素&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需求：表单必填项前面加一个标识（这也是我这次的需求）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;label&amp;gt;页面地址&amp;lt;/label&amp;gt;
&amp;lt;input type=&#39;text&#39; placeholder=&amp;quot;请输入页面地址&amp;quot;/&amp;gt;
label::before {
    content: &#39;*&#39;;
    color: red;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果：&lt;img src=&#34;https://hueralin.github.io/img/posts/xinghao.jpg&#34; alt=&#34;必填项前加星号&#34; /&gt;&lt;/p&gt;

&lt;p&gt;伪元素并不多：&lt;br /&gt;
1. ::before&lt;br /&gt;
2. ::after&lt;br /&gt;
3. ::first-letter 段落首字母&lt;br /&gt;
4. ::first-line 段落首行&lt;br /&gt;
5. ::selection 这个很有意思，代表被用户高亮的部分（例如鼠标选中）&lt;/p&gt;

&lt;h3 id=&#34;before-和-after&#34;&gt;::before 和 ::after&lt;/h3&gt;

&lt;p&gt;这两个伪元素比较特殊，属于扩增原元素一类（我自己瞎起的名字）&lt;br /&gt;
::before 创建一个伪元素，并作为匹配元素的第一个子元素，::after则相反；这个新增的元素默认为“行内元素”&lt;br /&gt;
语法参照&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/CSS/::before&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;MDN&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/* CSS3 语法 */
element::before { 样式 }  
/* （单冒号）CSS2 过时语法 (仅用来支持 IE8) */
element:before  { 样式 }  
/* 在每一个p元素前插入内容 */
p::before { content: &amp;quot;Hello world!&amp;quot;; } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MDN上关于这一节的最后一个例子不错，大家可以尝试一下！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React组件中的函数this绑定</title>
      <link>https://hueralin.github.io/2019/bind/</link>
      <pubDate>Tue, 20 Aug 2019 11:04:35 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/bind/</guid>
      <description>

&lt;h2 id=&#34;实习项目遇到的问题&#34;&gt;实习项目遇到的问题&lt;/h2&gt;

&lt;h3 id=&#34;关于函数this绑定&#34;&gt;关于函数this绑定！&lt;/h3&gt;

&lt;p&gt;最近在React项目中遇到了关于函数this绑定的问题，因为在普通函数（诸如:function(){xxx}）中，this的绑定是动态的，在被执行时才会确定。若这些普通函数在自身组件内使用一般不会有太大的问题，然而一旦被当作参数（例如事件处理函数）传递到其他组件时，this就会绑定为其他组件的实例，在获取原实例的状态时就会发生错误。&lt;/p&gt;

&lt;p&gt;箭头函数的this绑定和普通函数不一样，它是静态绑定的，也就是说箭头函数的this绑定是在定义时绑定的，即定义箭头函数时所处的作用域的this。所以说如果React组件中的函数是用箭头函数的形式定义的话，就不用担心this绑定的问题。&lt;/p&gt;

&lt;p&gt;假如你的onClick事件处理函数在被触发时需要传参，如果直接 &lt;code&gt;onClick={this.handleClick(xxx)}&lt;/code&gt; 话，onClick得到的就不是函数，而是函数返回的结果，所以应使用 &lt;code&gt;onClick={() =&amp;gt; this.handleClick(xxx)}&lt;/code&gt; ，即给onClick一个箭头函数作为事件处理函数，那么this就绑定为了当前组件的实例，调用的普通函数也不用做特殊的处理。&lt;/p&gt;

&lt;p&gt;我犯了一个最基础也最致命的问题，在渲染中进行了状态的改变！按理说我不应该会犯这种错误，我犯这种错误的原因就是我将箭头函数和普通函数结合使用（模仿的项目中的老代码）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;handleInput(key) {
  return (e) =&amp;gt; {
      let inputValue = {}
      inputValue[key] = e.target.value
      this.setState({
      data: Object.assign({}, this.state.data, inputValue)
      })
  }
}
onChange={this.handleInput(xxx)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看出和之前 &lt;code&gt;onClick={() =&amp;gt; this.handleClick(xxx)}&lt;/code&gt; 的不同了么？&lt;br /&gt;
这里是由普通函数将箭头函数return了出来，所以函数渲染时立即执行handleInput，并将执行后的箭头函数传给onChange，顺便完成this绑定，Emmmm，秀啊！可惜当初我没搞懂这个用意，将handleInput彻底改成了普通函数，导致在渲染时执行了this.setState()，浏览器不停的改变状态和渲染，瞬间报错0～20000+，不得不强制杀死浏览器进程&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;总结react组件中的函数this绑定的几种方法&#34;&gt;总结React组件中的函数this绑定的几种方法&lt;/h3&gt;

&lt;p&gt;一、每当作为事件处理函数时，例如：&lt;code&gt;onClick onChange&lt;/code&gt; 等，都手动绑定一次&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 这种方法的好处是在绑定this的同时能传递参数
onClick={this.handleClick.bind(this, args)}
// 缺点是，每次都得手动调用bind()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、在构造函数中绑定一次，一劳永逸&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 缺点是不能传递参数
this.handleCLick = this.handleClick.bind(this)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三、React组件的函数直接定义成箭头函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;handleClick = (args) =&amp;gt; {xxxxx}
// 缺点也是不能传递参数
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;上述三个做法有个矛盾，就是“一次绑定”和“传递参数”不能兼顾&lt;br /&gt;
对于二、三方法，要实现传递参数，就得使用箭头函数，即&lt;br /&gt;
&lt;code&gt;onClick = {() =&amp;gt; this.handleClick(args)}&lt;/code&gt;&lt;br /&gt;
既然使用了箭头函数，那么二三方法中的绑定就没有必要了，这虽然是个好方法，但是看书写的代码量和第一种方法又有什么区别呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;四、普通函数返回一个箭头函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 这是在实习期做项目时前辈的一个做法，感觉还不错
// 这种方法的原理就是在普通函数中返回一个箭头函数，  
// 在渲染时立即执行该函数，接收箭头函数作为事件处理函数，完成绑定的同时又传递了参数  
handleClick (args) {
  return () =&amp;gt; {
    balabalabala...
  }
}
onClick = {this.handleClick(args)}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Array</title>
      <link>https://hueralin.github.io/2019/array/</link>
      <pubDate>Mon, 19 Aug 2019 15:46:37 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/array/</guid>
      <description>

&lt;h1 id=&#34;array&#34;&gt;Array&lt;/h1&gt;

&lt;p&gt;Emmmm, Array的函数不少，至少我觉的是这样。随着ES的发展，Array多了许多奇奇怪怪的函数。&lt;br /&gt;
虽说奇怪&amp;hellip;.但用起来超爽的啊！！！！&lt;/p&gt;

&lt;h3 id=&#34;什么-想要查找数组中的某个元素&#34;&gt;什么？想要查找数组中的某个元素？&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Array.find()&lt;/strong&gt; 拿走不送！&lt;br /&gt;
该函数接受两个参数：callback、thisObj&lt;br /&gt;
在回调函数中return符合查找条件的元素，若查找成功则直接返回该元素的值，否则返回undefined，并且不会改变原素组，简直不要太爽！&lt;br /&gt;
如果想要查找某个元素的索引的话，可以使用 Array.findIndex() 函数，找不到的话返回-1。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>后台管理系统</title>
      <link>https://hueralin.github.io/2019/athene/</link>
      <pubDate>Wed, 07 Aug 2019 10:49:37 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/athene/</guid>
      <description>

&lt;h3 id=&#34;这是实习期一个后台管理的项目&#34;&gt;这是实习期一个后台管理的项目&lt;/h3&gt;

&lt;p&gt;目前正在熟悉该项目，边熟悉，边做一些记录&lt;/p&gt;

&lt;p&gt;先来看一下大体的框架：&lt;br /&gt;
&lt;strong&gt;顶层容器&lt;/strong&gt;&lt;br /&gt;
在container目录下的index.js文件中，有一个IndexContainer组件，该组件中的render函数是这么写的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;render () {
    let { permission } = this.props
    return (
        &amp;lt;div&amp;gt;
        &amp;lt;Header params={this.props.params} username={permission.username} /&amp;gt;
        &amp;lt;div className=&#39;main-content&#39;&amp;gt;
            &amp;lt;SideNav routes={this.props.routes} permissions={permission.permission} /&amp;gt;
            &amp;lt;div&amp;gt;
            {this.props.children}
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出该系统采用了非常常见的布局，即‘顶部导航+左侧导航+右侧内容’&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;路由配置&lt;/strong&gt;&lt;br /&gt;
因为路由比较多，所有路由配置分为两个路由文件：&lt;br /&gt;
&lt;em&gt;外层路由文件&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 这里引入了内层路由文件  
import routers from &#39;./routers&#39;
module.exports = (
  &amp;lt;Router history={browserHistory}&amp;gt;
    &amp;lt;Route path=&#39;/&#39; /&amp;gt;
    &amp;lt;Route path=&#39;/xxx&#39; component={xxx} /&amp;gt;
    &amp;lt;Route path=&#39;/xx/xx&#39; component={xx} /&amp;gt;
    ......
    &amp;lt;Route path=&#39;&#39; component={Container} onEnter={handleEnterSystem}&amp;gt;
      {/* 嵌套路由，内层路由文件里的Route渲染的组件都是Container容器下的子组件，在this.props.children处渲染*/}
      { routers }
    &amp;lt;/Route&amp;gt;
    &amp;lt;Redirect from=&#39;*&#39; to=&#39;/error/404.html&#39; /&amp;gt;
  &amp;lt;/Router&amp;gt;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;内层路由组件&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Router = (
  &amp;lt;Route path=&#39;/xxx&#39;&amp;gt;
    &amp;lt;IndexRoute component={Page} /&amp;gt;
    &amp;lt;Route path=&#39;yyy/product&#39; component={ProductList} /&amp;gt;
    &amp;lt;Route path=&#39;yyy/product/:id&#39; component={Product} /&amp;gt;
    &amp;lt;Route path=&#39;yyy/users/:id&#39; component={Users} /&amp;gt;
    ......
  &amp;lt;/Route&amp;gt;
)
module.exports = Router
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ES2016/2017新特性</title>
      <link>https://hueralin.github.io/2019/es20162017etc/</link>
      <pubDate>Tue, 06 Aug 2019 11:56:42 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/es20162017etc/</guid>
      <description>

&lt;h3 id=&#34;es2016-es7&#34;&gt;ES2016(ES7)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Array.prototype.includes(value): 判断一个元素是否在数组中&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let a = [1,2,3,4,5,6]  
a.includes(4)   // true  
a.includes(7)   // false  

// 功能类似于 xxx.indexOf(y) &amp;gt; -1, 但有不同  
// includes可以检测Nan  (indexO不可以)
[NaN].includes(NaN) // true

// 不区分 -0 +0 （indexOf也可以）
[-0].includes(+0)   // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;求幂运算&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let a = 3
a ** 2      // 9
// 相当于 Math.pow(a, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;es2017-es8&#34;&gt;ES2017(ES8)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;String.prototype.padStart / String.prototype.padEnd（字符串填充）&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;功能：返回指定长度的填充后的字符串  
语法：str.padStart(len [, padStr])  // len 指定长度 padStr 填充字符串  
let str = &#39;huer&#39;  
// 1. 指定长度小于原字符串长度，则返回原字符串    
str.padStart(2)  // &#39;huer&#39;
// 2. 指定长度大于原字符串长度，则返回填充字符串（默认为空格）+原字符串  
str.padStart(5)  // &#39; huer&#39;  
// 3. 原字符串 &amp;lt; 指定长度 &amp;lt; 填充字符串 + 原字符串，则从填充字符串的右侧截取  
str.padStart(7, &#39;malin&#39;)    // &#39;malhuer&#39;  
// 4. 指定长度 &amp;gt; 填充字符串 + 原字符串, 重复填充字符串，使其达到指定长度  
str.padStart(10, &#39;a&#39;)       // &#39;aaaaaahuer&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Object.values / Object.entries&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Object.values(obj): 返回obj的可遍历属性的 ‘属性值’ 数组&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Object.entries(obj): 返回obj的可遍历属性的 ‘键值对’ 数组&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Object.getOwnPropertyDescriptors&lt;/strong&gt;&lt;br /&gt;
该函数返回对象的属性描述符&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;函数定义和函数调用的参数列表最后面的尾逗号&lt;/strong&gt;&lt;br /&gt;
Emmmm，就是说下面这种情况不会报错，有什么作用？？？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Func(a,b,) {xxx}
Func(1,2,)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;异步函数 async/await&lt;/strong&gt;&lt;br /&gt;
to be continued&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React_router配置</title>
      <link>https://hueralin.github.io/2019/react_router/</link>
      <pubDate>Mon, 05 Aug 2019 14:24:46 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/react_router/</guid>
      <description>

&lt;p&gt;最近在学习React-router遇到了一些问题，在此记录一下：&lt;br /&gt;
目前成功的配置为：&lt;br /&gt;
&lt;strong&gt;app.jsx&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;
import { HashRouter as Router, Route } from &#39;react-router-dom&#39;
import Content from &#39;./components/Content.jsx&#39;
import About from &#39;./components/About.jsx&#39;
import Posts from &#39;./components/Posts.jsx&#39;
import Post from &#39;./components/Post.jsx&#39;

ReactDOM.render(
    &amp;lt;Router&amp;gt;
        &amp;lt;Content&amp;gt;
            &amp;lt;Route path=&#39;/about&#39; component={About}&amp;gt;&amp;lt;/Route&amp;gt;
            &amp;lt;Route path=&#39;/posts&#39; component={Posts}&amp;gt;&amp;lt;/Route&amp;gt;
            &amp;lt;Route path=&#39;/posts/:id&#39; component={Post}&amp;gt;&amp;lt;/Route&amp;gt;
        &amp;lt;/Content&amp;gt;
    &amp;lt;/Router&amp;gt;,
    document.getElementById(&#39;app&#39;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Content.jsx&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;
import { Link } from &#39;react-router-dom&#39;

class Content extends React.Component {
    render () {
        return &amp;lt;div&amp;gt;
            &amp;lt;ul&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;Link to=&#39;/&#39;&amp;gt;主页&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;Link to=&#39;/posts&#39;&amp;gt;博文&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;Link to=&#39;/about&#39;&amp;gt;关于&amp;lt;/Link&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
            {this.props.children}
        &amp;lt;/div&amp;gt;
    }
}

export default Content
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，这里是用的是 react-router-dom（v5.0.1），而不是react-router&lt;/p&gt;

&lt;h3 id=&#34;react-router-dom的三个基本组件&#34;&gt;react-router-dom的三个基本组件&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Router Component&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Route matching Component&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Navigation Component&lt;br /&gt;
这三个组件都必须从 react-router-dom中导入&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;router-component&#34;&gt;Router Component&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;BrowserRouter&amp;gt;&lt;/code&gt;：用于使用服务器来处理请求的情况&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;HashRouter&amp;gt;&lt;/code&gt;：用于静态文件服务&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;HashRouter&lt;/strong&gt;&lt;br /&gt;
哈希路由用来兼容传统浏览器&lt;br /&gt;
HashRouter几个常见的参数：&lt;br /&gt;
1. &lt;code&gt;basename&lt;/code&gt; 用来指定统一的前缀&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;HashRouter basename=&#39;/huer&#39;&amp;gt;
    &amp;lt;Link to=&#39;/about&#39;&amp;gt;狐耳&amp;lt;/Link&amp;gt;
&amp;lt;/HashRouter&amp;gt;
// 即&#39;#/huer/login&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;route-matching-component&#34;&gt;Route Matching Component&lt;/h3&gt;

&lt;p&gt;路由匹配组件主要是用来根据不同的path来显示不同的component的，如果一个路由匹配组件没有设置path路径，那么它总会被匹配到。当一个Route的path匹配到当前的location&amp;rsquo;s pathname，就会渲染component属性所对应的内容，若没有匹配到，就会render null。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// when location = { pathname: &#39;/about&#39; }
&amp;lt;Route path=&#39;/about&#39; component={About}/&amp;gt; // renders &amp;lt;About/&amp;gt;
&amp;lt;Route path=&#39;/contact&#39; component={Contact}/&amp;gt; // renders null
&amp;lt;Route component={Always}/&amp;gt; // renders &amp;lt;Always/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Route&lt;/code&gt;：&lt;code&gt;&amp;lt;Route path=&#39;/user&#39; component={User}&amp;gt;&lt;/code&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Switch&lt;/code&gt;：&lt;code&gt;&amp;lt;Switch&amp;gt;一组&amp;lt;Route&amp;gt;&amp;lt;/Switch&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一个Switch组件包含一组Route组件，但并不是必须的。Switch组件会迭代它的子Route组件，并且只渲染第一个匹配到的Route，这在许多Route组件匹配到同一个pathname时非常有用。在没有匹配到合适的pathname时，它可以在最下面设置一个无path的Route组件，表示匹配不到时的组件，例如404页面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;Switch&amp;gt;
  &amp;lt;Route exact path=&amp;quot;/&amp;quot; component={Home} /&amp;gt;
  &amp;lt;Route path=&amp;quot;/about&amp;quot; component={About} /&amp;gt;
  &amp;lt;Route path=&amp;quot;/contact&amp;quot; component={Contact} /&amp;gt;
  {/* when none of the above match, &amp;lt;NoMatch&amp;gt; will be rendered */}
  &amp;lt;Route component={NoMatch} /&amp;gt;
&amp;lt;/Switch&amp;gt;

// 当前位置：/about ，那么About User NoMatch都会被渲染
&amp;lt;Route path=&amp;quot;/about&amp;quot; component={About}/&amp;gt;
&amp;lt;Route path=&amp;quot;/:user&amp;quot; component={User}/&amp;gt;
&amp;lt;Route component={NoMatch}/&amp;gt;
// 若使用Switch包裹起来，则匹配到第一个何时的就结束了，不会继续向下匹配
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;navigation&#34;&gt;Navigation&lt;/h3&gt;

&lt;p&gt;导航链接组件，有三种：&lt;br /&gt;
&lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// to: string  
&amp;lt;Link to=&amp;quot;/courses?sort=name&amp;quot; /&amp;gt;  
// to: object  
&amp;lt;Link
  to={{
    pathname: &amp;quot;/courses&amp;quot;,           // 路径名
    search: &amp;quot;?sort=name&amp;quot;,           // 查询字符串
    hash: &amp;quot;#the-hash&amp;quot;,              // 锚点
    state: { fromDashboard: true }  // 保留到该位置的状态
  }}
/&amp;gt;
// to: func  
&amp;lt;Link to={location =&amp;gt; ({ ...location, pathname: &amp;quot;/courses&amp;quot; })} /&amp;gt;  
&amp;lt;Link to={location =&amp;gt; `${location.pathname}?sort=name`} /&amp;gt;  
// 其实返回对象或字符串，即上面两种用法  
// replce  当值为true时，替换历史记录栈而不是新增一个记录
&amp;lt;Link to=&#39;/login&#39; replace&amp;gt;&amp;lt;/Link&amp;gt;  
// exact代表当前路由path的路径采用精确匹配,不然像下面的代码（若没有exact），匹配/时也会渲染about
// 嵌套路由不要加exact属性
&amp;lt;Link exact to=&#39;/&#39;&amp;gt;&amp;lt;/Link&amp;gt;
&amp;lt;Link to=&#39;/about&#39;&amp;gt;&amp;lt;/Link&amp;gt;
// 其他的属性，例如title,id,className等也可以加上
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;NavLink&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// activeClassName  被选中时应用该样式  
&amp;lt;NavLink to=&amp;quot;/faq&amp;quot; activeClassName=&amp;quot;selected&amp;quot;&amp;gt;FAQs&amp;lt;/NavLink&amp;gt;
// activeStyle 同理，接受一个对象  
// isActive：func 匹配时执行的回调函数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;Redirect&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 重定向本来就是定向到其他URL，本质上就是replace，现有 ‘push’ 属性，代表想历史记录栈中加入一条历史记录，而不是替换。  
&amp;lt;Redirect push to=&#39;/about&#39;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;match&lt;/strong&gt;&lt;br /&gt;
match对象包含一些路由匹配的信息，match对象从this.props.match中获取&lt;br /&gt;
它包含以下四个属性：&lt;br /&gt;
1. params：&lt;br /&gt;
2. isExact：是否精确匹配&lt;br /&gt;
3. path：即写在Route中的path匹配模式&lt;br /&gt;
4. url：实际的path&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>敏捷开发</title>
      <link>https://hueralin.github.io/2019/mjkf/</link>
      <pubDate>Thu, 01 Aug 2019 17:10:22 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/mjkf/</guid>
      <description>&lt;p&gt;敏捷宣言&lt;/p&gt;

&lt;p&gt;12条原则&lt;/p&gt;

&lt;p&gt;Scrum&lt;/p&gt;

&lt;p&gt;XP(极限编程)&lt;br /&gt;
1. 结对编程&lt;br /&gt;
2. 测试驱动开发：单元测试，重构&lt;br /&gt;
3. 持续集成&lt;br /&gt;
4. 代码集体所有（统一规范，任何人写的代码，任何人都能维护）&lt;br /&gt;
5. 现场客户&lt;/p&gt;

&lt;p&gt;精益思维&lt;br /&gt;
1. 消除浪费&lt;br /&gt;
2. 增强学习&lt;br /&gt;
3. 尽量延迟决定&lt;br /&gt;
4. 尽快发布&lt;br /&gt;
5. 下放权力&lt;br /&gt;
6. 嵌入质量&lt;br /&gt;
7. 全局优化&lt;/p&gt;

&lt;p&gt;FDD-特性驱动开发&lt;/p&gt;

&lt;p&gt;看板（白板）&lt;/p&gt;

&lt;p&gt;MoSCoW&lt;/p&gt;

&lt;p&gt;估算&lt;br /&gt;
估算纸牌（数字高代表能力强，数字代表和参照物相比该任务的复杂度，每个人对同一个任务的估算是不同的）&lt;/p&gt;

&lt;p&gt;技术债务&lt;/p&gt;

&lt;p&gt;迭代开发 增量交付 自组织团队 高价值的优先级排序&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Webpack4 配置文件解析</title>
      <link>https://hueralin.github.io/2019/webpack4/</link>
      <pubDate>Mon, 29 Jul 2019 18:54:31 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/webpack4/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let path = require(&#39;path&#39;)
// 创建HTML模板的插件
let HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)
// 抽离CSS样式为单独文件的插件（原来都是将CSS样式全部放进了style里面）
let MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;)
// 优化CSS的插件（压缩CSS文件）
let OptimizeCss = require(&#39;optimize-css-assets-webpack-plugin&#39;)
// 用了上面优化CSS的插件，就得使用下面这个插件来优化JS（压缩JS文件）
let UglifyJsWebpackPlugin = require(&#39;uglifyjs-webpack-plugin&#39;)

module.exports = {

    // 优化CSS和JS
    // 优化项
    optimization: {
        // 压缩
        minimizer: [
            new UglifyJsWebpackPlugin({
                cache: true,    // 缓存
                parallel: true, // 并发压缩
                sourceMap: true // 
            }),
            new OptimizeCss()
        ]
    },

    // 模式：开发和生产模式两种
    mode: &#39;development&#39;,
    entry: &#39;./src/index.js&#39;,
    output: {
        // path 必须是绝对路径
        // path.resolve()可以将相对路径解析为绝对路径
        // __dirname 是当前目录
        path: path.resolve(__dirname, &#39;build&#39;),
        // 加上hash，每次都生成一个新的文件(不重复 ，防止出现缓存或覆盖的问题)（8位hash值）
        filename: &#39;bundle.[hash:8].js&#39;

    },
    devServer: {
        port: 3000,
        // 显示进度条
        progress: true,
        //  以build目录为静态服务的根目录(所有被服务的内容都来自这里)
        contentBase: &#39;./build&#39;,
        // 启动时自动打开浏览器
        open: true,
        // 使用gzip压缩所有被服务的文件
        compress: true
    },
    plugins: [
        // 这个插件可以按照模板生成一个index.html文件，并插入打包后的bundle.js文件
        new HtmlWebpackPlugin({
            // 指定模板文件
            template: &#39;./src/index.html&#39;,
            // 打包后的文件名
            filename: &#39;index.html&#39;,
            // 上线时的压缩操作
            minify: {
                // 去掉属性的引号
                removeAttributeQuotes: true,
                // （压缩）变成单行
                collapseWhitespace: true,
            },
            // 在引用文件名尾部加一个hash串
            hash: true
        }),
        new MiniCssExtractPlugin({
            // 抽离出来的CSS文件的名字
            filename: &#39;main.css&#39;
        })
    ],
    module: {   // 模块
        rules: [    // 规则
            {
                // css-loader是来处理 css文件中@import语法的
                // style-loader 是来将css文件插入到html中的style标签里去的
                // 使用单个loader只需要一个字符串表示，
                // 使用多个loader需要用数组
                // loader的顺序，从右向左执行

                // loader还可以用对象表示法（ 即数组元素为对象而不是字符串），该方法下可以传个option
                test: /\.css$/,
                use: [
                    // {
                    //     loader: &#39;style-loader&#39;,
                    //     options: {
                    //         // 将CSS文件插入到模板HTML自定义样式的上方
                    //         insertAt: &#39;top&#39;
                    //     }
                    // }
                    // 使用MiniCssExtractPlugin插件的loader，通过link引用CSS文件
                    MiniCssExtractPlugin.loader
                    , &#39;css-loader&#39;
                    , {
                        loader: &#39;postcss-loader&#39;,
                        options: {
                            plugins: [
                                require(&#39;autoprefixer&#39;)
                            ]
                        }
                    }]     // 自动加前缀，兼容浏览器
            },
            {
                test: /\.less$/,
                use: [
                    MiniCssExtractPlugin.loader
                    , &#39;css-loader&#39;
                    ,  {
                        loader: &#39;postcss-loader&#39;,
                        options: {
                            plugins: [
                                require(&#39;autoprefixer&#39;)
                            ]
                        }
                    } // 加前缀
                    ,  &#39;less-loader&#39;    // 处理less文件   
                ]      
            }
        ]
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>汉服那么美，为何现在流行不起来</title>
      <link>https://hueralin.github.io/2019/hjjh-02/</link>
      <pubDate>Sun, 28 Jul 2019 12:27:50 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/hjjh-02/</guid>
      <description>&lt;ol&gt;
&lt;li&gt;出行不便（生活节奏）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;价格昂贵（手工刺绣，配饰）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;身材和气质（汉服对这两点要求有点高）&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;普及范围狭窄（汉服知识？恐怕得考古好久）&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;服装和文化一样，要与时俱进。要想发扬汉服文化，让汉服流行起来，不能一味的追求历史（此言不当，不知如何表述），应该结合当下的形式，做出一些改进，这算不上“取其精华，去其糟粕”，古代的穿衣礼节，穿衣过程确有其繁琐的地方，放到现代来确实让人难以接受，这也是汉服流行不起来的原因之一。我们不能一味的遵从汉服文化而渐渐变得复古，这也是不可能的。最近在相关贴吧上看到过这样一个帖子，有个小姐姐晒出汉服写真却被一群大叔嘲讽，不懂汉服历史，穿着不伦不类，不认同这是汉服，戏称为“花衣服”。大叔们有这种想法也无可厚非，毕竟现在的穿汉服的人多多少少也搭配着一些现代的服饰，比如手表、小白鞋，还有大叔们嘲讽的丝袜，小姐姐面对嘲讽也是欲哭无泪&amp;hellip;&lt;/p&gt;

&lt;p&gt;小姐姐错了么？大叔们错了么？&lt;/p&gt;

&lt;p&gt;在我看来，此事无关对错。现在的年轻人穿汉服无非两个原因，其一是服饰着实好看，其二是想为发扬中国传统文化献上一份力量。曾经抖音上的一个短视频对我产生了一丝丝触动，一个女孩儿边哭变向床上扔着一件件汉服，边扔边说“我穿汉服上街怎么了？我喜欢汉服，这有错么，碍着你们了？一个个用异样的眼光看我，甚至还嘲讽我穿着奇装异服”，“在日本韩国，这在他们看来是很正常不过的事情，为什么在国内穿传统服装却被看作异类”（Emmm，原话忘了，大体这个意思吧）这段话引起了我的思考&lt;/p&gt;

&lt;p&gt;至于思考了啥？晚上回去再说，学习！😂&lt;/p&gt;

&lt;p&gt;to be continue&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>汉家江湖-起源</title>
      <link>https://hueralin.github.io/2019/hjjh-01/</link>
      <pubDate>Sun, 28 Jul 2019 12:22:08 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/hjjh-01/</guid>
      <description>&lt;p&gt;不知何时起，对汉服有了兴趣～&lt;/p&gt;

&lt;p&gt;能做什么？
1. 维护一个像B站二次元的网站（搞活动）
2. 汉服实体店
3. 联动武侠IP，电影？动漫？
4. 侠客栈（民宿）
5. IP手办？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>实习项目的Header结构解析</title>
      <link>https://hueralin.github.io/2019/zkheader/</link>
      <pubDate>Sun, 28 Jul 2019 00:07:10 +0800</pubDate>
      
      <guid>https://hueralin.github.io/2019/zkheader/</guid>
      <description>&lt;p&gt;最近在做公司的项目，更改移动端Header的现有布局。&lt;br /&gt;
Header是React组件，点击按钮出现侧边栏导航。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面简单来介绍一下Header的结构：&lt;/strong&gt;&lt;br /&gt;
Header接受了3个props，分别是“userInfo”、“changeNavState”、“style”。&lt;br /&gt;
userInfo是用户信息，changeNavState是用来更改侧边导航状态的函数，style是一个类样式。&lt;/p&gt;

&lt;p&gt;以上几个props都交由PropTypes来验证参数的合法性。&lt;br /&gt;
该Header组件内仅维护了一个状态，那就是 subNav，即侧边导航栏的显示与否，changeNavState函数改变的就是它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在render渲染函数中：&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;const { userInfo, style } = this.props&lt;/code&gt;&lt;br /&gt;
根据是否有userInfo.avatar属性来初始化headUrl变量（有则赋值为用户头像URL，无则赋值为默认头像URL）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接下来return一个JSX，&lt;/strong&gt;&lt;br /&gt;
首先判断subNav是否为真，真则显示侧边导航。&lt;br /&gt;
然后是左右布局，左边是点击显示侧边导航的下拉按钮和点击能返回主页的LOGO，右边是用户头像。&lt;br /&gt;
左边的导航按钮添加点击事件（调用changeNavState函数），通过控制subNav状态来显示和隐藏侧边导航。&lt;br /&gt;
右边判断userInfo.id属性，有则根据headeUrl显示用户头像，否则显示默认头像。默认头像图标添加点击跳转登录事件。&lt;/p&gt;

&lt;p&gt;其中userInfo属性是由connect函数连接的， userInfo来自于Redux的State。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>